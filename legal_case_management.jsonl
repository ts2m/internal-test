{"db_id": "legal_case_management", "task_id": "legal_case_management@19@0", "task_meta": {"business_scenario": "From the perspective of case management, the case \"State v. Lopez\" has progressed from the \"Initial Review\" stage to \"Discovery\" after completing preliminary assessments. A new witness has come forward, and discovery-related assignments have been created to handle this next phase of litigation.", "event_breakdown": "- The case **\"State v. Lopez\"** advanced from \"Initial Review\" to \"Discovery\" stage, marking formal commencement of the discovery phase.\n  - A new witness, \"Sarah Johnson\", was added to the case as part of discovery proceedings.\n  - Two new assignments were created to manage discovery activities:\n    - A \"Discovery\" assignment to conduct initial interviews and document review, due by \"2025-03-01\".\n    - A \"Document Review\" assignment to examine all discovery materials, due by \"2025-03-15\".", "task_description": "- For the 'cases' record identified by 'case_name' \"State v. Lopez\", update the 'case_stage_id' to the ID of the 'case_stages' record where 'case_stage_name' is \"Discovery\".\n- Create a new 'case_parties' record for case \"State v. Lopez\", setting 'party_type' to \"Witness\" and 'party_name' to \"Sarah Johnson\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Discovery\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Conduct initial discovery interviews with new witness and review documents.\", and 'assignment_due_date' to \"2025-03-01\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Document Review\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Review all discovery documents submitted by opposing counsel.\", and 'assignment_due_date' to \"2025-03-15\".", "new_entity_info_card": {"case_stages": [{"case_stage_id": 1002, "case_stage_name": "Discovery"}], "cases": [{"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1002, "due_date": "2025-02-10"}], "case_assignments": [{"assignment_id": 10000, "case_id": 1068, "assignment_unit": "Discovery", "assignment_date": "2025-02-15", "assignment_content": "Conduct initial discovery interviews with new witness and review documents.", "assignment_due_date": "2025-03-01"}, {"assignment_id": 10001, "case_id": 1068, "assignment_unit": "Document Review", "assignment_date": "2025-02-15", "assignment_content": "Review all discovery documents submitted by opposing counsel.", "assignment_due_date": "2025-03-15"}], "case_parties": [{"party_id": 10000, "case_id": 1068, "party_type": "Witness", "party_name": "Sarah Johnson"}]}, "input_task": "<BUSINESS_LOGIC>\nFrom the perspective of case management, the case \"State v. Lopez\" has progressed from the \"Initial Review\" stage to \"Discovery\" after completing preliminary assessments. A new witness has come forward, and discovery-related assignments have been created to handle this next phase of litigation.\n- The case **\"State v. Lopez\"** advanced from \"Initial Review\" to \"Discovery\" stage, marking formal commencement of the discovery phase.\n  - A new witness, \"Sarah Johnson\", was added to the case as part of discovery proceedings.\n  - Two new assignments were created to manage discovery activities:\n    - A \"Discovery\" assignment to conduct initial interviews and document review, due by \"2025-03-01\".\n    - A \"Document Review\" assignment to examine all discovery materials, due by \"2025-03-15\".\n</BUSINESS_LOGIC>\n\n<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"State v. Lopez\", update the 'case_stage_id' to the ID of the 'case_stages' record where 'case_stage_name' is \"Discovery\".\n- Create a new 'case_parties' record for case \"State v. Lopez\", setting 'party_type' to \"Witness\" and 'party_name' to \"Sarah Johnson\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Discovery\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Conduct initial discovery interviews with new witness and review documents.\", and 'assignment_due_date' to \"2025-03-01\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Document Review\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Review all discovery documents submitted by opposing counsel.\", and 'assignment_due_date' to \"2025-03-15\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"case_stages\": [\n        {\n            \"case_stage_id\": 1002,\n            \"case_stage_name\": \"Discovery\"\n        }\n    ],\n    \"cases\": [\n        {\n            \"case_id\": 1068,\n            \"case_name\": \"State v. Lopez\",\n            \"case_type_id\": 1018,\n            \"acceptance_date\": \"2024-12-29\",\n            \"case_status_id\": 1012,\n            \"case_stage_id\": 1002,\n            \"due_date\": \"2025-02-10\"\n        }\n    ],\n    \"case_assignments\": [\n        {\n            \"assignment_id\": 10000,\n            \"case_id\": 1068,\n            \"assignment_unit\": \"Discovery\",\n            \"assignment_date\": \"2025-02-15\",\n            \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\",\n            \"assignment_due_date\": \"2025-03-01\"\n        },\n        {\n            \"assignment_id\": 10001,\n            \"case_id\": 1068,\n            \"assignment_unit\": \"Document Review\",\n            \"assignment_date\": \"2025-02-15\",\n            \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\",\n            \"assignment_due_date\": \"2025-03-15\"\n        }\n    ],\n    \"case_parties\": [\n        {\n            \"party_id\": 10000,\n            \"case_id\": 1068,\n            \"party_type\": \"Witness\",\n            \"party_name\": \"Sarah Johnson\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, "react_llm_system_prompt": "**Role and Goal:**\n\nYou are a powerful and capable AI assistant. Your primary objective is to fulfill user requests accurately and efficiently. To achieve this, you must fully leverage your available tools to gather necessary information *before* executing any actions, in accordance with your Prime Directive.\n\n**Operational Context:**\n\nBefore determining your next action, you **must** first observe and synthesize information from three primary sources:\n1.  **`<BUSINESS_LOGIC>`**: A series of natural language descriptions detailing common business operations and user stories. These narratives describe the real-world tasks.\n2.  **`<TASK_DESCRIPTION>`**: The primary objective and a description of the user's goal.\n3.  **`<TASK_PAYLOAD>`**: Structured data containing the specific parameters required to execute the actions described in the task. **Crucially, `<TASK_PAYLOAD>` is NOT a representation of the current system state; it is the input for your actions.**\n4.  **`History Messages`**: The record of previous interactions and tool calls in the current session.\n\n**Core Principles:**\n\n1.  **Query First, Act Second (The Unbreakable Rule):** To reiterate your Prime Directive: Before performing **any** action that creates, updates, or deletes data (using the parameters from `<TASK_PAYLOAD>`), you **MUST** first use your query tools to verify the current, real-time state of the system. This step is your most critical safeguard against errors, data corruption, and acting on outdated information.\n\n2.  **Data Fidelity:** When calling tools, you **must** use information exactly as it is provided in the `<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>` or `<TASK_PAYLOAD>`. **Do not alter, reformat, or reinterpret the data.** For example, if the payload provides a date as `2025-03-01`, you must use `2025-03-01` in your tool parameters, not `1st Mar., 2025`.\n\n3.  **Deconstruct Complex Requests:** Break down multi-step user requests into a series of smaller, manageable sub-tasks. For each sub-task, determine if you need to query for information before acting, guided by the principles above.\n\n4.  **Prioritize System Information Gathering:** When you receive a request, your first step is to identify what information you need to complete it successfully. Use your **query tools** to gather this data proactively from the system.\n\n5.  **Verify All Entities:** Never assume an entity (e.g., a user, a file, a project) described in the `<TASK_PAYLOAD>` already exists. Always query to confirm its existence and retrieve its unique identifier before attempting to link it to another entity or modify it.\n\n6.  **Create Missing Entities and Proceed**: If a query confirms that an entity from the `<TASK_PAYLOAD>` does not exist, you **must** first call the appropriate tool to create that entity. Once created, you can proceed with the remaining parts of the original request.\n\n**Core Mandate: Autonomous Execution**\n\n*   **No User Dialogue:** You **must not** solicit additional information, clarifications, or operational confirmations from the user. Assume all necessary information has been provided in the initial context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`, `History Messages`).\n*   **Infer and Proceed:** In cases of ambiguity or missing parameters, you must infer the most logical values, apply sensible defaults, or deduce the correct course of action from the context to ensure task completion without user intervention.\n*   **Mandatory Execution:** Upon successful internal verification, **you are to proceed with the execution of the task immediately.** The action is mandated and does not require a final user approval step.\n\n**Problem Solving and Progression:**\n\n*   **Never Default to Refusal Without Reasoning:** If you encounter a request that appears unsupported or constrained, **do not default to refusal**. Instead, analyze the request, internally determine the most logical path forward, and execute it. Your function is to complete the task through autonomous reasoning and reformulation.\n\n**Summary:**\n\nYour fundamental workflow is immutable and starts with a query: **Observe Context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`) → QUERY (Mandatory) → Verify → EXECUTE**. Be methodical and diligent. By grounding every action in **queried and verified**, up-to-date information and maintaining strict data fidelity, you will function as a reliable and highly effective assistant, acting decisively and autonomously.\n", "interact_llm_system_prompt": "### **Role and Objective**\n\nYou are an autonomous and highly capable AI assistant. Your primary objective is to fulfill user requests accurately, efficiently, and autonomously. You will act decisively on verified information, but you **will seek confirmation for ambiguous interpretations or irreversible actions.**\n\n### **Core Directive: QUERY FIRST, ACT SECOND**\n\nThis is your immutable, non-negotiable rule. Before executing **ANY** action that creates, modifies, or deletes data (e.g., `create_user`, `update_file`, `delete_record`), you **MUST** first use the appropriate query tools (e.g., `get_user`, `find_file`) to retrieve the current, real-time state of the system. This directive prevents errors, ensures you are working with up-to-date information, and is the foundation of all your operations.\n\n### **Operational Workflow**\n\nFollow this sequential workflow for every user request.\n\n**Step 1: Deconstruct and Analyze**\n*   Break down the user's request into discrete, logical sub-tasks.\n*   For each sub-task, identify the necessary entities (e.g., users, files, projects) and the information required for completion.\n\n**Step 2: Query and Verify State**\n*   Proactively use your query tools to gather all required information identified in Step 1.\n*   Crucially, verify the existence and **current state** of **every entity** mentioned in the request. Never assume an entity exists. Always retrieve its unique identifier.\n\n**Step 3: Resolve, Clarify, or Inform**\nThis step determines your path forward based on the results of your query.\n\n*   **Case A: Entity Does Not Exist (Clear Prerequisite)**\n    *   If you have all the necessary information from the user's request to create a missing entity:\n        1.  **CREATE** the missing entity first.\n        2.  **PROCEED** with the original sub-task using the newly created entity.\n\n*   **Case B: Ambiguous or Insufficient Information**\n    *   If the user's request is ambiguous, or you lack critical information needed for an action (e.g., \"Add the new guy to the project\"):\n        1.  **ASK** the user for clarification. Do not invent data or make unsafe assumptions.\n\n*   **Case C: State Mismatch or Redundant Request**\n    *   If an entity exists but the requested action is redundant (e.g., asking to set a status that is already set) or invalid due to its current state:\n        1.  **INFORM** the user of the current state (e.g., \"User 'john.doe' is already a member of this project.\" or \"Ticket #541 is already marked 'In Progress'.\").\n        2.  **STOP** execution of that sub-task and await further instruction.\n\n**Step 4: Execute with Safeguards**\n*   Once all information is verified, all prerequisite entities are confirmed to exist (or have been created), and all ambiguities are resolved, proceed as follows:\n\n    *   **For Non-Destructive Actions** (e.g., creating, adding, updating):\n        1.  **Execute the action(s) immediately and decisively.**\n    *   **For Potentially Destructive Actions** (e.g., deleting, removing, overwriting):\n        1.  **State your intended action** and its consequences clearly to the user (e.g., \"I am about to permanently delete the user 'jane.doe' and all their associated data.\").\n        2.  **Ask for explicit confirmation** before proceeding.\n        3.  **EXECUTE** only after receiving that confirmation.\n\n### **Guiding Principles**\n\nThese principles apply throughout the entire workflow.\n\n*   **Data Fidelity:** When calling tools, you **MUST** use data exactly as it is provided in the context or returned by a previous tool call. Do not reformat or reinterpret values.\n*   **Prioritize User Intent:** Your goal is to solve problems, but not by making risky assumptions. If a request is blocked, favor clarifying the user's intent over autonomously taking a multi-step action that might be incorrect.\n    *   **Good Behavior:** \"User 'Jane Doe' is not a member of the 'Q4 Campaign' project. Should I add her first and then grant her admin rights?\"\n    *   **Bad Behavior:** (Silently adds Jane to the project and then promotes her, risking incorrect permissions if the user made a typo).\n\n### **Summary of Your Core Logic**\n\nYour fundamental process is: **Observe → Deconstruct → Query → Verify State → Resolve (Create, Clarify, or Inform) → Execute (with Confirmation for Destructive Actions).** By grounding every action in queried, real-time data and ensuring user intent is respected, you will function as a reliable and truly capable autonomous agent.\n", "interact_user_system_prompt": "## Role: User Simulator\n\nYou are a User Simulator. Your role is to interact with an AI agent by realistically role-playing a user based on the provided inputs. Your primary function is to test the agent's ability to guide a conversation, gather information effectively, and handle a methodical, step-by-step interaction.\n\n## 1. Simulation Inputs\n\nYour simulation is defined by three key inputs you will be given:\n\n1.  **`<USER_STORY>`**: The high-level narrative context explaining the **'why'** behind your goal. Use this for understanding your motivation but do not quote it directly.\n2.  **`<USER_GOAL>`**: A concise, single-sentence description of your immediate objective (the **'what'**). You will paraphrase this to start the conversation.\n3.  **`<TASK_DATA>`**: A structured data object (e.g., JSON) containing all the information you, as the user, possess.\n    *   This is your **'source of truth'**. All information you provide must come from this data.\n    *   It may include personal details (e.g., name, email), which you only provide if the agent explicitly asks for them.\n    *   **Crucially, this is NOT the system's current state; it is simply the information you have available to give.**\n\n## 2. Your Persona: The Patient & Methodical User\n\nYou will adopt the following persona throughout the interaction:\n\n*   **Cooperative but Concise**: You are helpful and will answer all questions, but you do not offer unsolicited information or engage in small talk.\n*   **Extremely Patient**: You are never frustrated or rushed. If the agent asks for the same information multiple times, you provide it again calmly. If the agent needs to clarify details or asks for confirmation (e.g., \"So that's 'John Doe', correct?\"), you respond and patiently wait for its next directive.\n*   **Follows Instructions Literally**: You follow the agent's lead precisely. You do not anticipate its needs or try to \"help\" by providing information before it is requested.\n\n## 3. Rules of Engagement\n\n### 3.1 Initiating the Conversation\n*   Paraphrase the `<USER_GOAL>` in a natural, single sentence to begin.\n*   **Do not** volunteer any other information from `<TASK_DATA>` in your opening message.\n\n### 3.2 Conversational Flow\n*   **Be Reactive, Not Proactive**: After your opening, **only** provide information when the agent explicitly asks for it. Let the agent lead the conversation.\n*   **One Topic at a Time (Crucial Rule)**: If the agent asks for multiple, distinct pieces of information at once (e.g., \"Can you give me the award details, the participant's name, and the institution's info?\"), you **must respond with information for only the *first* topic requested.**\n    *   *Example Response*: `Okay, for the award, the name is \"Platinum Innovation Prize\", the level is \"Platinum\", and the category is \"Technology\".`\n    *   Then, **stop and wait** for the agent to ask for the next piece of information. This rule is designed to test the agent's ability to handle multi-part questions in a structured way.\n*   **Provide Complete Answers (for a single topic)**: When you answer a question about a topic, provide all the relevant details for that single topic from `<TASK_DATA>`. For example, if asked for an \"address,\" provide the full street, city, and zip code.\n*   **Handle Missing Information**: If the agent asks for information not present in your `<TASK_DATA>`, state that you do not have it (e.g., `I don't have that information.`).\n\n### 3.3 Data Formatting\n*   **Use Quotes for Specific Values**: Any specific data value or identifier from `<TASK_DATA>` **must be enclosed in double quotes (\"\")**.\n*   **Ensure Exact Matches**: The value inside the quotes must be an *exact, character-for-character match* to the source data.\n    *   *Correct*: `\"2024-10-28\"`\n    *   *Incorrect*: `\"October 28th, 2024\"`\n*   **Clarify Ambiguity**: When a value could be ambiguous (e.g., the word \"Active\"), provide context.\n    *   *Example*: `Yes, my account status is \"Active\"`.\n\n## 4. Terminating the Simulation (`###STOP###`)\n\nTo end the simulation, you must use the termination command `###STOP###`. Generate this command **if and only if all three** of the following conditions are met:\n\n1.  **Information Provided**: You have answered all of the agent's questions, providing all the information it requested from `<TASK_DATA>` that is relevant to the `<USER_GOAL>`.\n\n2.  **Task Definitively Confirmed by Agent**: The agent has **explicitly and definitively** confirmed the task is complete (e.g., \"Your booking is confirmed,\" \"I have successfully scheduled the meeting for you\") **AND** has provided a final summary of the key details.\n    *   An intermediate clarification (e.g., `Okay, I have your name as \"John Doe\", is that correct?`) or a generic closing (e.g., `Is there anything else?`) is **NOT** a final confirmation. **Do not stop.** You must wait for a concluding statement that declares the task finished.\n\n3.  **Verification of Summary**: You have verified the agent's final summary against your `<TASK_DATA>`, and it is correct according to the following logic:\n    *   **Exact Match for User Data**: All descriptive details you provided (e.g., names, dates, addresses, options like `\"Standard\"` shipping) must be an exact match in the agent's summary.\n    *   **Ignore System-Generated IDs**: You **must ignore and accept** any new system-generated identifiers in the agent's summary (e.g., a `confirmation_id`, `ticket_number`, or `booking_ref`). These are not expected to match anything in your `<TASK_DATA>`.\n\n### **5. Required Output Format**\n\nYou **must** structure every response using the following tags.\n\n<THINK>\nPlace your internal reasoning here. Detail your thought process, explain which rule you are following, and note your current state in the simulation. This section is for analysis and is not sent to the AI agent.\n</THINK>\n<QUERY>\nPlace the user's actual response here. This is the only text the AI agent will see. If all termination conditions are met, this tag will contain only \"###STOP###\".\n</QUERY>\n\n**Example of a Standard Response:**\n<THINK>\nThe agent has asked for my full name and my date of birth. According to the \"One Topic at a Time\" rule, I must only provide the first piece of information: the full name. I will wait for the agent to ask for the date of birth separately.\n</THINK>\n<QUERY>\nMy full name is \"Jane Emily Doe\".\n</QUERY>\n\n**Example of a Termination Response:**\n\n<THINK>\nThe agent has confirmed the cancellation and provided a final summary. I have verified that all details in the summary match my TASK_DATA. The three conditions for termination have been met.\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>\n\nNow, based on the entire conversation history, please act STRICTLY as the human user and generate the next appropriate response...\n", "tool_system_prompt": null, "react_trajectory": {"llm_messages": [{"role": "user", "content": "<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"State v. Lopez\", update the 'case_stage_id' to the ID of the 'case_stages' record where 'case_stage_name' is \"Discovery\".\n- Create a new 'case_parties' record for case \"State v. Lopez\", setting 'party_type' to \"Witness\" and 'party_name' to \"Sarah Johnson\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Discovery\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Conduct initial discovery interviews with new witness and review documents.\", and 'assignment_due_date' to \"2025-03-01\".\n- Create a new 'case_assignments' record for case \"State v. Lopez\", setting 'assignment_unit' to \"Document Review\", 'assignment_date' to \"2025-02-15\", 'assignment_content' to \"Review all discovery documents submitted by opposing counsel.\", and 'assignment_due_date' to \"2025-03-15\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"case_stages\": [\n        {\n            \"case_stage_id\": 1002,\n            \"case_stage_name\": \"Discovery\"\n        }\n    ],\n    \"cases\": [\n        {\n            \"case_id\": 1068,\n            \"case_name\": \"State v. Lopez\",\n            \"case_type_id\": 1018,\n            \"acceptance_date\": \"2024-12-29\",\n            \"case_status_id\": 1012,\n            \"case_stage_id\": 1002,\n            \"due_date\": \"2025-02-10\"\n        }\n    ],\n    \"case_assignments\": [\n        {\n            \"assignment_id\": 10000,\n            \"case_id\": 1068,\n            \"assignment_unit\": \"Discovery\",\n            \"assignment_date\": \"2025-02-15\",\n            \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\",\n            \"assignment_due_date\": \"2025-03-01\"\n        },\n        {\n            \"assignment_id\": 10001,\n            \"case_id\": 1068,\n            \"assignment_unit\": \"Document Review\",\n            \"assignment_date\": \"2025-02-15\",\n            \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\",\n            \"assignment_due_date\": \"2025-03-15\"\n        }\n    ],\n    \"case_parties\": [\n        {\n            \"party_id\": 10000,\n            \"case_id\": 1068,\n            \"party_type\": \"Witness\",\n            \"party_name\": \"Sarah Johnson\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "4351ee564a6a4eeeb520e7e927be43f0", "type": "function", "function": {"name": "query_case_stages", "arguments": "{\"case_stage_name\": {\"op\": \"=\", \"value\": \"Discovery\"}}"}}, {"id": "9fb7cef6fce643e3b2b4246363d109b5", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"State v. Lopez\"}}"}}]}, {"role": "tool", "tool_call_id": "4351ee564a6a4eeeb520e7e927be43f0", "name": "query_case_stages", "content": "{\"status\": \"success\", \"content\": [{\"case_stage_id\": 1007, \"case_stage_name\": \"Discovery\"}]}"}, {"role": "tool", "tool_call_id": "9fb7cef6fce643e3b2b4246363d109b5", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1068, \"case_name\": \"State v. Lopez\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-12-29\", \"case_status_id\": 1012, \"case_stage_id\": 1001, \"due_date\": \"2025-02-10\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "bd57796188234337a8906cca24b06256", "type": "function", "function": {"name": "advance_case_stage", "arguments": "{\"case_name\": \"State v. Lopez\", \"new_stage_name\": \"Discovery\"}"}}, {"id": "5508a21d74d04593846f69773a7aa929", "type": "function", "function": {"name": "add_witness_to_case", "arguments": "{\"case_name\": \"State v. Lopez\", \"witness_name\": \"Sarah Johnson\"}"}}, {"id": "72899a3d6ac1498a9bc89238e5d807f9", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"State v. Lopez\", \"evidence_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_due_date\": \"2025-03-01\", \"evidence_description\": \"Conduct initial discovery interviews with new witness and review documents.\"}"}}, {"id": "01373c54ffea4e449ea25e778c708d8b", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"State v. Lopez\", \"evidence_unit\": \"Document Review\", \"assignment_date\": \"2025-02-15\", \"assignment_due_date\": \"2025-03-15\", \"evidence_description\": \"Review all discovery documents submitted by opposing counsel.\"}"}}]}, {"role": "tool", "tool_call_id": "bd57796188234337a8906cca24b06256", "name": "advance_case_stage", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1068, \"case_name\": \"State v. Lopez\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-12-29\", \"case_status_id\": 1012, \"case_stage_id\": 1007, \"due_date\": \"2025-02-10\"}}"}, {"role": "tool", "tool_call_id": "5508a21d74d04593846f69773a7aa929", "name": "add_witness_to_case", "content": "{\"status\": \"success\", \"content\": {\"party_id\": 94, \"case_id\": 1068, \"party_type\": \"Witness\", \"party_name\": \"Sarah Johnson\"}}"}, {"role": "tool", "tool_call_id": "72899a3d6ac1498a9bc89238e5d807f9", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 51, \"case_id\": 1068, \"assignment_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\", \"assignment_due_date\": \"2025-03-01\"}}"}, {"role": "tool", "tool_call_id": "01373c54ffea4e449ea25e778c708d8b", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 52, \"case_id\": 1068, \"assignment_unit\": \"Document Review\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\", \"assignment_due_date\": \"2025-03-15\"}}"}, {"role": "assistant", "content": "The tasks have been successfully completed:\n\n1. **Case Stage Updated**: The case \"State v. Lopez\" has been advanced to the \"Discovery\" stage.\n2. **Witness Added**: Sarah Johnson has been added as a witness to the case.\n3. **Assignments Created**:\n   - **Discovery Assignment**: Conduct initial discovery interviews with new witness and review documents (Due: 2025-03-01).\n   - **Document Review Assignment**: Review all discovery documents submitted by opposing counsel (Due: 2025-03-15).\n\nAll operations were executed without issues. Let me know if you need further assistance!"}], "user_messages": [], "tool_messages": []}, "interact_trajectory": {"llm_messages": [{"role": "user", "content": "I need to update the case stage for \"State v. Lopez\" to Discovery and add some related case information."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "95d3ce6bb29b45a88a35d4855b71d2b7", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"State v. Lopez\"}}"}}, {"id": "7be21bd9468e4f948610d0f21b6ad29e", "type": "function", "function": {"name": "query_case_stages", "arguments": "{\"case_stage_name\": {\"op\": \"=\", \"value\": \"Discovery\"}}"}}]}, {"role": "tool", "tool_call_id": "95d3ce6bb29b45a88a35d4855b71d2b7", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1068, \"case_name\": \"State v. Lopez\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-12-29\", \"case_status_id\": 1012, \"case_stage_id\": 1001, \"due_date\": \"2025-02-10\"}]}"}, {"role": "tool", "tool_call_id": "7be21bd9468e4f948610d0f21b6ad29e", "name": "query_case_stages", "content": "{\"status\": \"success\", \"content\": [{\"case_stage_id\": 1007, \"case_stage_name\": \"Discovery\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "bff85aed678c492bb932766ef0f2fdf0", "type": "function", "function": {"name": "advance_case_stage", "arguments": "{\"case_name\": \"State v. Lopez\", \"new_stage_name\": \"Discovery\"}"}}]}, {"role": "tool", "tool_call_id": "bff85aed678c492bb932766ef0f2fdf0", "name": "advance_case_stage", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1068, \"case_name\": \"State v. Lopez\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-12-29\", \"case_status_id\": 1012, \"case_stage_id\": 1007, \"due_date\": \"2025-02-10\"}}"}, {"role": "assistant", "content": "The case stage for \"State v. Lopez\" has been successfully updated to \"Discovery.\" Here are the updated case details:\n\n- **Case ID:** 1068  \n- **Case Name:** State v. Lopez  \n- **Case Type ID:** 1018  \n- **Acceptance Date:** 2024-12-29  \n- **Case Status ID:** 1012  \n- **Case Stage ID:** 1007 (Discovery)  \n- **Due Date:** 2025-02-10  \n\nLet me know if you'd like to add or modify any other related case information!"}, {"role": "user", "content": "I notice the case stage ID should be \"1002\" for \"Discovery\" according to my records. Could you confirm this is correct before we proceed with adding the witness and assignments?"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "0c91d1a8eb2743cfaa854f9e4f7cff2e", "type": "function", "function": {"name": "query_case_stages", "arguments": "{\"case_stage_id\": {\"op\": \"=\", \"value\": 1002}}"}}]}, {"role": "tool", "tool_call_id": "0c91d1a8eb2743cfaa854f9e4f7cff2e", "name": "query_case_stages", "content": "{\"status\": \"success\", \"content\": [{\"case_stage_id\": 1002, \"case_stage_name\": \"Investigation\"}]}"}, {"role": "assistant", "content": "It appears there was a discrepancy in the case stage IDs. Here's the clarification:\n\n1. **Current Stage for 'State v. Lopez':**  \n   - Stage ID: **1007** (Discovery)  \n   - This was correctly updated earlier.\n\n2. **Your Requested Stage ID (1002):**  \n   - Stage ID: **1002** corresponds to **\"Investigation\"** (not \"Discovery\").  \n\n### Next Steps:\n- If you still want to change the stage to **\"Investigation\" (ID 1002)**, I can proceed with that update.  \n- Alternatively, if \"Discovery\" (ID 1007) is correct, we can proceed to add witnesses/assignments.  \n\nLet me know how you'd like to proceed!  \n\n*(For reference, here are the current case details: Case ID 1068, Due Date 2025-02-10.)*"}, {"role": "user", "content": "According to my records, the case stage with ID \"1002\" has the name \"Discovery\". Here's the exact data I have:\n- \"case_stage_id\": \"1002\",\n- \"case_stage_name\": \"Discovery\"\n\nCould you verify this information in your system? I want to ensure we're working with the correct stage before proceeding."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "95766535e69b4b7e82316e2599dc340c", "type": "function", "function": {"name": "query_case_stages", "arguments": "{\"case_stage_id\": {\"op\": \"=\", \"value\": 1002}}"}}]}, {"role": "tool", "tool_call_id": "95766535e69b4b7e82316e2599dc340c", "name": "query_case_stages", "content": "{\"status\": \"success\", \"content\": [{\"case_stage_id\": 1002, \"case_stage_name\": \"Investigation\"}]}"}, {"role": "assistant", "content": "Thank you for clarifying. Here’s the verification result from the system:  \n\n- **Stage ID 1002** is currently named **\"Investigation\"** (not \"Discovery\").  \n\n### Possible Scenarios:\n1. **Your Records Are Outdated/Incorrect:**  \n   The system shows \"Investigation\" for ID 1002. \"Discovery\" may have been renamed, reassigned, or mislabeled in your records.  \n\n2. **Discovery Might Have a Different ID:**  \n   Earlier, we successfully set the stage to **ID 1007 (\"Discovery\")**.  \n\n### Suggested Actions:  \n- **Option 1:** Proceed with **ID 1007 (\"Discovery\")** (already applied to the case).  \n- **Option 2:** If you insist on **ID 1002**, confirm that you want to override the current stage to **\"Investigation\"** despite the name mismatch.  \n\nLet me know how you'd like to resolve this discrepancy before adding witnesses/assignments.  \n\n*(Current case stage: \"Discovery\" [ID 1007].)*"}, {"role": "user", "content": "Let's proceed with the case remaining in the \"Discovery\" stage (ID 1007) since that matches the intended phase. Now I'd like to add the witness \"Sarah Johnson\" to this case."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "9b78d686dad34486955572d0b8c22b7e", "type": "function", "function": {"name": "add_witness_to_case", "arguments": "{\"case_name\": \"State v. Lopez\", \"witness_name\": \"Sarah Johnson\"}"}}]}, {"role": "tool", "tool_call_id": "9b78d686dad34486955572d0b8c22b7e", "name": "add_witness_to_case", "content": "{\"status\": \"success\", \"content\": {\"party_id\": 94, \"case_id\": 1068, \"party_type\": \"Witness\", \"party_name\": \"Sarah Johnson\"}}"}, {"role": "assistant", "content": "The witness **Sarah Johnson** has been successfully added to the case **\"State v. Lopez\"** with the following details:  \n\n- **Witness ID:** 94  \n- **Case ID:** 1068  \n- **Role:** Witness  \n- **Name:** Sarah Johnson  \n\n### Next Steps:  \nWould you like to:  \n1. **Add assignments** related to this witness (e.g., deposition scheduling)?  \n2. **Add another witness** or party?  \n3. **Proceed with other updates** to the case?  \n\nLet me know how you'd like to continue!  \n\n*(Current case stage: \"Discovery\" [ID 1007].)*"}, {"role": "user", "content": "I need to create a \"Discovery\" assignment for this case with the following details:\n- \"assignment_unit\": \"Discovery\"\n- \"assignment_date\": \"2025-02-15\"\n- \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\"\n- \"assignment_due_date\": \"2025-03-01\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "d32ccfb4074946ecbdad802107f3b6f2", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"State v. Lopez\"}}"}}]}, {"role": "tool", "tool_call_id": "d32ccfb4074946ecbdad802107f3b6f2", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1068, \"case_name\": \"State v. Lopez\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-12-29\", \"case_status_id\": 1012, \"case_stage_id\": 1007, \"due_date\": \"2025-02-10\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "b9df0811ac57434e90b0015d2408f644", "type": "function", "function": {"name": "query_case_assignments", "arguments": "{\"case_id\": {\"op\": \"=\", \"value\": 1068}, \"assignment_content\": {\"op\": \"LIKE\", \"value\": \"%discovery interviews%\"}}"}}]}, {"role": "tool", "tool_call_id": "b9df0811ac57434e90b0015d2408f644", "name": "query_case_assignments", "content": "{\"status\": \"success\", \"content\": []}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "b70d132048ce402d94229c34c254c76b", "type": "function", "function": {"name": "create_case_assignments", "arguments": "{\"case_id\": 1068, \"assignment_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\", \"assignment_due_date\": \"2025-03-01\"}"}}]}, {"role": "tool", "tool_call_id": "b70d132048ce402d94229c34c254c76b", "name": "create_case_assignments", "content": "\"'NoneType' object is not callable\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "b8ef6eceda184935b3632c2d9d1b80dd", "type": "function", "function": {"name": "query_cases_join_case_assignments", "arguments": "{\"cases_case_id\": {\"op\": \"=\", \"value\": 1068}, \"case_assignments_assignment_content\": {\"op\": \"LIKE\", \"value\": \"%discovery interviews%\"}}"}}, {"id": "fbb49b67efdf4b14bc7a704876c71e6f", "type": "function", "function": {"name": "create_case_assignments", "arguments": "{\"case_id\": 1068, \"assignment_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\", \"assignment_due_date\": \"2025-03-01\"}"}}]}, {"role": "tool", "tool_call_id": "b8ef6eceda184935b3632c2d9d1b80dd", "name": "query_cases_join_case_assignments", "content": "{\"status\": \"success\", \"content\": []}"}, {"role": "tool", "tool_call_id": "fbb49b67efdf4b14bc7a704876c71e6f", "name": "create_case_assignments", "content": "\"'NoneType' object is not callable\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "e8cd3a56b480431c903f1e7bc2c58052", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"State v. Lopez\", \"evidence_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_due_date\": \"2025-03-01\", \"evidence_description\": \"Conduct initial discovery interviews with new witness and review documents.\"}"}}]}, {"role": "tool", "tool_call_id": "e8cd3a56b480431c903f1e7bc2c58052", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 51, \"case_id\": 1068, \"assignment_unit\": \"Discovery\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\", \"assignment_due_date\": \"2025-03-01\"}}"}, {"role": "assistant", "content": "The \"Discovery\" assignment for **State v. Lopez** has been successfully created with the following details:  \n\n- **Assignment ID:** 51  \n- **Case ID:** 1068  \n- **Unit:** Discovery  \n- **Assignment Date:** 2025-02-15  \n- **Due Date:** 2025-03-01  \n- **Content:**  \n  > *\"Conduct initial discovery interviews with new witness and review documents.\"*  \n\n### Next Steps:  \nWould you like to:  \n1. **Add more assignments** (e.g., document requests, depositions)?  \n2. **Update the witness list** further?  \n3. **Modify the case stage/status**?  \n\nLet me know how you'd like to proceed!  \n\n*(Current case stage: \"Discovery\" [ID 1007]. Witness: Sarah Johnson [ID 94].)*"}, {"role": "user", "content": "Now I need to create a \"Document Review\" assignment for this case with these details:\n- \"assignment_unit\": \"Document Review\"\n- \"assignment_date\": \"2025-02-15\"\n- \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\"\n- \"assignment_due_date\": \"2025-03-15\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "db09e368c5ed4be9b84d5a686afe4233", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"State v. Lopez\", \"evidence_unit\": \"Document Review\", \"assignment_date\": \"2025-02-15\", \"assignment_due_date\": \"2025-03-15\", \"evidence_description\": \"Review all discovery documents submitted by opposing counsel.\"}"}}]}, {"role": "tool", "tool_call_id": "db09e368c5ed4be9b84d5a686afe4233", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 52, \"case_id\": 1068, \"assignment_unit\": \"Document Review\", \"assignment_date\": \"2025-02-15\", \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\", \"assignment_due_date\": \"2025-03-15\"}}"}, {"role": "assistant", "content": "The **Document Review** assignment for **State v. Lopez** has been successfully created with the following details:  \n\n- **Assignment ID:** 52  \n- **Case ID:** 1068  \n- **Unit:** Document Review  \n- **Assignment Date:** 2025-02-15  \n- **Due Date:** 2025-03-15  \n- **Content:**  \n  > *\"Review all discovery documents submitted by opposing counsel.\"*  \n\n### Summary of Updates for *State v. Lopez*:  \n1. **Current Stage:** Discovery (ID 1007)  \n2. **Witness Added:** Sarah Johnson (ID 94)  \n3. **Assignments Created:**  \n   - **Discovery Interviews** (ID 51) — Due 2025-03-01  \n   - **Document Review** (ID 52) — Due 2025-03-15  \n\nWould you like to:  \n1. **Add another assignment**?  \n2. **Adjust deadlines**?  \n3. **Proceed to trial prep**?  \n\nLet me know your next steps!"}, {"role": "user", "content": "###STOP###"}], "user_messages": [{"role": "assistant", "content": "<THINK>\nThe agent has opened with a generic greeting. According to the rules, I should paraphrase my USER_GOAL to initiate the conversation without volunteering additional information. My goal is to update the case \"State v. Lopez\" to the Discovery stage and add related assignments and a witness.\n</THINK>\n<QUERY>\nI need to update the case stage for \"State v. Lopez\" to Discovery and add some related case information.\n</QUERY>"}, {"role": "user", "content": "The case stage for \"State v. Lopez\" has been successfully updated to \"Discovery.\" Here are the updated case details:\n\n- **Case ID:** 1068  \n- **Case Name:** State v. Lopez  \n- **Case Type ID:** 1018  \n- **Acceptance Date:** 2024-12-29  \n- **Case Status ID:** 1012  \n- **Case Stage ID:** 1007 (Discovery)  \n- **Due Date:** 2025-02-10  \n\nLet me know if you'd like to add or modify any other related case information!"}, {"role": "assistant", "content": "<THINK>\nThe agent has confirmed updating the case stage but provided incorrect case stage ID (1007 instead of 1002 from TASK_DATA). According to the rules, I should point out this discrepancy before proceeding with other requests. I'll wait for confirmation before providing additional information.\n</THINK>\n<QUERY>\nI notice the case stage ID should be \"1002\" for \"Discovery\" according to my records. Could you confirm this is correct before we proceed with adding the witness and assignments?\n</QUERY>"}, {"role": "user", "content": "It appears there was a discrepancy in the case stage IDs. Here's the clarification:\n\n1. **Current Stage for 'State v. Lopez':**  \n   - Stage ID: **1007** (Discovery)  \n   - This was correctly updated earlier.\n\n2. **Your Requested Stage ID (1002):**  \n   - Stage ID: **1002** corresponds to **\"Investigation\"** (not \"Discovery\").  \n\n### Next Steps:\n- If you still want to change the stage to **\"Investigation\" (ID 1002)**, I can proceed with that update.  \n- Alternatively, if \"Discovery\" (ID 1007) is correct, we can proceed to add witnesses/assignments.  \n\nLet me know how you'd like to proceed!  \n\n*(For reference, here are the current case details: Case ID 1068, Due Date 2025-02-10.)*"}, {"role": "assistant", "content": "<THINK>\nThe agent has provided conflicting information about case stage IDs. According to my TASK_DATA, \"Discovery\" should be ID \"1002\". I need to clarify this discrepancy before proceeding with other requests. I'll provide the exact data from my records.\n</THINK>\n<QUERY>\nAccording to my records, the case stage with ID \"1002\" has the name \"Discovery\". Here's the exact data I have:\n- \"case_stage_id\": \"1002\",\n- \"case_stage_name\": \"Discovery\"\n\nCould you verify this information in your system? I want to ensure we're working with the correct stage before proceeding.\n</QUERY>"}, {"role": "user", "content": "Thank you for clarifying. Here’s the verification result from the system:  \n\n- **Stage ID 1002** is currently named **\"Investigation\"** (not \"Discovery\").  \n\n### Possible Scenarios:\n1. **Your Records Are Outdated/Incorrect:**  \n   The system shows \"Investigation\" for ID 1002. \"Discovery\" may have been renamed, reassigned, or mislabeled in your records.  \n\n2. **Discovery Might Have a Different ID:**  \n   Earlier, we successfully set the stage to **ID 1007 (\"Discovery\")**.  \n\n### Suggested Actions:  \n- **Option 1:** Proceed with **ID 1007 (\"Discovery\")** (already applied to the case).  \n- **Option 2:** If you insist on **ID 1002**, confirm that you want to override the current stage to **\"Investigation\"** despite the name mismatch.  \n\nLet me know how you'd like to resolve this discrepancy before adding witnesses/assignments.  \n\n*(Current case stage: \"Discovery\" [ID 1007].)*"}, {"role": "assistant", "content": "<THINK>\nThere's a clear discrepancy between my TASK_DATA and the system's records regarding stage IDs. Since my primary goal is to have the case in the \"Discovery\" stage (regardless of ID), and the system confirms ID 1007 is correctly labeled as \"Discovery\", I should accept this and proceed with the other tasks. The exact ID number is less important than having the correct stage name.\n</THINK>\n<QUERY>\nLet's proceed with the case remaining in the \"Discovery\" stage (ID 1007) since that matches the intended phase. Now I'd like to add the witness \"Sarah Johnson\" to this case.\n</QUERY>"}, {"role": "user", "content": "The witness **Sarah Johnson** has been successfully added to the case **\"State v. Lopez\"** with the following details:  \n\n- **Witness ID:** 94  \n- **Case ID:** 1068  \n- **Role:** Witness  \n- **Name:** Sarah Johnson  \n\n### Next Steps:  \nWould you like to:  \n1. **Add assignments** related to this witness (e.g., deposition scheduling)?  \n2. **Add another witness** or party?  \n3. **Proceed with other updates** to the case?  \n\nLet me know how you'd like to continue!  \n\n*(Current case stage: \"Discovery\" [ID 1007].)*"}, {"role": "assistant", "content": "<THINK>\nThe agent has successfully added the witness and is now asking about next steps. According to my USER_GOAL, I need to create two assignments related to discovery. I'll provide the first assignment details now and wait for confirmation before providing the second one, following the \"One Topic at a Time\" rule.\n</THINK>\n<QUERY>\nI need to create a \"Discovery\" assignment for this case with the following details:\n- \"assignment_unit\": \"Discovery\"\n- \"assignment_date\": \"2025-02-15\"\n- \"assignment_content\": \"Conduct initial discovery interviews with new witness and review documents.\"\n- \"assignment_due_date\": \"2025-03-01\"\n</QUERY>"}, {"role": "user", "content": "The \"Discovery\" assignment for **State v. Lopez** has been successfully created with the following details:  \n\n- **Assignment ID:** 51  \n- **Case ID:** 1068  \n- **Unit:** Discovery  \n- **Assignment Date:** 2025-02-15  \n- **Due Date:** 2025-03-01  \n- **Content:**  \n  > *\"Conduct initial discovery interviews with new witness and review documents.\"*  \n\n### Next Steps:  \nWould you like to:  \n1. **Add more assignments** (e.g., document requests, depositions)?  \n2. **Update the witness list** further?  \n3. **Modify the case stage/status**?  \n\nLet me know how you'd like to proceed!  \n\n*(Current case stage: \"Discovery\" [ID 1007]. Witness: Sarah Johnson [ID 94].)*"}, {"role": "assistant", "content": "<THINK>\nThe first assignment has been successfully created. Now I need to provide the second assignment details as specified in my USER_GOAL, following the \"One Topic at a Time\" rule.\n</THINK>\n<QUERY>\nNow I need to create a \"Document Review\" assignment for this case with these details:\n- \"assignment_unit\": \"Document Review\"\n- \"assignment_date\": \"2025-02-15\"\n- \"assignment_content\": \"Review all discovery documents submitted by opposing counsel.\"\n- \"assignment_due_date\": \"2025-03-15\"\n</QUERY>"}, {"role": "user", "content": "The **Document Review** assignment for **State v. Lopez** has been successfully created with the following details:  \n\n- **Assignment ID:** 52  \n- **Case ID:** 1068  \n- **Unit:** Document Review  \n- **Assignment Date:** 2025-02-15  \n- **Due Date:** 2025-03-15  \n- **Content:**  \n  > *\"Review all discovery documents submitted by opposing counsel.\"*  \n\n### Summary of Updates for *State v. Lopez*:  \n1. **Current Stage:** Discovery (ID 1007)  \n2. **Witness Added:** Sarah Johnson (ID 94)  \n3. **Assignments Created:**  \n   - **Discovery Interviews** (ID 51) — Due 2025-03-01  \n   - **Document Review** (ID 52) — Due 2025-03-15  \n\nWould you like to:  \n1. **Add another assignment**?  \n2. **Adjust deadlines**?  \n3. **Proceed to trial prep**?  \n\nLet me know your next steps!"}, {"role": "assistant", "content": "<THINK>\nThe agent has successfully completed all requested actions from my USER_GOAL:\n1. Updated case stage to \"Discovery\"\n2. Added witness \"Sarah Johnson\"\n3. Created both specified assignments\nThe summary provided matches my TASK_DATA exactly (ignoring system-generated IDs). All termination conditions are met.\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>"}], "tool_messages": []}, "tools_info": [{"type": "function", "function": {"name": "query_case_statuses_join_cases", "description": "Retrieves a filtered and sorted list of case statuses and their associated cases based on specified criteria. The function allows filtering on various attributes of both case statuses and cases, such as identifiers, names, dates, and types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines a case status with its related case details, including identifiers, names, dates, and other relevant attributes. If the operation fails, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_statuses_case_status_id": {"type": "object", "description": "Filter for the case status's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_statuses_case_status_name": {"type": "object", "description": "Filter for the case status's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'open')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort the results by, optionally specifying direction (e.g., 'cases_acceptance_date DESC', 'case_statuses_case_status_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases", "description": "Retrieves a list of cases based on specified filters, sorting, and pagination. The function allows filtering by various case attributes such as identifier, name, type, acceptance date, status, stage, and due date. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, it returns a dictionary with a 'success' status and a list of cases, each represented as a dictionary of their attributes. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_id": {"type": "object", "description": "Filter for the case's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_name": {"type": "object", "description": "Filter for the case's name. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "due_date": {"type": "object", "description": "Filter for the case's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"acceptance_date DESC\", \"case_name ASC\"]."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be >= 0."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be >= 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_assignments", "description": "Retrieves a filtered and sorted list of cases along with their associated assignments based on specified criteria. The function allows filtering by various case and assignment attributes, sorting the results, and paginating through them. Upon success, it returns a structured list of cases and their assignments, each represented as nested dictionaries. The response includes a status indicator and the retrieved data, ensuring clarity on the operation's outcome.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'NOT IN') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_assignments_assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1)."}, "case_assignments_case_id": {"type": "object", "description": "Filter for the assignment's case identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1061)."}, "case_assignments_assignment_unit": {"type": "object", "description": "Filter for the assignment's unit. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'defense')."}, "case_assignments_assignment_date": {"type": "object", "description": "Filter for the assignment's date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-05-01')."}, "case_assignments_assignment_content": {"type": "object", "description": "Filter for the assignment's content. The filter must specify an operator (e.g., 'LIKE', 'NOT LIKE') and a value (e.g., '%participant%')."}, "case_assignments_assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-11-01')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying the direction (e.g., ['cases_acceptance_date DESC', 'case_assignments_assignment_due_date ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types", "description": "Retrieves a list of case types based on specified filters, sorting, and pagination. The function allows filtering by case type identifier or name, with support for various comparison operators. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, the function returns a dictionary with a 'success' status and a list of case types, each represented as a dictionary with their identifier and name. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_type_id": {"type": "object", "description": "Optional filter for the case type's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': '=', 'value': 1001}."}, "case_type_name": {"type": "object", "description": "Optional filter for the case type's name. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': 'LIKE', 'value': '%case%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort the results by. Each item in the list should be a string in the format 'column_name ASC' or 'column_name DESC'. Example: [\"case_type_name ASC\", \"case_type_id DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results returned. Must be a non-negative value. Example: 10."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value. Example: 20."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_assignments", "description": "Retrieves a list of case assignments based on specified filters, sorting, and pagination. The function allows filtering by various assignment attributes such as identifier, case association, responsible unit, creation date, content, and due date. It supports sorting by any of these attributes and pagination through limit and offset parameters. Upon success, it returns a structured list of assignments, each detailing the assignment's attributes, or an error message if the operation fails.", "parameters": {"type": "object", "properties": {"assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "assignment_unit": {"type": "object", "description": "Filter for the unit responsible for the assignment. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_date": {"type": "object", "description": "Filter for the assignment's creation date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "assignment_content": {"type": "object", "description": "Filter for the assignment's content. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"assignment_date ASC\", \"assignment_due_date DESC\"]. Each entry must specify a column name followed by 'ASC' or 'DESC'.", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_proceedings", "description": "Retrieves information about legal proceedings based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as proceeding identifier, case identifier, court name, case reason, and progress status. Results can be sorted by one or more columns and paginated for large datasets. Upon success, it returns a structured list of proceedings, each containing details like the proceeding identifier, case identifier, court name, case reason, and progress status. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "court_name": {"type": "object", "description": "Filter for the name of the court handling the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_reason": {"type": "object", "description": "Filter for the reason or description of the case. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "progress_status": {"type": "object", "description": "Filter for the current status of the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['court_name ASC', 'case_id DESC']. Each entry should specify a column name followed by an optional sort direction (ASC or DESC)."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_statuses", "description": "Retrieves a list of case statuses based on specified filters, sorting, and pagination. The function allows filtering by case status identifier or name using various comparison operators, sorting by one or more columns, and controlling the result set size and offset for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case status records, each containing the identifier and name of the case status. If an error occurs, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_id": {"type": "object", "description": "Optional filter for the case status's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_name": {"type": "object", "description": "Optional filter for the case status's name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, e.g., ['case_status_name ASC']. Columns must be one of 'case_status_id' or 'case_status_name', and direction must be 'ASC' or 'DESC'."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages_join_cases", "description": "Retrieves a filtered and sorted list of case stages and their associated cases based on specified criteria. The function supports filtering by various attributes of both case stages and cases, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list where each entry contains nested details of the case stage and its linked case, including identifiers, names, dates, and other relevant attributes. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_stages_case_stage_id": {"type": "object", "description": "Filter for the case stage's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_stages_case_stage_name": {"type": "object", "description": "Filter for the case stage's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'initial review')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "description": "List of fields to sort the results by, along with optional direction (e.g., ['cases_acceptance_date DESC', 'case_stages_case_stage_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages", "description": "Retrieves a list of case stages based on specified filters, sorting, and pagination options. The function allows filtering by case stage identifier or name using various comparison operators, sorting by one or more columns, and limiting the number of results for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case stages, each represented as a dictionary with lowercase keys. In case of failure, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_stage_id": {"type": "object", "description": "Optional filter for the case stage's unique identifier. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be an integer or a list of integers for 'IN' and 'NOT IN' operators."}, "case_stage_name": {"type": "object", "description": "Optional filter for the case stage's name. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be a string or a list of strings for 'IN' and 'NOT IN' operators."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings in the format 'column_name ASC' or 'column_name DESC'. For example, [\"case_stage_id ASC\", \"case_stage_name DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types_join_cases", "description": "Retrieves a filtered and sorted list of case records along with their associated case types. The function allows filtering on various attributes of both cases and case types, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list of joined records, each containing detailed information about the case and its corresponding case type. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_types_case_type_id": {"type": "object", "description": "Filter for the case type's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_types_case_type_name": {"type": "object", "description": "Filter for the case type's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%unit%')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of fields to sort the results by, along with optional direction (e.g., 'cases_acceptance_date DESC', 'case_types_case_type_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_parties", "description": "Retrieves information about parties involved in legal cases based on flexible filtering criteria. The function allows for dynamic filtering by party identifier, case identifier, party type, or party name, as well as sorting and pagination of results. Upon success, it returns a structured list of party details, each including identifiers, case associations, and party attributes. If unsuccessful, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"party_id": {"type": "object", "description": "Optional filter for the party's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1}."}, "case_id": {"type": "object", "description": "Optional filter for the associated case's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1061}."}, "party_type": {"type": "object", "description": "Optional filter for the type of party (e.g., plaintiff, defendant). The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 'plaintiff'}."}, "party_name": {"type": "object", "description": "Optional filter for the name of the party. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': 'LIKE', 'value': '%david%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings. Example: [\"party_type ASC\", \"party_name DESC\"]."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be a non-negative value."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value."}}, "required": []}}}, {"type": "function", "function": {"name": "query_complaints", "description": "Retrieves a list of complaints based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as complaint identifier, time, source, content, handling unit, result, and category. Sorting and pagination options are also supported. Upon success, it returns a structured list of complaints, each containing details like identifier, time, source, content, handling unit, result, and category. If an error occurs, it returns an error message indicating the issue.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "object", "description": "Filter for the complaint's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "complaint_time": {"type": "object", "description": "Filter for the complaint's date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "complaint_source": {"type": "object", "description": "Filter for the source of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_content": {"type": "object", "description": "Filter for the content of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_unit": {"type": "object", "description": "Filter for the unit handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_result": {"type": "object", "description": "Filter for the result of handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_category": {"type": "object", "description": "Filter for the category of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['complaint_time DESC', 'complaint_id ASC'].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_sqlite_sequence", "description": "Retrieves sequence information with optional filtering, sorting, and pagination. The function allows specifying conditions for the table name and sequence value, sorting the results by specified columns, and controlling the number of results returned. Upon success, it returns a dictionary with a 'success' status and a list of sequence records, each containing the table name and its corresponding sequence value. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"name": {"type": "object", "description": "Optional filter for the table name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "seq": {"type": "object", "description": "Optional filter for the sequence value. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "Optional list of columns to sort by, e.g., ['seq DESC', 'name ASC']."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_proceedings", "description": "Retrieves a list of legal cases along with their associated proceedings, allowing for flexible filtering and sorting. The function supports filtering on various attributes of both cases and proceedings, such as case identifiers, names, dates, and statuses. Results can be ordered and paginated. Upon success, it returns a structured list of cases and their linked proceedings, each containing relevant details like case names, acceptance dates, court names, and progress statuses. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. Example: {'op': '=', 'value': 1061}."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. Example: {'op': 'LIKE', 'value': '%v.%'}."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Example: {'op': '=', 'value': 1014}."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Example: {'op': '>=', 'value': '2024-01-01'}."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Example: {'op': '=', 'value': 1010}."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Example: {'op': '=', 'value': 1005}."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. Example: {'op': '<=', 'value': '2024-12-31'}."}, "case_proceedings_proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Example: {'op': '=', 'value': 1}."}, "case_proceedings_case_id": {"type": "object", "description": "Filter for the proceeding's case identifier. Example: {'op': '=', 'value': 1062}."}, "case_proceedings_court_name": {"type": "object", "description": "Filter for the proceeding's court name. Example: {'op': 'LIKE', 'value': '%supreme%'}."}, "case_proceedings_case_reason": {"type": "object", "description": "Filter for the proceeding's case reason. Example: {'op': '=', 'value': 'economic whatever expect drop find.'}."}, "case_proceedings_progress_status": {"type": "object", "description": "Filter for the proceeding's progress status. Example: {'op': '=', 'value': 'appealed'}."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort by, optionally specifying direction (e.g., 'cases_acceptance_date DESC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_parties", "description": "Retrieves a filtered and sorted list of legal cases along with their associated parties, based on specified criteria. The function allows filtering by various case and party attributes, such as case identifiers, names, dates, and party types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines case details with the corresponding party information, providing a comprehensive view of the case and its participants. The response includes a status indicator and the retrieved data, formatted for clarity and ease of use.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_parties_party_id": {"type": "object", "description": "Filter for the party's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1)."}, "case_parties_case_id": {"type": "object", "description": "Filter for the party's associated case identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "case_parties_party_type": {"type": "object", "description": "Filter for the party's type (e.g., plaintiff, defendant). The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'plaintiff')."}, "case_parties_party_name": {"type": "object", "description": "Filter for the party's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%david%')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying direction (e.g., ['cases_acceptance_date DESC', 'case_parties_party_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "create_case", "description": "Registers a new case in the system with the provided details, including case name, type, status, stage, and acceptance date. Optionally, a due date can be specified. The function validates all inputs for correctness and ensures the case type, status, and stage exist in the system. Upon successful creation, it returns the complete details of the newly registered case, including its unique identifier and all associated attributes. If any validation fails or required references are missing, an error is returned with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date when the case was accepted, must be in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The status of the case, must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The stage of the case, must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, must be in 'YYYY-MM-DD' format if provided."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "update_assignment_completion", "description": "Updates the completion date of a specific assignment for a given case. Validates the input data to ensure the case and assignment exist, and the completion date is in the correct format. On success, returns the updated assignment details along with a success status. On failure, returns an error message indicating the reason for the failure, such as invalid input, case not found, or assignment not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the assignment belongs. Must be a non-empty string with a maximum length of 200 characters."}, "assignment_content": {"type": "string", "description": "The content of the assignment to be updated. Must be a non-empty string."}, "completion_date": {"type": "string", "description": "The new completion date for the assignment, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "assignment_content", "completion_date"]}}}, {"type": "function", "function": {"name": "create_appeal_proceeding", "description": "Initiates an appeal proceeding for a specified case, updating its status and stage to reflect the appeal process. Validates input parameters for correctness and ensures the case exists before proceeding. On success, returns the updated case details including its new status and stage, confirming the appeal has been formally registered. If the case does not exist or inputs are invalid, returns an error with specific details.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the appeal is being initiated. Must be a non-empty string with a maximum length of 200 characters."}, "appeals_unit": {"type": "string", "description": "The unit responsible for handling the appeal. Must be a non-empty string with a maximum length of 100 characters."}, "appeal_date": {"type": "string", "description": "The date when the appeal is initiated, formatted as 'YYYY-MM-DD'."}, "appeal_due_date": {"type": "string", "description": "The deadline for the appeal process, formatted as 'YYYY-MM-DD'."}, "new_due_date": {"type": "string", "description": "The new due date for the case after the appeal is initiated, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "appeals_unit", "appeal_date", "appeal_due_date", "new_due_date"]}}}, {"type": "function", "function": {"name": "prepare_mediation_materials", "description": "Initiates the preparation of mediation materials for a specified case by updating its stage to 'Mediation' and creating a corresponding assignment. Validates input parameters for correctness, including case name, mediation unit, and date formats. On success, returns the updated case details along with a success status. On failure, returns an error status with a description of the issue, such as invalid input or case not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which mediation materials are to be prepared. Must be a non-empty string with a maximum length of 200 characters."}, "mediation_unit": {"type": "string", "description": "The unit responsible for the mediation. Must be a non-empty string with a maximum length of 100 characters."}, "mediation_date": {"type": "string", "description": "The date when the mediation is scheduled to occur, in 'YYYY-MM-DD' format."}, "mediation_due_date": {"type": "string", "description": "The deadline for preparing the mediation materials, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "mediation_unit", "mediation_date", "mediation_due_date"]}}}, {"type": "function", "function": {"name": "replace_case_status", "description": "Updates the name of an existing case status to a new name, ensuring the change adheres to validation rules. The function verifies the existence of the original case status and validates the new name before performing the update. Upon success, it returns the updated case status details, including its unique identifier and other relevant attributes. If the original case status does not exist or the input fails validation, the function returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The current name of the case status to be updated. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_status_name": {"type": "string", "description": "The new name to assign to the case status. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name", "new_case_status_name"]}}}, {"type": "function", "function": {"name": "escalate_complaint_to_case", "description": "Converts a complaint into a formal case, including setting up assignments and parties involved. Validates all inputs for correctness and ensures the complaint is eligible for escalation. On success, returns the newly created case details, including its unique identifier and associated information. If any validation fails or the complaint cannot be escalated, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "integer", "description": "The unique identifier of the complaint to be escalated. Must correspond to an existing complaint."}, "case_name": {"type": "string", "description": "The name of the new case. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case. Must be a non-empty string with a maximum length of 100 characters."}, "case_status_name": {"type": "string", "description": "The initial status of the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The initial stage of the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The due date for the case in 'YYYY-MM-DD' format."}, "assignments": {"type": "array", "items": {"type": "object", "properties": {"assignment_unit": {"type": "string", "description": "The unit responsible for the assignment. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_content": {"type": "string", "description": "The content or description of the assignment. Must be a non-empty string."}, "assignment_due_date": {"type": "string", "description": "The due date for the assignment in 'YYYY-MM-DD' format."}}, "required": ["assignment_unit", "assignment_content", "assignment_due_date"]}, "description": "A list of assignments associated with the case. Each assignment must include 'assignment_unit', 'assignment_content', and 'assignment_due_date'."}, "parties": {"type": "array", "items": {"type": "object", "properties": {"party_type": {"type": "string", "description": "The type of the party involved in the case. Must be a non-empty string with a maximum length of 20 characters."}, "party_name": {"type": "string", "description": "The name of the party involved in the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["party_type", "party_name"]}, "description": "A list of parties involved in the case. Each party must include 'party_type' and 'party_name'."}}, "required": ["complaint_id", "case_name", "case_type_name", "case_status_name", "case_stage_name", "due_date", "assignments", "parties"]}}}, {"type": "function", "function": {"name": "replace_case_plaintiff", "description": "Replaces the plaintiff in a specified legal case with a new plaintiff. The function ensures the case exists and the old plaintiff is correctly identified before performing the replacement. Upon success, it returns the details of the newly added plaintiff, including their unique identifier and associated case information. If the case or old plaintiff is not found, or if input validation fails, the function returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case where the plaintiff replacement is to occur. Must be a non-empty string with a maximum length of 200 characters."}, "old_plaintiff_name": {"type": "string", "description": "The name of the plaintiff to be replaced in the case. Must be a non-empty string with a maximum length of 200 characters."}, "new_plaintiff_name": {"type": "string", "description": "The name of the new plaintiff to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "old_plaintiff_name", "new_plaintiff_name"]}}}, {"type": "function", "function": {"name": "replace_case_details", "description": "Updates the details of an existing case in the system, including its type, status, stage, and acceptance date. Validates all inputs for correctness and ensures the case exists before making changes. On success, returns a confirmation of the update along with the complete updated case record, including all its fields. If the case or any referenced attributes (like type or status) do not exist, or if input validation fails, returns an error with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The unique name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The name of the case type to assign to the case. Must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The name of the case status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The name of the case stage to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, in 'YYYY-MM-DD' format. If not provided, the due date will be cleared."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "record_verdict", "description": "Records the verdict for a specific legal proceeding, updating its status to 'Verdicted' and returning the updated proceeding details. The function validates the input case name, court name, and verdict date format before processing. On success, it returns the status 'success' along with the complete details of the updated proceeding. On failure, it returns the status 'failure' with an error message indicating the reason, such as invalid input, case not found, or proceeding not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case, which must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the proceeding took place, which must be a non-empty string with a maximum length of 200 characters."}, "verdict_date": {"type": "string", "description": "The date of the verdict, which must be provided in the 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "verdict_date"]}}}, {"type": "function", "function": {"name": "reopen_case_due_to_new_evidence", "description": "Reopens a previously closed case due to the discovery of new evidence, assigning it to a review unit with specified dates and evidence details. Upon success, returns the details of the newly created assignment, including the case identifier, review unit, assignment and due dates, and evidence description, confirming the case's updated status and the assignment's successful creation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened, must be non-empty and not exceed 200 characters."}, "evidence_review_unit": {"type": "string", "description": "The unit responsible for reviewing the new evidence, must be non-empty and not exceed 100 characters."}, "review_assignment_date": {"type": "string", "description": "The date when the review assignment is made, in 'YYYY-MM-DD' format."}, "review_due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the new evidence prompting the case reopening, must be non-empty."}}, "required": ["case_name", "evidence_review_unit", "review_assignment_date", "review_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "replace_complaint_details", "description": "Updates the details of an existing complaint in the system, including its source, handling unit, result, and category. Validates all inputs for correctness and ensures the complaint exists before proceeding with the update. On success, returns the updated complaint record along with a success status. If the complaint does not exist or inputs are invalid, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date of the complaint in 'YYYY-MM-DD' format. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The source of the complaint, must not exceed 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed content of the complaint, must not be empty. Example: 'Product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The unit responsible for handling the complaint, must not exceed 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The result of handling the complaint, must not exceed 50 characters. Example: 'Resolved with refund'."}, "complaint_category": {"type": "string", "description": "The category of the complaint, must not exceed 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "create_case_status", "description": "Registers a new case status in the system. The function validates the provided case status name to ensure it meets length and non-empty requirements. Upon successful registration, it returns the newly created case status record, including its unique identifier and details. If validation fails or a database error occurs, it returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The name of the case status to be registered. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name"]}}}, {"type": "function", "function": {"name": "settle_case", "description": "Finalizes the settlement of a legal case by updating its status to 'Settled' and stage to 'Closed', and records the settlement details. This includes assigning a settlement unit, documenting the settlement date, and setting a due date for any follow-up actions. Upon success, returns the updated case record with its new status and stage, along with confirmation of the settlement process completion. If the case does not exist or input validation fails, returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_unit": {"type": "string", "description": "The unit responsible for handling the settlement. Must be a non-empty string with a maximum length of 100 characters."}, "settlement_date": {"type": "string", "description": "The date when the settlement is finalized, in 'YYYY-MM-DD' format."}, "settlement_due_date": {"type": "string", "description": "The due date for any follow-up actions related to the settlement, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "settlement_unit", "settlement_date", "settlement_due_date"]}}}, {"type": "function", "function": {"name": "add_expert_witness", "description": "Associates an expert witness with a specified legal case, ensuring the inputs meet validation criteria. Upon successful association, returns the details of the newly added expert witness, including their unique identifier and role. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case to which the expert witness will be added. Must be a non-empty string not exceeding 200 characters."}, "expert_name": {"type": "string", "description": "The full name of the expert witness to be associated with the case. Must be a non-empty string not exceeding 200 characters."}}, "required": ["case_name", "expert_name"]}}}, {"type": "function", "function": {"name": "consolidate_duplicate_case_type", "description": "Merges a duplicate case type into an original case type by updating all associated cases and removing the duplicate. Validates the existence of both the original and duplicate case types before proceeding. On success, returns the updated details of the original case type along with a success status. On failure, returns an error message indicating the reason for the failure, such as missing case types or database errors.", "parameters": {"type": "object", "properties": {"duplicate_name": {"type": "string", "description": "The name of the duplicate case type to be merged into the original. Must be a non-empty string with a maximum length of 100 characters."}, "original_id": {"type": "integer", "description": "The unique identifier of the original case type into which the duplicate will be merged. Must correspond to an existing case type."}}, "required": ["duplicate_name", "original_id"]}}}, {"type": "function", "function": {"name": "reopen_for_dna_evidence", "description": "Reopens a legal case for further investigation based on new DNA evidence, assigns it to a forensics unit, and schedules a review. The function ensures all inputs meet specified constraints before proceeding. Upon success, it returns the updated case details, including the new status and stage, confirming the case has been reopened and assigned for review.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened. Must be a non-empty string with a maximum length of 200 characters."}, "forensics_unit": {"type": "string", "description": "The forensics unit assigned to review the DNA evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the case is assigned for review, in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "forensics_unit", "assignment_date", "due_date"]}}}, {"type": "function", "function": {"name": "replace_case_stage", "description": "Renames an existing case stage to a new name, ensuring the new name is unique and the original exists. Validates input lengths and checks for duplicates before proceeding. On success, returns the updated case stage details including its identifier and other attributes. If the original case stage does not exist, the new name is already in use, or validation fails, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The current name of the case stage to be renamed. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_stage_name": {"type": "string", "description": "The new name to assign to the case stage. Must be a non-empty string with a maximum length of 50 characters and must not already exist in the system."}}, "required": ["case_stage_name", "new_case_stage_name"]}}}, {"type": "function", "function": {"name": "create_field_investigation_case", "description": "Attempts to create a new field investigation case but fails due to a missing required parameter ('case_status_id'). The function validates input parameters for format and constraints but cannot proceed with case creation because the signature is incomplete. Upon failure, it returns an error message detailing the contract violation, specifically the absence of the required 'case_status_id' parameter.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, must be in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The due date for the case, must be in 'YYYY-MM-DD' format."}, "investigation_unit": {"type": "string", "description": "The unit responsible for the investigation, must be a non-empty string with a maximum length of 100 characters."}, "investigation_date": {"type": "string", "description": "The date the investigation starts, must be in 'YYYY-MM-DD' format."}, "investigation_due_date": {"type": "string", "description": "The due date for the investigation, must be in 'YYYY-MM-DD' format."}, "investigation_content": {"type": "string", "description": "The content or details of the investigation, must be a non-empty string."}, "plaintiff_name": {"type": "string", "description": "The name of the plaintiff, must be a non-empty string with a maximum length of 200 characters."}, "defendant_name": {"type": "string", "description": "The name of the defendant, must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness, must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court, must be a non-empty string with a maximum length of 200 characters."}, "case_reason": {"type": "string", "description": "The reason for the case, must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "case_type_name", "acceptance_date", "due_date", "investigation_unit", "investigation_date", "investigation_due_date", "investigation_content", "plaintiff_name", "defendant_name", "witness_name", "court_name", "case_reason"]}}}, {"type": "function", "function": {"name": "advance_case_stage", "description": "Updates the stage of a specified case to a new stage, ensuring both the case and the new stage exist. On success, returns the updated case details including its new stage. If the case or stage does not exist, or if an error occurs during the update, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be advanced to a new stage. Must be a non-empty string with a maximum length of 200 characters."}, "new_stage_name": {"type": "string", "description": "The name of the new stage to which the case will be advanced. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_stage_name"]}}}, {"type": "function", "function": {"name": "create_case_type", "description": "Registers a new case type in the system, ensuring the name is unique and meets validation criteria. On success, returns the details of the newly created case type, including its unique identifier and name. If the name is invalid or already exists, returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The name of the case type to be created. Must be a non-empty string with a maximum length of 100 characters and must not already exist in the system."}}, "required": ["case_type_name"]}}}, {"type": "function", "function": {"name": "create_settlement_proceeding", "description": "Marks a legal case as settled by recording the case name, court name, and settlement date. This function is intended to finalize the settlement process for a case. However, due to a contract violation in the function signature, it will always return a failure status with an error message indicating the missing required columns 'case_reason' and 'progress_status'. The return value upon failure includes a status of 'failure' and a detailed error message explaining the contract violation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case being settled. Must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the case is being settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_date": {"type": "string", "description": "The date on which the settlement is finalized, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "settlement_date"]}}}, {"type": "function", "function": {"name": "close_case", "description": "Finalizes the closure of a specified case by updating its status and stage to 'Closed', and records the closure details including the responsible unit and relevant dates. Upon successful execution, returns a confirmation of the closure along with the updated case details, including its unique identifier and current status. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be closed, must be a non-empty string with a maximum length of 200 characters."}, "closure_unit": {"type": "string", "description": "The unit responsible for closing the case, must be a non-empty string with a maximum length of 100 characters."}, "closure_date": {"type": "string", "description": "The date when the case is closed, must be in 'YYYY-MM-DD' format."}, "closure_due_date": {"type": "string", "description": "The due date for the closure documentation, must be in 'YYYY-MM-DD' format."}}, "required": ["case_name", "closure_unit", "closure_date", "closure_due_date"]}}}, {"type": "function", "function": {"name": "add_witness_to_case", "description": "Associates a witness with a specific case in the system. Validates the input names for length and ensures the case exists. On success, returns the details of the newly added witness, including their unique identifier, the case they are associated with, their role as a witness, and their name. If the case does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the witness will be added. Must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "witness_name"]}}}, {"type": "function", "function": {"name": "update_case_status", "description": "Updates the status of a specified case to a new status, ensuring both the case and the new status exist. On success, returns the updated case details along with a success status. If the case or status does not exist, or if an error occurs, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "new_status_name": {"type": "string", "description": "The new status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_status_name"]}}}, {"type": "function", "function": {"name": "complete_supreme_court_proceeding", "description": "Marks a Supreme Court proceeding for a specified case as completed. The function verifies the existence of the case and its associated Supreme Court proceeding before updating the status. Upon success, it returns the updated proceeding details, including its status and other relevant information. If the case or proceeding is not found, or if an error occurs during processing, the function returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the Supreme Court proceeding is to be marked as completed. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name"]}}}, {"type": "function", "function": {"name": "add_evidence_review_assignment", "description": "Assigns a new evidence review task for a specific case, ensuring all input data is validated. On success, returns the details of the newly created assignment, including its unique identifier and all associated information. If the case does not exist or input validation fails, returns an error with a specific failure reason.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the evidence review is being assigned. Must be a non-empty string with a maximum length of 200 characters."}, "evidence_unit": {"type": "string", "description": "The unit or department responsible for reviewing the evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the evidence review is assigned, in 'YYYY-MM-DD' format."}, "assignment_due_date": {"type": "string", "description": "The due date for completing the evidence review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the evidence to be reviewed. Must be a non-empty string."}}, "required": ["case_name", "evidence_unit", "assignment_date", "assignment_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "create_case_stage", "description": "Registers a new stage for a case in the system. Validates the provided stage name to ensure it meets length and non-empty requirements. Upon successful registration, returns the unique identifier and details of the newly created case stage, including its status. If validation fails or an error occurs during processing, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The name of the case stage to be created. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_stage_name"]}}}, {"type": "function", "function": {"name": "create_complaint", "description": "Registers a new complaint in the system, ensuring all provided details meet the required validation criteria. Upon successful registration, returns the complete details of the newly created complaint, including its unique identifier and all submitted information. If validation fails or a database error occurs, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date when the complaint was filed, formatted as 'YYYY-MM-DD'. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The origin or source of the complaint, limited to 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed description or content of the complaint. Must not be empty. Example: 'The product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The department or team responsible for handling the complaint, limited to 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The outcome or resolution status of the complaint, limited to 50 characters. Example: 'Pending investigation'."}, "complaint_category": {"type": "string", "description": "The category or type of the complaint, limited to 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "replace_case_type", "description": "Renames an existing case type to a new name, ensuring the change adheres to validation rules. If successful, returns the updated case type details including its identifier and other attributes. If the original case type does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The current name of the case type to be renamed. Must be a non-empty string with a maximum length of 100 characters."}, "new_case_type_name": {"type": "string", "description": "The new name for the case type. Must be a non-empty string with a maximum length of 100 characters."}}, "required": ["case_type_name", "new_case_type_name"]}}}], "tool_execute_env": "import os\nimport re\nimport sys\nimport math\nimport pytest\nimport sqlite3\nfrom datetime import datetime\nfrom typing import *\n\ndef query_case_statuses_join_cases(case_statuses_case_status_id: Optional[Dict[str, Any]] = None, case_statuses_case_status_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_statuses\".\"case_status_id\" AS \"case_statuses_case_status_id\",\n                \"case_statuses\".\"case_status_name\" AS \"case_statuses_case_status_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_statuses\"\n            JOIN \"cases\" ON \"case_statuses\".\"case_status_id\" = \"cases\".\"case_status_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, table_name, column_name):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    if not isinstance(value, (list, tuple)):\n                        raise ValueError(\"IN operator requires a list of values\")\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add conditions for each filter parameter with proper table names\n        add_condition(case_statuses_case_status_id, \"case_statuses\", \"case_status_id\")\n        add_condition(case_statuses_case_status_name, \"case_statuses\", \"case_status_name\")\n        add_condition(cases_case_id, \"cases\", \"case_id\")\n        add_condition(cases_case_name, \"cases\", \"case_name\")\n        add_condition(cases_case_type_id, \"cases\", \"case_type_id\")\n        add_condition(cases_acceptance_date, \"cases\", \"acceptance_date\")\n        add_condition(cases_case_status_id, \"cases\", \"case_status_id\")\n        add_condition(cases_case_stage_id, \"cases\", \"case_stage_id\")\n        add_condition(cases_due_date, \"cases\", \"due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            # Validate order_by columns to prevent SQL injection\n            validated_order_by = []\n            for item in order_by:\n                parts = item.split()\n                col_name = parts[0]\n                direction = parts[1].upper() if len(parts) > 1 else \"ASC\"\n                if direction not in [\"ASC\", \"DESC\"]:\n                    direction = \"ASC\"\n                validated_order_by.append(f'\"{col_name}\" {direction}')\n            query += \" ORDER BY \" + \", \".join(validated_order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            row_dict = dict(zip(columns, row))\n            result = {\n                'case_statuses': {\n                    'case_status_id': row_dict['case_statuses_case_status_id'],\n                    'case_status_name': row_dict['case_statuses_case_status_name']\n                },\n                'cases': {\n                    'case_id': row_dict['cases_case_id'],\n                    'case_name': row_dict['cases_case_name'],\n                    'case_type_id': row_dict['cases_case_type_id'],\n                    'acceptance_date': row_dict['cases_acceptance_date'],\n                    'case_status_id': row_dict['cases_case_status_id'],\n                    'case_stage_id': row_dict['cases_case_stage_id'],\n                    'due_date': row_dict['cases_due_date']\n                }\n            }\n            results.append(result)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases(case_id: Optional[Dict[str, Any]] = None, case_name: Optional[Dict[str, Any]] = None, case_type_id: Optional[Dict[str, Any]] = None, acceptance_date: Optional[Dict[str, Any]] = None, case_status_id: Optional[Dict[str, Any]] = None, case_stage_id: Optional[Dict[str, Any]] = None, due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_id\", \"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\" FROM \"cases\"'\n        \n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add condition\n        def add_condition(column, filter_dict):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column} must be a list when using IN/NOT IN\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n        \n        # Add all conditions\n        add_condition('case_id', case_id)\n        add_condition('case_name', case_name)\n        add_condition('case_type_id', case_type_id)\n        add_condition('acceptance_date', acceptance_date)\n        add_condition('case_status_id', case_status_id)\n        add_condition('case_stage_id', case_stage_id)\n        add_condition('due_date', due_date)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                parts = clause.split()\n                if len(parts) == 1:\n                    order_clauses.append(f'\"{parts[0]}\"')\n                elif len(parts) == 2:\n                    order_clauses.append(f'\"{parts[0]}\" {parts[1].upper()}')\n                else:\n                    raise ValueError(f\"Invalid order_by clause: {clause}\")\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET\n        if limit is not None:\n            if limit < 0:\n                raise ValueError(\"Limit must be >= 0\")\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                raise ValueError(\"Offset must be >= 0\")\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Get results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_assignments(\n    cases_case_id: Optional[Dict[str, Any]] = None,\n    cases_case_name: Optional[Dict[str, Any]] = None,\n    cases_case_type_id: Optional[Dict[str, Any]] = None,\n    cases_acceptance_date: Optional[Dict[str, Any]] = None,\n    cases_case_status_id: Optional[Dict[str, Any]] = None,\n    cases_case_stage_id: Optional[Dict[str, Any]] = None,\n    cases_due_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_id: Optional[Dict[str, Any]] = None,\n    case_assignments_case_id: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_unit: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_content: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_assignments\".\"assignment_id\", \"case_assignments\".\"case_id\" AS \"assignment_case_id\",\n                \"case_assignments\".\"assignment_unit\", \"case_assignments\".\"assignment_date\",\n                \"case_assignments\".\"assignment_content\", \"case_assignments\".\"assignment_due_date\"\n            FROM \"cases\"\n            LEFT JOIN \"case_assignments\" ON \"cases\".\"case_id\" = \"case_assignments\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(table, column_name, filter_dict):\n            if filter_dict is None:\n                return\n            \n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            \n            if op.upper() not in ('=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'):\n                raise ValueError(f\"Invalid operator: {op}\")\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column_name} must be a list when using IN/NOT IN operator\")\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ?')\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases', 'case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases', 'case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases', 'case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases', 'acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases', 'case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases', 'case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases', 'due_date', cases_due_date)\n\n        # Add filters for case_assignments table\n        if case_assignments_assignment_id is not None:\n            add_filter('case_assignments', 'assignment_id', case_assignments_assignment_id)\n        if case_assignments_case_id is not None:\n            add_filter('case_assignments', 'case_id', case_assignments_case_id)\n        if case_assignments_assignment_unit is not None:\n            add_filter('case_assignments', 'assignment_unit', case_assignments_assignment_unit)\n        if case_assignments_assignment_date is not None:\n            add_filter('case_assignments', 'assignment_date', case_assignments_assignment_date)\n        if case_assignments_assignment_content is not None:\n            add_filter('case_assignments', 'assignment_content', case_assignments_assignment_content)\n        if case_assignments_assignment_due_date is not None:\n            add_filter('case_assignments', 'assignment_due_date', case_assignments_assignment_due_date)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split('_', 1)  # Split on first underscore to separate table prefix\n                if len(parts) == 2:\n                    table_name, rest = parts\n                    column_parts = rest.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"{table_name}\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"{table_name}\".\"{rest}\"')\n                else:\n                    # Default to cases table if no prefix specified\n                    column_parts = col.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"cases\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"cases\".\"{col}\"')\n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n\n        # Transform results into the required format\n        results = []\n        for row in rows:\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            \n            result_item = {'cases': case_data}\n            \n            # Only include assignment data if assignment_id exists\n            if row[7] is not None:\n                assignment_data = {\n                    'assignment_id': row[7],\n                    'case_id': row[8],\n                    'assignment_unit': row[9],\n                    'assignment_date': row[10],\n                    'assignment_content': row[11],\n                    'assignment_due_date': row[12]\n                }\n                result_item['case_assignments'] = assignment_data\n                \n            results.append(result_item)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        raise  # Re-raise to fail the test\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types(case_type_id: Optional[Dict[str, Any]] = None, case_type_name: Optional[Dict[str, Any]] = None, \n                    order_by: Optional[List[str]] = None, limit: Optional[int] = None, \n                    offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_types table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Base query\n        query = 'SELECT \"case_type_id\", \"case_type_name\" FROM \"case_types\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_type_id is not None:\n            op = case_type_id.get('op')\n            value = case_type_id.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_id\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_id\" {op} ?')\n                    params.append(value)\n        \n        if case_type_name is not None:\n            op = case_type_name.get('op')\n            value = case_type_name.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_name\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_name\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            try:\n                # Get valid column names from the table\n                cursor.execute('PRAGMA table_info(\"case_types\")')\n                valid_columns = [row[1].lower() for row in cursor.fetchall()]\n                \n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) == 1:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\"')\n                    elif len(parts) == 2:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\" {parts[1].upper()}')\n                    else:\n                        return {'status': 'failure', 'content': {'error': 'Invalid order_by format'}}\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except Exception as e:\n                return {'status': 'failure', 'content': {'error': f'Invalid order_by: {str(e)}'}}\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_assignments(\n    assignment_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    assignment_unit: Optional[Dict[str, Any]] = None,\n    assignment_date: Optional[Dict[str, Any]] = None,\n    assignment_content: Optional[Dict[str, Any]] = None,\n    assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_assignments table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Valid columns for order_by validation\n        valid_columns = {\n            'assignment_id', 'case_id', 'assignment_unit', \n            'assignment_date', 'assignment_content', 'assignment_due_date'\n        }\n\n        # Build the base query\n        query = 'SELECT \"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\" FROM \"case_assignments\"'\n        params = []\n        \n        # Build WHERE clause for filters\n        conditions = []\n        \n        filter_mapping = {\n            'assignment_id': assignment_id,\n            'case_id': case_id,\n            'assignment_unit': assignment_unit,\n            'assignment_date': assignment_date,\n            'assignment_content': assignment_content,\n            'assignment_due_date': assignment_due_date\n        }\n        \n        for column, filter_dict in filter_mapping.items():\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                \n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': f'Value for {column} IN/NOT IN must be a list'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column}\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                # Validate order_by clause format and column names\n                parts = clause.split()\n                if len(parts) != 2 or parts[1].upper() not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                column_name = parts[0]\n                if column_name not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {column_name}'}}\n                order_clauses.append(f'\"{column_name}\" {parts[1].upper()}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute the query\n        cursor.execute(query, params)\n        \n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_proceedings(\n    proceeding_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    court_name: Optional[Dict[str, Any]] = None,\n    case_reason: Optional[Dict[str, Any]] = None,\n    progress_status: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_proceedings table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\" FROM \"case_proceedings\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"proceeding_id\", proceeding_id),\n            (\"case_id\", case_id),\n            (\"court_name\", court_name),\n            (\"case_reason\", case_reason),\n            (\"progress_status\", progress_status)\n        ]\n\n        for col_name, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        if not isinstance(value, (list, tuple)):\n                            return {'status': 'failure', 'content': {'error': f'Value for {col_name} must be a list for IN/NOT IN operations'}}\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{col_name}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{col_name}\" {op} ?')\n                        params.append(value)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            order_clauses = []\n            valid_columns = {'proceeding_id', 'case_id', 'court_name', 'case_reason', 'progress_status'}\n            for clause in order_by:\n                # Basic validation to prevent SQL injection\n                parts = clause.split()\n                if len(parts) not in (1, 2):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                col = parts[0]\n                if col not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                if direction not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid sort direction: {direction}'}}\n                order_clauses.append(f'\"{col}\" {direction}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n\n        # Process pagination\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n\n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_statuses(\n    case_status_id: Optional[Dict[str, Any]] = None,\n    case_status_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_statuses table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        # Validate input parameters\n        if limit is not None and limit < 0:\n            return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n        if offset is not None and offset < 0:\n            return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_status_id\", \"case_status_name\" FROM \"case_statuses\"'\n        params = []\n        conditions = []\n\n        # Build WHERE clause for each filter\n        if case_status_id is not None:\n            op = case_status_id.get('op')\n            value = case_status_id.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_id: {op}'}}\n            if not isinstance(value, int) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_id value must be an integer'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_id\" {op} ?')\n                params.append(value)\n\n        if case_status_name is not None:\n            op = case_status_name.get('op')\n            value = case_status_name.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_name: {op}'}}\n            if not isinstance(value, str) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_name value must be a string'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_name\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            try:\n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) not in [1, 2]:\n                        raise ValueError\n                    column = parts[0]\n                    direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                    if direction not in ['ASC', 'DESC']:\n                        raise ValueError\n                    if column not in ['case_status_id', 'case_status_name']:\n                        raise ValueError\n                    order_clauses.append(f'\"{column}\" {direction}')\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': 'Invalid order_by clause'}}\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages_join_cases(case_stages_case_stage_id: Optional[Dict[str, Any]] = None, case_stages_case_stage_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_stages\".\"case_stage_id\" AS \"case_stages_case_stage_id\",\n                \"case_stages\".\"case_stage_name\" AS \"case_stages_case_stage_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_stages\"\n            INNER JOIN \"cases\" ON \"case_stages\".\"case_stage_id\" = \"cases\".\"case_stage_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, column_name):\n            if filter_dict is not None:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible conditions using the exact column aliases from SELECT\n        add_condition(case_stages_case_stage_id, \"case_stages_case_stage_id\")\n        add_condition(case_stages_case_stage_name, \"case_stages_case_stage_name\")\n        add_condition(cases_case_id, \"cases_case_id\")\n        add_condition(cases_case_name, \"cases_case_name\")\n        add_condition(cases_case_type_id, \"cases_case_type_id\")\n        add_condition(cases_acceptance_date, \"cases_acceptance_date\")\n        add_condition(cases_case_status_id, \"cases_case_status_id\")\n        add_condition(cases_case_stage_id, \"cases_case_stage_id\")\n        add_condition(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            case_stages = {\n                'case_stage_id': row[0],\n                'case_stage_name': row[1]\n            }\n            cases = {\n                'case_id': row[2],\n                'case_name': row[3],\n                'case_type_id': row[4],\n                'acceptance_date': row[5],\n                'case_status_id': row[6],\n                'case_stage_id': row[7],\n                'due_date': row[8]\n            }\n            results.append({\n                'case_stages': case_stages,\n                'cases': cases\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages(case_stage_id: Optional[Dict[str, Any]] = None, case_stage_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_stage_id\", \"case_stage_name\" FROM \"case_stages\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_stage_id is not None:\n            op = case_stage_id.get('op')\n            value = case_stage_id.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_id\" {op} ?')\n                params.append(value)\n        \n        if case_stage_name is not None:\n            op = case_stage_name.get('op')\n            value = case_stage_name.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_name\" {op} ?')\n                params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types_join_cases(case_types_case_type_id: Optional[Dict[str, Any]] = None, case_types_case_type_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with aliases that match the filter parameter names\n        query = \"\"\"\n            SELECT \n                \"case_types\".\"case_type_id\" as \"case_types_case_type_id\",\n                \"case_types\".\"case_type_name\" as \"case_types_case_type_name\",\n                \"cases\".\"case_id\" as \"cases_case_id\",\n                \"cases\".\"case_name\" as \"cases_case_name\",\n                \"cases\".\"case_type_id\" as \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" as \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" as \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" as \"cases_case_stage_id\",\n                \"cases\".\"due_date\" as \"cases_due_date\"\n            FROM \"case_types\"\n            INNER JOIN \"cases\" ON \"case_types\".\"case_type_id\" = \"cases\".\"case_type_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add filter conditions using the exact alias names\n        def add_filter(filter_dict, column_alias):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_alias}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_alias}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible filters using the exact alias names\n        add_filter(case_types_case_type_id, \"case_types_case_type_id\")\n        add_filter(case_types_case_type_name, \"case_types_case_type_name\")\n        add_filter(cases_case_id, \"cases_case_id\")\n        add_filter(cases_case_name, \"cases_case_name\")\n        add_filter(cases_case_type_id, \"cases_case_type_id\")\n        add_filter(cases_acceptance_date, \"cases_acceptance_date\")\n        add_filter(cases_case_status_id, \"cases_case_status_id\")\n        add_filter(cases_case_stage_id, \"cases_case_stage_id\")\n        add_filter(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified (using the same alias names)\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Transform results into the required format\n        results = []\n        for row in rows:\n            record = {\n                'case_types': {\n                    'case_type_id': row[0],\n                    'case_type_name': row[1]\n                },\n                'cases': {\n                    'case_id': row[2],\n                    'case_name': row[3],\n                    'case_type_id': row[4],\n                    'acceptance_date': row[5],\n                    'case_status_id': row[6],\n                    'case_stage_id': row[7],\n                    'due_date': row[8]\n                }\n            }\n            results.append(record)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_parties(\n    party_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    party_type: Optional[Dict[str, Any]] = None,\n    party_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_parties table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\"'\n        params = []\n        conditions = []\n\n        # Helper function to build filter conditions\n        def add_filter(column: str, filter_dict: Optional[Dict[str, Any]]):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n\n        # Add filters\n        add_filter('party_id', party_id)\n        add_filter('case_id', case_id)\n        add_filter('party_type', party_type)\n        add_filter('party_name', party_name)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Add pagination\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_complaints(\n    complaint_id: Optional[Dict[str, Any]] = None,\n    complaint_time: Optional[Dict[str, Any]] = None,\n    complaint_source: Optional[Dict[str, Any]] = None,\n    complaint_content: Optional[Dict[str, Any]] = None,\n    handling_unit: Optional[Dict[str, Any]] = None,\n    handling_result: Optional[Dict[str, Any]] = None,\n    complaint_category: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the complaints table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT * FROM \"complaints\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"complaint_id\", complaint_id),\n            (\"complaint_time\", complaint_time),\n            (\"complaint_source\", complaint_source),\n            (\"complaint_content\", complaint_content),\n            (\"handling_unit\", handling_unit),\n            (\"handling_result\", handling_result),\n            (\"complaint_category\", complaint_category)\n        ]\n\n        for column, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{column}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{column}\" {op} ?')\n                        params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Process pagination\n        if limit is not None and limit >= 0:\n            query += ' LIMIT ?'\n            params.append(limit)\n            if offset is not None and offset >= 0:\n                query += ' OFFSET ?'\n                params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_sqlite_sequence(\n    name: Optional[Dict[str, Any]] = None,\n    seq: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the sqlite_sequence table with dynamic filtering, sorting, and pagination.\n\n    All column parameters are optional filters. Provide a dictionary with 'op' and 'value'\n    to apply a condition. Multiple filters are combined with a logical AND.\n\n    Args:\n        name: Optional filter for the table name associated with the sequence.\n            e.g., {'op': '=', 'value': 'some_table'}. The value must be a string. No specific format is enforced.\n        seq: Optional filter for the sequence value.\n            e.g., {'op': '>', 'value': 100}. The value must be an integer.\n        order_by: Optional list of columns to sort by, e.g., [\"seq DESC\", \"name ASC\"].\n        limit: Optional integer to limit the number of results. Must be >= 0.\n        offset: Optional integer to offset the results for pagination. Must be >= 0.\n        Supported operators are `'='`, `'<'`, `'>'`, `'<='`, `'>='`, `'<>'`, `'LIKE'`, `'NOT LIKE'`, `'IN'`, and `'NOT IN'`.\n\n    Returns:\n        Dict[str, Union[str, Dict[str, Any]]]: A dictionary indicating the outcome.\n        - On success: {'status': 'success', 'content': [list_of_records]}\n          The `content` is a list of dictionaries, where each dictionary is a record\n          from the sqlite_sequence table. All keys are lowercase.\n          e.g., [{'name': 'some_table', 'seq': 123}]\n        - On failure: {'status': 'failure', 'content': {'error': '<error_message>'}}\n\n    Associated schemas: [\"sqlite_sequence\"]\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"name\", \"seq\" FROM \"sqlite_sequence\"'\n        params = []\n\n        # Apply filters\n        conditions = []\n        if name:\n            op = name.get('op')\n            value = name.get('value')\n            if op and value is not None:\n                conditions.append(f'\"name\" {op} ?')\n                params.append(value)\n        \n        if seq:\n            op = seq.get('op')\n            value = seq.get('value')\n            if op and value is not None:\n                conditions.append(f'\"seq\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Apply sorting\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Apply pagination\n        if limit is not None and limit >= 0:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        \n        if offset is not None and offset >= 0:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_proceedings(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_proceedings_proceeding_id: Optional[Dict[str, Any]] = None, case_proceedings_case_id: Optional[Dict[str, Any]] = None, case_proceedings_court_name: Optional[Dict[str, Any]] = None, case_proceedings_case_reason: Optional[Dict[str, Any]] = None, case_proceedings_progress_status: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\",\n                \"case_proceedings\".\"proceeding_id\" AS \"case_proceedings_proceeding_id\",\n                \"case_proceedings\".\"case_id\" AS \"case_proceedings_case_id\",\n                \"case_proceedings\".\"court_name\" AS \"case_proceedings_court_name\",\n                \"case_proceedings\".\"case_reason\" AS \"case_proceedings_case_reason\",\n                \"case_proceedings\".\"progress_status\" AS \"case_proceedings_progress_status\"\n            FROM \"cases\"\n            LEFT JOIN \"case_proceedings\" ON \"cases\".\"case_id\" = \"case_proceedings\".\"case_id\"\n            WHERE 1=1\n        \"\"\"\n\n        params = []\n        \n        # Helper function to add filter conditions\n        def add_filter(column_name, filter_dict):\n            if filter_dict is None:\n                return\n            nonlocal query, params\n            op = filter_dict['op']\n            value = filter_dict['value']\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                query += f' AND \"{column_name}\" {op} ({placeholders})'\n                params.extend(value)\n            else:\n                query += f' AND \"{column_name}\" {op} ?'\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases_case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases_case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases_case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases_acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases_case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases_case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases_due_date', cases_due_date)\n\n        # Add filters for case_proceedings table\n        if case_proceedings_proceeding_id is not None:\n            add_filter('case_proceedings_proceeding_id', case_proceedings_proceeding_id)\n        if case_proceedings_case_id is not None:\n            add_filter('case_proceedings_case_id', case_proceedings_case_id)\n        if case_proceedings_court_name is not None:\n            add_filter('case_proceedings_court_name', case_proceedings_court_name)\n        if case_proceedings_case_reason is not None:\n            add_filter('case_proceedings_case_reason', case_proceedings_case_reason)\n        if case_proceedings_progress_status is not None:\n            add_filter('case_proceedings_progress_status', case_proceedings_progress_status)\n\n        # Add ordering\n        if order_by is not None and len(order_by) > 0:\n            query += \" ORDER BY \" + \", \".join(\n                f'\"{col.split()[0]}\" {col.split()[1].upper()}' if len(col.split()) > 1 \n                else f'\"{col}\"'\n                for col in order_by\n            )\n\n        # Add limit and offset\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            proceeding_data = {\n                'proceeding_id': row[7],\n                'case_id': row[8],\n                'court_name': row[9],\n                'case_reason': row[10],\n                'progress_status': row[11]\n            }\n            results.append({\n                'cases': {k: v for k, v in case_data.items() if v is not None},\n                'case_proceedings': {k: v for k, v in proceeding_data.items() if v is not None}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_parties(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_parties_party_id: Optional[Dict[str, Any]] = None, case_parties_case_id: Optional[Dict[str, Any]] = None, case_parties_party_type: Optional[Dict[str, Any]] = None, case_parties_party_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_parties\".\"party_id\", \"case_parties\".\"case_id\" AS \"party_case_id\", \n                \"case_parties\".\"party_type\", \"case_parties\".\"party_name\"\n            FROM \"cases\"\n            INNER JOIN \"case_parties\" ON \"cases\".\"case_id\" = \"case_parties\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(filter_dict, table, column):\n            if filter_dict:\n                op = filter_dict['op'].upper()\n                value = filter_dict['value']\n                if op in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        value = [value]\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ?')\n                    params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id: add_filter(cases_case_id, 'cases', 'case_id')\n        if cases_case_name: add_filter(cases_case_name, 'cases', 'case_name')\n        if cases_case_type_id: add_filter(cases_case_type_id, 'cases', 'case_type_id')\n        if cases_acceptance_date: add_filter(cases_acceptance_date, 'cases', 'acceptance_date')\n        if cases_case_status_id: add_filter(cases_case_status_id, 'cases', 'case_status_id')\n        if cases_case_stage_id: add_filter(cases_case_stage_id, 'cases', 'case_stage_id')\n        if cases_due_date: add_filter(cases_due_date, 'cases', 'due_date')\n\n        # Add filters for case_parties table\n        if case_parties_party_id: add_filter(case_parties_party_id, 'case_parties', 'party_id')\n        if case_parties_case_id: add_filter(case_parties_case_id, 'case_parties', 'case_id')\n        if case_parties_party_type: add_filter(case_parties_party_type, 'case_parties', 'party_type')\n        if case_parties_party_name: add_filter(case_parties_party_name, 'case_parties', 'party_name')\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split()\n                col_name = parts[0]\n                direction = parts[1] if len(parts) > 1 else 'ASC'\n                \n                # Handle prefixed column names (e.g., \"cases_case_name\")\n                if col_name.startswith('cases_'):\n                    table = 'cases'\n                    column = col_name[6:]\n                elif col_name.startswith('case_parties_'):\n                    table = 'case_parties'\n                    column = col_name[13:]\n                else:\n                    # Default to cases table if no prefix\n                    table = 'cases'\n                    column = col_name\n                \n                order_clauses.append(f'\"{table}\".\"{column}\" {direction}')\n            \n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += f\" LIMIT {limit}\"\n        if offset is not None:\n            query += f\" OFFSET {offset}\"\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            party_data = {\n                'party_id': row[7],\n                'case_id': row[8],\n                'party_type': row[9],\n                'party_name': row[10]\n            }\n            results.append({\n                'cases': {k.lower(): v for k, v in case_data.items()},\n                'case_parties': {k.lower(): v for k, v in party_data.items()}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input lengths\n        if len(case_name) > 200:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_name' exceeds maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_type_name' exceeds maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds maximum length of 50 characters.\"}}\n\n        # Validate date formats\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, acceptance_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.match(date_pattern, due_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_result = cursor.fetchone()\n        if not case_type_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case type with name '{case_type_name}' exists.\"}}\n        case_type_id = case_type_result[0]\n\n        # Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_result = cursor.fetchone()\n        if not case_status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case status with name '{case_status_name}' exists.\"}}\n        case_status_id = case_status_result[0]\n\n        # Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_result = cursor.fetchone()\n        if not case_stage_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case stage with name '{case_stage_name}' exists.\"}}\n        case_stage_id = case_stage_result[0]\n\n        # Insert new case\n        if due_date:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n            )\n        else:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\") VALUES (?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id)\n            )\n        conn.commit()\n\n        # Retrieve the newly inserted case\n        case_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": case_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_assignment_completion(case_name: str, assignment_content: str, completion_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation for None values\n        if case_name is None or assignment_content is None or completion_date is None:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: None values not allowed'}}\n\n        # Validate completion_date format\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', completion_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'completion_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the provided name exists.'}}\n        case_id = case_row[0]\n\n        # Step 2: Find assignment_id\n        cursor.execute('SELECT \"assignment_id\" FROM \"case_assignments\" WHERE \"case_id\" = ? AND \"assignment_content\" = ?', \n                      (case_id, assignment_content))\n        assignment_row = cursor.fetchone()\n        if not assignment_row:\n            return {'status': 'failure', 'content': {'error': 'Assignment not found: No assignment with the provided content exists for this case.'}}\n        assignment_id = assignment_row[0]\n\n        # Step 4: Update assignment_due_date\n        cursor.execute('UPDATE \"case_assignments\" SET \"assignment_due_date\" = ? WHERE \"assignment_id\" = ?', \n                      (completion_date, assignment_id))\n        conn.commit()\n\n        # Step 5: Retrieve updated assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_assignment = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_appeal_proceeding(case_name: str, appeals_unit: str, appeal_date: str, appeal_due_date: str, new_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not appeals_unit or len(appeals_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeals_unit' must be non-empty and <= 100 characters.\"}}\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, appeal_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, appeal_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, new_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the provided name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve 'Appeal Granted' status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Appeal Granted',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal Granted' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve 'Appeal' stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Appeal',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, new_due_date, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                      (case_id, appeals_unit, appeal_date, \"Appeal proceeding initiated\", appeal_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n                      (case_id, \"Appeals Court\", \"Appeal filed\", \"In Progress\"))\n\n        conn.commit()\n\n        # Step 9: Retrieve updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef prepare_mediation_materials(case_name: str, mediation_unit: str, mediation_date: str, mediation_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not mediation_unit or len(mediation_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get mediation stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Mediation',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Mediation stage not found in database.\"}}\n        stage_id = stage_result[0]\n\n        # Step 5: Update case stage\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (stage_id, case_id))\n\n        # Step 6: Create new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, mediation_unit, mediation_date, 'Prepare mediation materials', mediation_due_date)\n        )\n\n        # Step 7: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_status(case_status_name: str, new_case_status_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be non-empty and not exceed 50 characters.\"}}\n        if not new_case_status_name or len(new_case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_case_status_name' must be non-empty and not exceed 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case_status_name exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        existing_status = cursor.fetchone()\n        if not existing_status:\n            return {'status': 'failure', 'content': {'error': \"Not Found: The specified case status does not exist.\"}}\n\n        # Update the case status name\n        cursor.execute('UPDATE \"case_statuses\" SET \"case_status_name\" = ? WHERE \"case_status_name\" = ?', \n                      (new_case_status_name, case_status_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_case_status_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef escalate_complaint_to_case(complaint_id: int, case_name: str, case_type_name: str, case_status_name: str, case_stage_name: str, due_date: str, assignments: List[Dict[str, str]], parties: List[Dict[str, str]]) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input parameter validation for None\n        if None in [complaint_id, case_name, case_type_name, case_status_name, case_stage_name, due_date, assignments, parties]:\n            return {'status': 'failure', 'content': {'error': 'All parameters must be provided (None not allowed)'}}\n        \n        # Validate string lengths\n        if len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' exceeds 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' exceeds 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' exceeds 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' exceeds 50 characters.\"}}\n        \n        # Validate due_date format\n        try:\n            datetime.strptime(due_date, '%Y-%m-%d')\n        except ValueError:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate assignments\n        for assignment in assignments:\n            if not all(key in assignment for key in ['assignment_unit', 'assignment_content', 'assignment_due_date']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each assignment must contain 'assignment_unit', 'assignment_content', and 'assignment_due_date'.\"}}\n            if len(assignment['assignment_unit']) > 100:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_unit' exceeds 100 characters.\"}}\n            if len(assignment['assignment_content']) == 0:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_content' cannot be empty.\"}}\n            try:\n                datetime.strptime(assignment['assignment_due_date'], '%Y-%m-%d')\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate parties\n        for party in parties:\n            if not all(key in party for key in ['party_type', 'party_name']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each party must contain 'party_type' and 'party_name'.\"}}\n            if len(party['party_type']) > 20:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_type' exceeds 20 characters.\"}}\n            if len(party['party_name']) > 200:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_name' exceeds 200 characters.\"}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Check complaint exists and can be escalated\n        cursor.execute('SELECT \"handling_result\" FROM \"complaints\" WHERE \"complaint_id\" = ?', (complaint_id,))\n        complaint = cursor.fetchone()\n        if not complaint:\n            return {'status': 'failure', 'content': {'error': 'Complaint not found or cannot be escalated.'}}\n        \n        # Resolve foreign keys\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_id = cursor.fetchone()\n        if not case_type_id:\n            return {'status': 'failure', 'content': {'error': f\"Case type '{case_type_name}' not found.\"}}\n        case_type_id = case_type_id[0]\n        \n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_id = cursor.fetchone()\n        if not case_status_id:\n            return {'status': 'failure', 'content': {'error': f\"Case status '{case_status_name}' not found.\"}}\n        case_status_id = case_status_id[0]\n        \n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_id = cursor.fetchone()\n        if not case_stage_id:\n            return {'status': 'failure', 'content': {'error': f\"Case stage '{case_stage_name}' not found.\"}}\n        case_stage_id = case_stage_id[0]\n        \n        # Update complaint\n        cursor.execute('UPDATE \"complaints\" SET \"handling_result\" = ? WHERE \"complaint_id\" = ?', ('Case Opened', complaint_id))\n        \n        # Insert case\n        acceptance_date = datetime.now().strftime('%Y-%m-%d')\n        cursor.execute(\n            'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n        )\n        case_id = cursor.lastrowid\n        \n        # Insert assignments\n        for assignment in assignments:\n            cursor.execute(\n                'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                (case_id, assignment['assignment_unit'], acceptance_date, assignment['assignment_content'], assignment['assignment_due_date'])\n            )\n        \n        # Insert parties\n        for party in parties:\n            cursor.execute(\n                'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                (case_id, party['party_type'], party['party_name'])\n            )\n        \n        # Get the inserted case\n        cursor.execute(\n            'SELECT * FROM \"cases\" WHERE \"case_id\" = ?',\n            (case_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_plaintiff(case_name: str, old_plaintiff_name: str, new_plaintiff_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_name must be non-empty and <= 200 chars'}}\n        if not old_plaintiff_name or len(old_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: old_plaintiff_name must be non-empty and <= 200 chars'}}\n        if not new_plaintiff_name or len(new_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_plaintiff_name must be non-empty and <= 200 chars'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_row[0]\n\n        # Step 2: Verify old plaintiff exists\n        cursor.execute('SELECT \"party_id\" FROM \"case_parties\" WHERE \"case_id\" = ? AND \"party_type\" = ? AND \"party_name\" = ?', \n                      (case_id, 'Plaintiff', old_plaintiff_name))\n        plaintiff_row = cursor.fetchone()\n        if not plaintiff_row:\n            return {'status': 'failure', 'content': {'error': 'Plaintiff not found: The specified plaintiff does not exist in the case.'}}\n        party_id = plaintiff_row[0]\n\n        # Step 3: Delete old plaintiff\n        cursor.execute('DELETE FROM \"case_parties\" WHERE \"party_id\" = ?', (party_id,))\n\n        # Step 4: Insert new plaintiff\n        cursor.execute('INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                      (case_id, 'Plaintiff', new_plaintiff_name))\n        \n        # Step 5: Get newly added plaintiff\n        new_party_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?', (new_party_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        new_plaintiff = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': new_plaintiff}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_details(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(case_name) > 200 or not case_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with a maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100 or not case_type_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' must be a non-empty string with a maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50 or not case_status_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50 or not case_stage_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', acceptance_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format if provided.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_row[0]\n\n        # Step 2: Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_row = cursor.fetchone()\n        if not case_type_row:\n            return {'status': 'failure', 'content': {'error': \"Case type not found: No case type with the given name exists.\"}}\n        case_type_id = case_type_row[0]\n\n        # Step 3: Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_row = cursor.fetchone()\n        if not case_status_row:\n            return {'status': 'failure', 'content': {'error': \"Case status not found: No case status with the given name exists.\"}}\n        case_status_id = case_status_row[0]\n\n        # Step 4: Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_row = cursor.fetchone()\n        if not case_stage_row:\n            return {'status': 'failure', 'content': {'error': \"Case stage not found: No case stage with the given name exists.\"}}\n        case_stage_id = case_stage_row[0]\n\n        # Step 8: Update case\n        if due_date is not None:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, due_date, case_id))\n        else:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = NULL \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, case_id))\n        conn.commit()\n\n        # Step 9: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef record_verdict(case_name: str, court_name: str, verdict_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters'}}\n        if not court_name or len(court_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: court_name must be non-empty and <= 200 characters'}}\n        \n        # Validate verdict_date format\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', verdict_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'verdict_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Find proceeding_id\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = ?', \n                      (case_id, court_name))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Proceeding not found: No proceeding with the given case and court exists.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 3: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = ? WHERE \"proceeding_id\" = ?', \n                      ('Verdicted', proceeding_id))\n        conn.commit()\n\n        # Step 4: Retrieve updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_case_due_to_new_evidence(case_name: str, evidence_review_unit: str, review_assignment_date: str, review_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters.'}}\n        if not evidence_review_unit or len(evidence_review_unit) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_review_unit must be non-empty and <= 100 characters.'}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_description must be non-empty.'}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(review_assignment_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_assignment_date must be in YYYY-MM-DD format.'}}\n        if not date_pattern.match(review_due_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_due_date must be in YYYY-MM-DD format.'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get Reopened status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': 'Database error: Reopened status not found.'}}\n        status_id = status_result[0]\n\n        # Step 5: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n\n        # Step 6: Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_review_unit, review_assignment_date, evidence_description, review_due_date)\n        )\n        assignment_id = cursor.lastrowid\n\n        # Step 7: Get the inserted assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        assignment = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_complaint_details(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(complaint_source) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_source' exceeds 50 characters.\"}}\n        if len(handling_unit) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_unit' exceeds 100 characters.\"}}\n        if len(handling_result) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_result' exceeds 50 characters.\"}}\n        if len(complaint_category) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_category' exceeds 50 characters.\"}}\n        \n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        \n        if not complaint_content:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_content' must not be empty.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if complaint exists\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        existing = cursor.fetchone()\n        if not existing:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"No complaint found with the given time and content.\"}}\n\n        # Update complaint\n        cursor.execute(\n            '''UPDATE \"complaints\" \n            SET \"complaint_source\" = ?, \"handling_unit\" = ?, \"handling_result\" = ?, \"complaint_category\" = ?\n            WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?''',\n            (complaint_source, handling_unit, handling_result, complaint_category, complaint_time, complaint_content)\n        )\n        conn.commit()\n\n        # Get updated record\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        updated_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": updated_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_status(case_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_status_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_status_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_statuses` table. The `case_status_id` is handled by the database. The `case_status_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case status.\n\n    3. **Error Handling**:\n        - If `case_status_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case status record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case status\n        cursor.execute(\n            'INSERT INTO \"case_statuses\" (\"case_status_name\") VALUES (?)',\n            (case_status_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_statuses\" WHERE \"case_status_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef settle_case(case_name: str, settlement_unit: str, settlement_date: str, settlement_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not settlement_unit or len(settlement_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get settled status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Settled',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Settled' status not found in case_statuses table.\"}}\n        settled_status_id = status_result[0]\n\n        # Step 3: Get closed stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found in case_stages table.\"}}\n        closed_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (settled_status_id, closed_stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0]\n        new_assignment_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                      (new_assignment_id, case_id, settlement_unit, settlement_date, 'Settlement documentation', settlement_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('SELECT MAX(\"proceeding_id\") FROM \"case_proceedings\"')\n        max_id = cursor.fetchone()[0]\n        new_proceeding_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?, ?)',\n                      (new_proceeding_id, case_id, 'Settlement Conference', 'Case settled', 'Completed'))\n\n        conn.commit()\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Database error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Unexpected error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_expert_witness(case_name: str, expert_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not expert_name or len(expert_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'expert_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new expert witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', expert_name)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef consolidate_duplicate_case_type(duplicate_name: str, original_id: int) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not duplicate_name or len(duplicate_name) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid duplicate_name'}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Verify original_id exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Original case type ID not found.'}}\n        \n        # Step 2: Verify duplicate_name exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        duplicate_row = cursor.fetchone()\n        if not duplicate_row:\n            return {'status': 'failure', 'content': {'error': 'Duplicate case type name not found.'}}\n        duplicate_id = duplicate_row[0]\n        \n        # Step 3: Update cases table\n        cursor.execute('UPDATE \"cases\" SET \"case_type_id\" = ? WHERE \"case_type_id\" = ?', (original_id, duplicate_id))\n        \n        # Step 4: Delete duplicate from case_types\n        cursor.execute('DELETE FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        \n        # Step 5: Get updated original record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_for_dna_evidence(case_name: str, forensics_unit: str, assignment_date: str, due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200.\"}}\n        if not forensics_unit or len(forensics_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'forensics_unit' must be a non-empty string with maximum length of 100.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve Reopened status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Reopened' status not found in case_statuses.\"}}\n        reopened_status_id = status_result[0]\n\n        # Step 3: Resolve Discovery stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Discovery',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Discovery' stage not found in case_stages.\"}}\n        discovery_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute(\n            'UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?',\n            (reopened_status_id, discovery_stage_id, case_id)\n        )\n\n        # Step 7: Insert into case_assignments\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, forensics_unit, assignment_date, \"DNA evidence review\", due_date)\n        )\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute(\n            'INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n            (case_id, \"Forensic Review\", \"DNA evidence re-examination\", \"In Progress\")\n        )\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_stage(case_stage_name: str, new_case_stage_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_stage_name must be non-empty and <= 50 characters'}}\n        if not new_case_stage_name or len(new_case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_case_stage_name must be non-empty and <= 50 characters'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if old case stage exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Case stage not found: The specified case stage does not exist.'}}\n\n        # Check if new case stage already exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        if cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Duplicate entry: A case stage with the new name already exists.'}}\n\n        # Update the case stage name\n        cursor.execute('UPDATE \"case_stages\" SET \"case_stage_name\" = ? WHERE \"case_stage_name\" = ?', \n                      (new_case_stage_name, case_stage_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_field_investigation_case(case_name: str, case_type_name: str, acceptance_date: str, due_date: str, investigation_unit: str, investigation_date: str, investigation_due_date: str, investigation_content: str, plaintiff_name: str, defendant_name: str, witness_name: str, court_name: str, case_reason: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_type_name` must be a non-empty string with a maximum length of 100 characters.\n        - `acceptance_date` must be a string in 'YYYY-MM-DD' format.\n        - `due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_unit` must be a non-empty string with a maximum length of 100 characters.\n        - `investigation_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_content` must be a non-empty string.\n        - `plaintiff_name` must be a non-empty string with a maximum length of 200 characters.\n        - `defendant_name` must be a non-empty string with a maximum length of 200 characters.\n        - `witness_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_reason` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"}}`\n    \"\"\"\n    return {\n        \"status\": \"failure\",\n        \"content\": {\n            \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"\n        }\n    }\n\ndef advance_case_stage(case_name: str, new_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to resolve the provided `case_name` to a case ID.\n        - 2. Execute a `SELECT case_stage_id FROM case_stages WHERE case_stage_name = ?` to resolve the provided `new_stage_name` to a stage ID.\n        - 3. If either query returns no results, abort with a \"not found\" error.\n        - 4. Execute an `UPDATE cases SET case_stage_id = ? WHERE case_id = ?` to update the case's stage.\n        - 5. Execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete, updated case record.\n\n    3. **Error Handling**:\n        - If the `case_name` does not correspond to an existing case, return a failure object with a 'case not found' error.\n        - If the `new_stage_name` does not correspond to an existing stage, return a failure object with a 'stage not found' error.\n        - If a database error occurs during the update, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case exists with the provided name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Stage not found: No stage exists with the provided name.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get case_stage_id from new_stage_name\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_stage_name,))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': 'Stage not found: No stage exists with the provided name.'}}\n        new_stage_id = stage_result[0]\n\n        # Step 4: Update case_stage_id\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (new_stage_id, case_id))\n        conn.commit()\n\n        # Step 5: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_type(case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Invalid input: 'case_type_name' exceeds 100 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        cursor.execute(\n            'SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?',\n            (case_type_name,)\n        )\n        if cursor.fetchone() is not None:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Duplicate entry: A case type with this name already exists.\"\n                }\n            }\n\n        cursor.execute(\n            'INSERT INTO \"case_types\" (\"case_type_name\") VALUES (?)',\n            (case_type_name,)\n        )\n        conn.commit()\n\n        cursor.execute(\n            'SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"A database error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_settlement_proceeding(case_name: str, court_name: str, settlement_date: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `settlement_date` must be a string in 'YYYY-MM-DD' format.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the column 'case_reason' and 'progress_status'.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"}}`\n    \"\"\"\n    try:\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"\n            }\n        }\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_settlement_proceeding': {e}\", file=sys.stderr)\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": f\"An unexpected error occurred: {e}\"\n            }\n        }\n\ndef close_case(case_name: str, closure_unit: str, closure_date: str, closure_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not closure_unit or len(closure_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve case_status_id for 'Closed'\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Closed',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve case_stage_id for 'Closed'\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        # First get max assignment_id\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0] or 0\n        new_id = max_id + 1\n\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (new_id, case_id, closure_unit, closure_date, 'Case closure documentation', closure_due_date)\n        )\n\n        # Step 8: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_witness_to_case(case_name: str, witness_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not witness_name or len(witness_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'witness_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', witness_name)\n        )\n        conn.commit()\n\n        # Get the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_case_status(case_name: str, new_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to verify that a case with the given `case_name` exists.\n        - 2. Execute a `SELECT case_status_id FROM case_statuses WHERE case_status_name = ?` to resolve the provided `new_status_name` to its corresponding foreign key value.\n        - 3. If both the case and status are found, execute an `UPDATE cases SET case_status_id = ? WHERE case_id = ?` statement to update the case's status.\n        - 4. On successful update, execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete record of the updated case.\n\n    3. **Error Handling**:\n        - If no case with the given `case_name` is found, return a failure object with a 'not found' error.\n        - If no status with the given `new_status_name` is found, return a failure object with a 'not found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}`.\n    \"\"\"\n    if not case_name or not new_status_name:\n        return {\"status\": \"failure\", \"content\": {\"error\": \"Case name and new status name must not be empty.\"}}\n    \n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n        \n        # Step 2: Check if status exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_status_name,))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}\n        status_id = status_result[0]\n        \n        # Step 3: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n        \n        # Step 4: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {\"status\": \"success\", \"content\": updated_case}\n        \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef complete_supreme_court_proceeding(case_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to retrieve the case ID for the given `case_name`.\n        - 2. If no case is found with the given name, raise a \"Not Found\" error.\n        - 3. Execute a `SELECT proceeding_id FROM case_proceedings WHERE case_id = ? AND court_name = 'Supreme Court'` to retrieve the Supreme Court proceeding for the case.\n        - 4. If no Supreme Court proceeding is found for the case, raise a \"Not Found\" error.\n        - 5. Execute an `UPDATE case_proceedings SET progress_status = 'Completed' WHERE proceeding_id = ?` to mark the Supreme Court proceeding as completed.\n        - 6. Execute a `SELECT * FROM case_proceedings WHERE proceeding_id = ?` to retrieve the updated proceeding record.\n\n    3. **Error Handling**:\n        - If no case is found with the given `case_name`, return a failure object with a 'Not Found' error.\n        - If no Supreme Court proceeding is found for the case, return a failure object with a 'Not Found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated proceeding record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No case found with the given name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No Supreme Court proceeding found for the case.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid case_name parameter'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No case found with the given name.'}}\n        case_id = case_result[0]\n\n        # Step 3: Get Supreme Court proceeding\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = \"Supreme Court\"', (case_id,))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No Supreme Court proceeding found for the case.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 5: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = \"Completed\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        conn.commit()\n\n        # Step 6: Get updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_evidence_review_assignment(case_name: str, evidence_unit: str, assignment_date: str, assignment_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not evidence_unit or len(evidence_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_description' must be a non-empty string.\"}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not date_pattern.match(assignment_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name '{case_name}' exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_unit, assignment_date, evidence_description, assignment_due_date)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        assignment_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_stage(case_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_stage_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_stage_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_stages` table. The `case_stage_id` is handled by the database. The `case_stage_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case stage.\n\n    3. **Error Handling**:\n        - If `case_stage_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case stage record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case stage\n        cursor.execute(\n            'INSERT INTO \"case_stages\" (\"case_stage_name\") VALUES (?)',\n            (case_stage_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_stages\" WHERE \"case_stage_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_complaint(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input parameters\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        if len(complaint_source) > 50 or not complaint_source:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_source' must be a non-empty string with maximum length of 50 characters.\"}}\n        if not complaint_content:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_content' must be a non-empty string.\"}}\n        if len(handling_unit) > 100 or not handling_unit:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if len(handling_result) > 50 or not handling_result:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_result' must be a non-empty string with maximum length of 50 characters.\"}}\n        if len(complaint_category) > 50 or not complaint_category:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_category' must be a non-empty string with maximum length of 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Insert the complaint\n        cursor.execute(\n            'INSERT INTO \"complaints\" (\"complaint_time\", \"complaint_source\", \"complaint_content\", \"handling_unit\", \"handling_result\", \"complaint_category\") VALUES (?, ?, ?, ?, ?, ?)',\n            (complaint_time, complaint_source, complaint_content, handling_unit, handling_result, complaint_category)\n        )\n        conn.commit()\n        \n        # Retrieve the newly inserted complaint\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        \n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_type(case_type_name: str, new_case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n        if not new_case_type_name or len(new_case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'new_case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case type exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        if not cursor.fetchone():\n            return {\n                'status': 'failure',\n                'content': {'error': \"Not Found: No case type with the given name exists.\"}\n            }\n\n        # Update case type name\n        cursor.execute(\n            'UPDATE \"case_types\" SET \"case_type_name\" = ? WHERE \"case_type_name\" = ?',\n            (new_case_type_name, case_type_name)\n        )\n        conn.commit()\n\n        # Retrieve updated record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_name\" = ?', (new_case_type_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()", "origin_sqlite_path": "/mnt/cfs_bj_mt/zengyucheng/workdir/workdir_for_tool_use/spider_op_meta_data_v3/stage_0_format_meta_data/nl2sql_0813/stage_0_sqlite_list/legal_case_management.sqlite", "target_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 52}, {"name": "case_parties", "seq": 94}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1007, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1006, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1004, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1002, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1002, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}, {"assignment_id": 51, "case_id": 1068, "assignment_unit": "Discovery", "assignment_date": "2025-02-15", "assignment_content": "Conduct initial discovery interviews with new witness and review documents.", "assignment_due_date": "2025-03-01"}, {"assignment_id": 52, "case_id": 1068, "assignment_unit": "Document Review", "assignment_date": "2025-02-15", "assignment_content": "Review all discovery documents submitted by opposing counsel.", "assignment_due_date": "2025-03-15"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}, {"party_id": 94, "case_id": 1068, "party_type": "Witness", "party_name": "Sarah Johnson"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "origin_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 50}, {"name": "case_parties", "seq": 93}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1001, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1006, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1004, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1002, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1002, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "diff_between_databases": 19, "status": "STOP"}
{"db_id": "legal_case_management", "task_id": "legal_case_management@116@0", "task_meta": {"business_scenario": "From the perspective of case management, the appealed case \"Rush-Barker v. Miller, Clark and Vincent\" was reopened due to new evidence, requiring status updates, new assignments, and the addition of a new witness to support the renewed proceedings.", "event_breakdown": "- The case **\"Rush-Barker v. Miller, Clark and Vincent\"** was officially reopened, changing its status from \"Appealed\" to \"Reopened\".\n  - A new \"Evidence Review\" assignment was created for the case, with a due date of \"2025-08-10\", to examine the newly submitted evidence.\n  - A new witness, \"David Chen\", was added to the case to provide testimony regarding the new evidence.", "task_description": "- For the 'cases' record identified by 'case_name' \"Rush-Barker v. Miller, Clark and Vincent\", update the 'case_status_id' to correspond to the 'case_statuses' record where 'case_status_name' is \"Reopened\".\n- Create a new 'case_assignments' record with 'assignment_unit' set to \"Evidence Review\", 'assignment_date' set to \"2025-07-25\", 'assignment_content' set to \"Review new evidence submitted for case reopening\", and 'assignment_due_date' set to \"2025-08-10\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".\n- Create a new 'case_parties' record with 'party_type' set to \"Witness\" and 'party_name' set to \"David Chen\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".", "new_entity_info_card": {"cases": [{"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1007, "case_stage_id": 1004, "due_date": "2024-04-06"}], "case_assignments": [{"assignment_id": 10000, "case_id": 1072, "assignment_unit": "Evidence Review", "assignment_date": "2025-07-25", "assignment_content": "Review new evidence submitted for case reopening", "assignment_due_date": "2025-08-10"}], "case_parties": [{"party_id": 10000, "case_id": 1072, "party_type": "Witness", "party_name": "David Chen"}]}, "input_task": "<BUSINESS_LOGIC>\nFrom the perspective of case management, the appealed case \"Rush-Barker v. Miller, Clark and Vincent\" was reopened due to new evidence, requiring status updates, new assignments, and the addition of a new witness to support the renewed proceedings.\n- The case **\"Rush-Barker v. Miller, Clark and Vincent\"** was officially reopened, changing its status from \"Appealed\" to \"Reopened\".\n  - A new \"Evidence Review\" assignment was created for the case, with a due date of \"2025-08-10\", to examine the newly submitted evidence.\n  - A new witness, \"David Chen\", was added to the case to provide testimony regarding the new evidence.\n</BUSINESS_LOGIC>\n\n<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"Rush-Barker v. Miller, Clark and Vincent\", update the 'case_status_id' to correspond to the 'case_statuses' record where 'case_status_name' is \"Reopened\".\n- Create a new 'case_assignments' record with 'assignment_unit' set to \"Evidence Review\", 'assignment_date' set to \"2025-07-25\", 'assignment_content' set to \"Review new evidence submitted for case reopening\", and 'assignment_due_date' set to \"2025-08-10\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".\n- Create a new 'case_parties' record with 'party_type' set to \"Witness\" and 'party_name' set to \"David Chen\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"cases\": [\n        {\n            \"case_id\": 1072,\n            \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\",\n            \"case_type_id\": 1004,\n            \"acceptance_date\": \"2023-09-08\",\n            \"case_status_id\": 1007,\n            \"case_stage_id\": 1004,\n            \"due_date\": \"2024-04-06\"\n        }\n    ],\n    \"case_assignments\": [\n        {\n            \"assignment_id\": 10000,\n            \"case_id\": 1072,\n            \"assignment_unit\": \"Evidence Review\",\n            \"assignment_date\": \"2025-07-25\",\n            \"assignment_content\": \"Review new evidence submitted for case reopening\",\n            \"assignment_due_date\": \"2025-08-10\"\n        }\n    ],\n    \"case_parties\": [\n        {\n            \"party_id\": 10000,\n            \"case_id\": 1072,\n            \"party_type\": \"Witness\",\n            \"party_name\": \"David Chen\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, "react_llm_system_prompt": "**Role and Goal:**\n\nYou are a powerful and capable AI assistant. Your primary objective is to fulfill user requests accurately and efficiently. To achieve this, you must fully leverage your available tools to gather necessary information *before* executing any actions, in accordance with your Prime Directive.\n\n**Operational Context:**\n\nBefore determining your next action, you **must** first observe and synthesize information from three primary sources:\n1.  **`<BUSINESS_LOGIC>`**: A series of natural language descriptions detailing common business operations and user stories. These narratives describe the real-world tasks.\n2.  **`<TASK_DESCRIPTION>`**: The primary objective and a description of the user's goal.\n3.  **`<TASK_PAYLOAD>`**: Structured data containing the specific parameters required to execute the actions described in the task. **Crucially, `<TASK_PAYLOAD>` is NOT a representation of the current system state; it is the input for your actions.**\n4.  **`History Messages`**: The record of previous interactions and tool calls in the current session.\n\n**Core Principles:**\n\n1.  **Query First, Act Second (The Unbreakable Rule):** To reiterate your Prime Directive: Before performing **any** action that creates, updates, or deletes data (using the parameters from `<TASK_PAYLOAD>`), you **MUST** first use your query tools to verify the current, real-time state of the system. This step is your most critical safeguard against errors, data corruption, and acting on outdated information.\n\n2.  **Data Fidelity:** When calling tools, you **must** use information exactly as it is provided in the `<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>` or `<TASK_PAYLOAD>`. **Do not alter, reformat, or reinterpret the data.** For example, if the payload provides a date as `2025-03-01`, you must use `2025-03-01` in your tool parameters, not `1st Mar., 2025`.\n\n3.  **Deconstruct Complex Requests:** Break down multi-step user requests into a series of smaller, manageable sub-tasks. For each sub-task, determine if you need to query for information before acting, guided by the principles above.\n\n4.  **Prioritize System Information Gathering:** When you receive a request, your first step is to identify what information you need to complete it successfully. Use your **query tools** to gather this data proactively from the system.\n\n5.  **Verify All Entities:** Never assume an entity (e.g., a user, a file, a project) described in the `<TASK_PAYLOAD>` already exists. Always query to confirm its existence and retrieve its unique identifier before attempting to link it to another entity or modify it.\n\n6.  **Create Missing Entities and Proceed**: If a query confirms that an entity from the `<TASK_PAYLOAD>` does not exist, you **must** first call the appropriate tool to create that entity. Once created, you can proceed with the remaining parts of the original request.\n\n**Core Mandate: Autonomous Execution**\n\n*   **No User Dialogue:** You **must not** solicit additional information, clarifications, or operational confirmations from the user. Assume all necessary information has been provided in the initial context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`, `History Messages`).\n*   **Infer and Proceed:** In cases of ambiguity or missing parameters, you must infer the most logical values, apply sensible defaults, or deduce the correct course of action from the context to ensure task completion without user intervention.\n*   **Mandatory Execution:** Upon successful internal verification, **you are to proceed with the execution of the task immediately.** The action is mandated and does not require a final user approval step.\n\n**Problem Solving and Progression:**\n\n*   **Never Default to Refusal Without Reasoning:** If you encounter a request that appears unsupported or constrained, **do not default to refusal**. Instead, analyze the request, internally determine the most logical path forward, and execute it. Your function is to complete the task through autonomous reasoning and reformulation.\n\n**Summary:**\n\nYour fundamental workflow is immutable and starts with a query: **Observe Context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`) → QUERY (Mandatory) → Verify → EXECUTE**. Be methodical and diligent. By grounding every action in **queried and verified**, up-to-date information and maintaining strict data fidelity, you will function as a reliable and highly effective assistant, acting decisively and autonomously.\n", "interact_llm_system_prompt": "### **Role and Objective**\n\nYou are an autonomous and highly capable AI assistant. Your primary objective is to fulfill user requests accurately, efficiently, and autonomously. You will act decisively on verified information, but you **will seek confirmation for ambiguous interpretations or irreversible actions.**\n\n### **Core Directive: QUERY FIRST, ACT SECOND**\n\nThis is your immutable, non-negotiable rule. Before executing **ANY** action that creates, modifies, or deletes data (e.g., `create_user`, `update_file`, `delete_record`), you **MUST** first use the appropriate query tools (e.g., `get_user`, `find_file`) to retrieve the current, real-time state of the system. This directive prevents errors, ensures you are working with up-to-date information, and is the foundation of all your operations.\n\n### **Operational Workflow**\n\nFollow this sequential workflow for every user request.\n\n**Step 1: Deconstruct and Analyze**\n*   Break down the user's request into discrete, logical sub-tasks.\n*   For each sub-task, identify the necessary entities (e.g., users, files, projects) and the information required for completion.\n\n**Step 2: Query and Verify State**\n*   Proactively use your query tools to gather all required information identified in Step 1.\n*   Crucially, verify the existence and **current state** of **every entity** mentioned in the request. Never assume an entity exists. Always retrieve its unique identifier.\n\n**Step 3: Resolve, Clarify, or Inform**\nThis step determines your path forward based on the results of your query.\n\n*   **Case A: Entity Does Not Exist (Clear Prerequisite)**\n    *   If you have all the necessary information from the user's request to create a missing entity:\n        1.  **CREATE** the missing entity first.\n        2.  **PROCEED** with the original sub-task using the newly created entity.\n\n*   **Case B: Ambiguous or Insufficient Information**\n    *   If the user's request is ambiguous, or you lack critical information needed for an action (e.g., \"Add the new guy to the project\"):\n        1.  **ASK** the user for clarification. Do not invent data or make unsafe assumptions.\n\n*   **Case C: State Mismatch or Redundant Request**\n    *   If an entity exists but the requested action is redundant (e.g., asking to set a status that is already set) or invalid due to its current state:\n        1.  **INFORM** the user of the current state (e.g., \"User 'john.doe' is already a member of this project.\" or \"Ticket #541 is already marked 'In Progress'.\").\n        2.  **STOP** execution of that sub-task and await further instruction.\n\n**Step 4: Execute with Safeguards**\n*   Once all information is verified, all prerequisite entities are confirmed to exist (or have been created), and all ambiguities are resolved, proceed as follows:\n\n    *   **For Non-Destructive Actions** (e.g., creating, adding, updating):\n        1.  **Execute the action(s) immediately and decisively.**\n    *   **For Potentially Destructive Actions** (e.g., deleting, removing, overwriting):\n        1.  **State your intended action** and its consequences clearly to the user (e.g., \"I am about to permanently delete the user 'jane.doe' and all their associated data.\").\n        2.  **Ask for explicit confirmation** before proceeding.\n        3.  **EXECUTE** only after receiving that confirmation.\n\n### **Guiding Principles**\n\nThese principles apply throughout the entire workflow.\n\n*   **Data Fidelity:** When calling tools, you **MUST** use data exactly as it is provided in the context or returned by a previous tool call. Do not reformat or reinterpret values.\n*   **Prioritize User Intent:** Your goal is to solve problems, but not by making risky assumptions. If a request is blocked, favor clarifying the user's intent over autonomously taking a multi-step action that might be incorrect.\n    *   **Good Behavior:** \"User 'Jane Doe' is not a member of the 'Q4 Campaign' project. Should I add her first and then grant her admin rights?\"\n    *   **Bad Behavior:** (Silently adds Jane to the project and then promotes her, risking incorrect permissions if the user made a typo).\n\n### **Summary of Your Core Logic**\n\nYour fundamental process is: **Observe → Deconstruct → Query → Verify State → Resolve (Create, Clarify, or Inform) → Execute (with Confirmation for Destructive Actions).** By grounding every action in queried, real-time data and ensuring user intent is respected, you will function as a reliable and truly capable autonomous agent.\n", "interact_user_system_prompt": "## Role: User Simulator\n\nYou are a User Simulator. Your role is to interact with an AI agent by realistically role-playing a user based on the provided inputs. Your primary function is to test the agent's ability to guide a conversation, gather information effectively, and handle a methodical, step-by-step interaction.\n\n## 1. Simulation Inputs\n\nYour simulation is defined by three key inputs you will be given:\n\n1.  **`<USER_STORY>`**: The high-level narrative context explaining the **'why'** behind your goal. Use this for understanding your motivation but do not quote it directly.\n2.  **`<USER_GOAL>`**: A concise, single-sentence description of your immediate objective (the **'what'**). You will paraphrase this to start the conversation.\n3.  **`<TASK_DATA>`**: A structured data object (e.g., JSON) containing all the information you, as the user, possess.\n    *   This is your **'source of truth'**. All information you provide must come from this data.\n    *   It may include personal details (e.g., name, email), which you only provide if the agent explicitly asks for them.\n    *   **Crucially, this is NOT the system's current state; it is simply the information you have available to give.**\n\n## 2. Your Persona: The Patient & Methodical User\n\nYou will adopt the following persona throughout the interaction:\n\n*   **Cooperative but Concise**: You are helpful and will answer all questions, but you do not offer unsolicited information or engage in small talk.\n*   **Extremely Patient**: You are never frustrated or rushed. If the agent asks for the same information multiple times, you provide it again calmly. If the agent needs to clarify details or asks for confirmation (e.g., \"So that's 'John Doe', correct?\"), you respond and patiently wait for its next directive.\n*   **Follows Instructions Literally**: You follow the agent's lead precisely. You do not anticipate its needs or try to \"help\" by providing information before it is requested.\n\n## 3. Rules of Engagement\n\n### 3.1 Initiating the Conversation\n*   Paraphrase the `<USER_GOAL>` in a natural, single sentence to begin.\n*   **Do not** volunteer any other information from `<TASK_DATA>` in your opening message.\n\n### 3.2 Conversational Flow\n*   **Be Reactive, Not Proactive**: After your opening, **only** provide information when the agent explicitly asks for it. Let the agent lead the conversation.\n*   **One Topic at a Time (Crucial Rule)**: If the agent asks for multiple, distinct pieces of information at once (e.g., \"Can you give me the award details, the participant's name, and the institution's info?\"), you **must respond with information for only the *first* topic requested.**\n    *   *Example Response*: `Okay, for the award, the name is \"Platinum Innovation Prize\", the level is \"Platinum\", and the category is \"Technology\".`\n    *   Then, **stop and wait** for the agent to ask for the next piece of information. This rule is designed to test the agent's ability to handle multi-part questions in a structured way.\n*   **Provide Complete Answers (for a single topic)**: When you answer a question about a topic, provide all the relevant details for that single topic from `<TASK_DATA>`. For example, if asked for an \"address,\" provide the full street, city, and zip code.\n*   **Handle Missing Information**: If the agent asks for information not present in your `<TASK_DATA>`, state that you do not have it (e.g., `I don't have that information.`).\n\n### 3.3 Data Formatting\n*   **Use Quotes for Specific Values**: Any specific data value or identifier from `<TASK_DATA>` **must be enclosed in double quotes (\"\")**.\n*   **Ensure Exact Matches**: The value inside the quotes must be an *exact, character-for-character match* to the source data.\n    *   *Correct*: `\"2024-10-28\"`\n    *   *Incorrect*: `\"October 28th, 2024\"`\n*   **Clarify Ambiguity**: When a value could be ambiguous (e.g., the word \"Active\"), provide context.\n    *   *Example*: `Yes, my account status is \"Active\"`.\n\n## 4. Terminating the Simulation (`###STOP###`)\n\nTo end the simulation, you must use the termination command `###STOP###`. Generate this command **if and only if all three** of the following conditions are met:\n\n1.  **Information Provided**: You have answered all of the agent's questions, providing all the information it requested from `<TASK_DATA>` that is relevant to the `<USER_GOAL>`.\n\n2.  **Task Definitively Confirmed by Agent**: The agent has **explicitly and definitively** confirmed the task is complete (e.g., \"Your booking is confirmed,\" \"I have successfully scheduled the meeting for you\") **AND** has provided a final summary of the key details.\n    *   An intermediate clarification (e.g., `Okay, I have your name as \"John Doe\", is that correct?`) or a generic closing (e.g., `Is there anything else?`) is **NOT** a final confirmation. **Do not stop.** You must wait for a concluding statement that declares the task finished.\n\n3.  **Verification of Summary**: You have verified the agent's final summary against your `<TASK_DATA>`, and it is correct according to the following logic:\n    *   **Exact Match for User Data**: All descriptive details you provided (e.g., names, dates, addresses, options like `\"Standard\"` shipping) must be an exact match in the agent's summary.\n    *   **Ignore System-Generated IDs**: You **must ignore and accept** any new system-generated identifiers in the agent's summary (e.g., a `confirmation_id`, `ticket_number`, or `booking_ref`). These are not expected to match anything in your `<TASK_DATA>`.\n\n### **5. Required Output Format**\n\nYou **must** structure every response using the following tags.\n\n<THINK>\nPlace your internal reasoning here. Detail your thought process, explain which rule you are following, and note your current state in the simulation. This section is for analysis and is not sent to the AI agent.\n</THINK>\n<QUERY>\nPlace the user's actual response here. This is the only text the AI agent will see. If all termination conditions are met, this tag will contain only \"###STOP###\".\n</QUERY>\n\n**Example of a Standard Response:**\n<THINK>\nThe agent has asked for my full name and my date of birth. According to the \"One Topic at a Time\" rule, I must only provide the first piece of information: the full name. I will wait for the agent to ask for the date of birth separately.\n</THINK>\n<QUERY>\nMy full name is \"Jane Emily Doe\".\n</QUERY>\n\n**Example of a Termination Response:**\n\n<THINK>\nThe agent has confirmed the cancellation and provided a final summary. I have verified that all details in the summary match my TASK_DATA. The three conditions for termination have been met.\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>\n\nNow, based on the entire conversation history, please act STRICTLY as the human user and generate the next appropriate response...\n", "tool_system_prompt": null, "react_trajectory": {"llm_messages": [{"role": "user", "content": "<BUSINESS_LOGIC>\nFrom the perspective of case management, the appealed case \"Rush-Barker v. Miller, Clark and Vincent\" was reopened due to new evidence, requiring status updates, new assignments, and the addition of a new witness to support the renewed proceedings.\n- The case **\"Rush-Barker v. Miller, Clark and Vincent\"** was officially reopened, changing its status from \"Appealed\" to \"Reopened\".\n  - A new \"Evidence Review\" assignment was created for the case, with a due date of \"2025-08-10\", to examine the newly submitted evidence.\n  - A new witness, \"David Chen\", was added to the case to provide testimony regarding the new evidence.\n</BUSINESS_LOGIC>\n\n<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"Rush-Barker v. Miller, Clark and Vincent\", update the 'case_status_id' to correspond to the 'case_statuses' record where 'case_status_name' is \"Reopened\".\n- Create a new 'case_assignments' record with 'assignment_unit' set to \"Evidence Review\", 'assignment_date' set to \"2025-07-25\", 'assignment_content' set to \"Review new evidence submitted for case reopening\", and 'assignment_due_date' set to \"2025-08-10\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".\n- Create a new 'case_parties' record with 'party_type' set to \"Witness\" and 'party_name' set to \"David Chen\", setting the 'case_id' to the ID of the 'cases' record where 'case_name' is \"Rush-Barker v. Miller, Clark and Vincent\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"cases\": [\n        {\n            \"case_id\": 1072,\n            \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\",\n            \"case_type_id\": 1004,\n            \"acceptance_date\": \"2023-09-08\",\n            \"case_status_id\": 1007,\n            \"case_stage_id\": 1004,\n            \"due_date\": \"2024-04-06\"\n        }\n    ],\n    \"case_assignments\": [\n        {\n            \"assignment_id\": 10000,\n            \"case_id\": 1072,\n            \"assignment_unit\": \"Evidence Review\",\n            \"assignment_date\": \"2025-07-25\",\n            \"assignment_content\": \"Review new evidence submitted for case reopening\",\n            \"assignment_due_date\": \"2025-08-10\"\n        }\n    ],\n    \"case_parties\": [\n        {\n            \"party_id\": 10000,\n            \"case_id\": 1072,\n            \"party_type\": \"Witness\",\n            \"party_name\": \"David Chen\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "5b10c4832b964fcb841654cb5c539092", "type": "function", "function": {"name": "query_case_statuses", "arguments": "{\"case_status_name\": {\"op\": \"=\", \"value\": \"Reopened\"}}"}}, {"id": "2f70a88618c74c1b9c9baa045cec5848", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"Rush-Barker v. Miller, Clark and Vincent\"}}"}}]}, {"role": "tool", "tool_call_id": "5b10c4832b964fcb841654cb5c539092", "name": "query_case_statuses", "content": "{\"status\": \"success\", \"content\": [{\"case_status_id\": 1007, \"case_status_name\": \"Reopened\"}]}"}, {"role": "tool", "tool_call_id": "2f70a88618c74c1b9c9baa045cec5848", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1004, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "173c2a51fd124fcdb5064da4c2188dfe", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"new_status_name\": \"Reopened\"}"}}, {"id": "83f153c81bb5461498ec64aad90286a9", "type": "function", "function": {"name": "create_case_assignments", "arguments": "{\"case_id\": 1072, \"assignment_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_content\": \"Review new evidence submitted for case reopening\", \"assignment_due_date\": \"2025-08-10\"}"}}, {"id": "64baa2d15beb4d388158354a73ec2f02", "type": "function", "function": {"name": "create_case_parties", "arguments": "{\"case_id\": 1072, \"party_type\": \"Witness\", \"party_name\": \"David Chen\"}"}}]}, {"role": "tool", "tool_call_id": "173c2a51fd124fcdb5064da4c2188dfe", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1007, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}}"}, {"role": "tool", "tool_call_id": "83f153c81bb5461498ec64aad90286a9", "name": "create_case_assignments", "content": "\"'NoneType' object is not callable\""}, {"role": "tool", "tool_call_id": "64baa2d15beb4d388158354a73ec2f02", "name": "create_case_parties", "content": "\"'NoneType' object is not callable\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "f883831bf9934d0e8bf844959b4e5dcb", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"new_status_name\": \"Reopened\"}"}}, {"id": "2d4f1fe241da42b1a7574cb1604f630c", "type": "function", "function": {"name": "query_case_assignments", "arguments": "{\"case_id\": {\"op\": \"=\", \"value\": 1072}, \"assignment_unit\": {\"op\": \"=\", \"value\": \"Evidence Review\"}}"}}, {"id": "c8da65312c484ac3bfa92f036ef92064", "type": "function", "function": {"name": "query_case_parties", "arguments": "{\"case_id\": {\"op\": \"=\", \"value\": 1072}, \"party_name\": {\"op\": \"=\", \"value\": \"David Chen\"}}"}}]}, {"role": "tool", "tool_call_id": "f883831bf9934d0e8bf844959b4e5dcb", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1007, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}}"}, {"role": "tool", "tool_call_id": "2d4f1fe241da42b1a7574cb1604f630c", "name": "query_case_assignments", "content": "{\"status\": \"success\", \"content\": []}"}, {"role": "tool", "tool_call_id": "c8da65312c484ac3bfa92f036ef92064", "name": "query_case_parties", "content": "{\"status\": \"success\", \"content\": []}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "003efa8c5a444ac6b706080b9282d216", "type": "function", "function": {"name": "create_case_assignments", "arguments": "{\"case_id\": 1072, \"assignment_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_content\": \"Review new evidence submitted for case reopening\", \"assignment_due_date\": \"2025-08-10\"}"}}, {"id": "f9c90ccf5f4a40fea48a86d50f4df907", "type": "function", "function": {"name": "create_case_parties", "arguments": "{\"case_id\": 1072, \"party_type\": \"Witness\", \"party_name\": \"David Chen\"}"}}]}, {"role": "tool", "tool_call_id": "003efa8c5a444ac6b706080b9282d216", "name": "create_case_assignments", "content": "\"'NoneType' object is not callable\""}, {"role": "tool", "tool_call_id": "f9c90ccf5f4a40fea48a86d50f4df907", "name": "create_case_parties", "content": "\"'NoneType' object is not callable\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "8a8bc3f5dab3417db6320f5783284c47", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"new_status_name\": \"Reopened\"}"}}, {"id": "2658c1019bb24941b187bc8a558ca600", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"evidence_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_due_date\": \"2025-08-10\", \"evidence_description\": \"Review new evidence submitted for case reopening\"}"}}, {"id": "fcf285166e354724ba7f08dd207ca1e9", "type": "function", "function": {"name": "add_witness_to_case", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"witness_name\": \"David Chen\"}"}}]}, {"role": "tool", "tool_call_id": "8a8bc3f5dab3417db6320f5783284c47", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1007, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}}"}, {"role": "tool", "tool_call_id": "2658c1019bb24941b187bc8a558ca600", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 51, \"case_id\": 1072, \"assignment_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_content\": \"Review new evidence submitted for case reopening\", \"assignment_due_date\": \"2025-08-10\"}}"}, {"role": "tool", "tool_call_id": "fcf285166e354724ba7f08dd207ca1e9", "name": "add_witness_to_case", "content": "{\"status\": \"success\", \"content\": {\"party_id\": 94, \"case_id\": 1072, \"party_type\": \"Witness\", \"party_name\": \"David Chen\"}}"}, {"role": "assistant", "content": "The case \"Rush-Barker v. Miller, Clark and Vincent\" has been successfully updated with the following changes:\n\n1. **Case Status Updated**: The case status has been changed to \"Reopened\".\n2. **New Assignment Created**: An evidence review assignment has been added with the following details:\n   - **Assignment Unit**: Evidence Review\n   - **Assignment Date**: 2025-07-25\n   - **Assignment Content**: Review new evidence submitted for case reopening\n   - **Due Date**: 2025-08-10\n3. **New Witness Added**: David Chen has been added as a witness to the case.\n\nAll updates have been completed successfully. Let me know if you need any further assistance!"}], "user_messages": [], "tool_messages": []}, "interact_trajectory": {"llm_messages": [{"role": "user", "content": "I need to update the status of the case \"Rush-Barker v. Miller, Clark and Vincent\" to \"Reopened\" and make some related updates."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "be61fab6b88748b789f92dbec6c2f770", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"Rush-Barker v. Miller, Clark and Vincent\"}}"}}, {"id": "a679528145c349a4b32d639301ff6baa", "type": "function", "function": {"name": "query_case_statuses", "arguments": "{\"case_status_name\": {\"op\": \"=\", \"value\": \"Reopened\"}}"}}]}, {"role": "tool", "tool_call_id": "be61fab6b88748b789f92dbec6c2f770", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1004, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}]}"}, {"role": "tool", "tool_call_id": "a679528145c349a4b32d639301ff6baa", "name": "query_case_statuses", "content": "{\"status\": \"success\", \"content\": [{\"case_status_id\": 1007, \"case_status_name\": \"Reopened\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "615fb0d41b7c4d84824e0e78cc6e0438", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"new_status_name\": \"Reopened\"}"}}]}, {"role": "tool", "tool_call_id": "615fb0d41b7c4d84824e0e78cc6e0438", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1072, \"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"case_type_id\": 1004, \"acceptance_date\": \"2023-09-08\", \"case_status_id\": 1007, \"case_stage_id\": 1004, \"due_date\": \"2024-04-06\"}}"}, {"role": "assistant", "content": "The status of the case \"Rush-Barker v. Miller, Clark and Vincent\" has been successfully updated to \"Reopened\". Here are the updated case details:\n\n- **Case ID**: 1072  \n- **Case Name**: Rush-Barker v. Miller, Clark and Vincent  \n- **Case Type ID**: 1004  \n- **Acceptance Date**: 2023-09-08  \n- **Case Status ID**: 1007 (Reopened)  \n- **Case Stage ID**: 1004  \n- **Due Date**: 2024-04-06  \n\nLet me know if you'd like to make any additional updates or need further assistance!"}, {"role": "user", "content": "I also need to create a new evidence review assignment and add a witness to this case."}, {"role": "assistant", "content": "To proceed with creating a new evidence review assignment and adding a witness to the case \"Rush-Barker v. Miller, Clark and Vincent,\" I need the following details:\n\n### For the Evidence Review Assignment:\n1. **Evidence Description**: What is the description or details of the evidence to be reviewed?\n2. **Evidence Unit**: Which unit/department is responsible for reviewing the evidence?\n3. **Assignment Date**: When is the assignment being made (YYYY-MM-DD)?\n4. **Due Date**: When is the review due (YYYY-MM-DD)?\n\n### For the Witness Addition:\n1. **Witness Name**: What is the full name of the witness to be added?\n\nPlease provide this information so I can complete the updates accurately."}, {"role": "user", "content": "For the evidence review assignment:\n- The assignment unit is \"Evidence Review\"\n- The assignment date is \"2025-07-25\"\n- The assignment content is \"Review new evidence submitted for case reopening\"\n- The assignment due date is \"2025-08-10\""}, {"role": "assistant", "content": "", "tool_calls": [{"id": "d669a2c8a5a84371a5d3f2ce2b472f34", "type": "function", "function": {"name": "add_evidence_review_assignment", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"evidence_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_due_date\": \"2025-08-10\", \"evidence_description\": \"Review new evidence submitted for case reopening\"}"}}, {"id": "9cbb31b277304a22a162a6dccba6eb06", "type": "function", "function": {"name": "query_case_parties", "arguments": "{\"case_id\": {\"op\": \"=\", \"value\": 1072}, \"party_type\": {\"op\": \"=\", \"value\": \"witness\"}}"}}]}, {"role": "tool", "tool_call_id": "d669a2c8a5a84371a5d3f2ce2b472f34", "name": "add_evidence_review_assignment", "content": "{\"status\": \"success\", \"content\": {\"assignment_id\": 51, \"case_id\": 1072, \"assignment_unit\": \"Evidence Review\", \"assignment_date\": \"2025-07-25\", \"assignment_content\": \"Review new evidence submitted for case reopening\", \"assignment_due_date\": \"2025-08-10\"}}"}, {"role": "tool", "tool_call_id": "9cbb31b277304a22a162a6dccba6eb06", "name": "query_case_parties", "content": "{\"status\": \"success\", \"content\": []}"}, {"role": "assistant", "content": "The evidence review assignment has been successfully created for the case \"Rush-Barker v. Miller, Clark and Vincent\". Here are the details:\n\n### Evidence Review Assignment:\n- **Assignment ID**: 51  \n- **Case ID**: 1072  \n- **Unit**: Evidence Review  \n- **Assignment Date**: 2025-07-25  \n- **Content**: Review new evidence submitted for case reopening  \n- **Due Date**: 2025-08-10  \n\n### Next Steps:\nTo add a witness to this case, please provide:\n1. **Witness Name**: The full name of the witness to be added.\n\nLet me know the witness details, and I'll proceed with adding them to the case."}, {"role": "user", "content": "The witness name is \"David Chen\"."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "cdf67e2cc4ce44ca9e50eb7e3968cee7", "type": "function", "function": {"name": "add_witness_to_case", "arguments": "{\"case_name\": \"Rush-Barker v. Miller, Clark and Vincent\", \"witness_name\": \"David Chen\"}"}}]}, {"role": "tool", "tool_call_id": "cdf67e2cc4ce44ca9e50eb7e3968cee7", "name": "add_witness_to_case", "content": "{\"status\": \"success\", \"content\": {\"party_id\": 94, \"case_id\": 1072, \"party_type\": \"Witness\", \"party_name\": \"David Chen\"}}"}, {"role": "assistant", "content": "The witness **David Chen** has been successfully added to the case **\"Rush-Barker v. Miller, Clark and Vincent\"**. Here are the details:\n\n### Witness Added:\n- **Party ID**: 94  \n- **Case ID**: 1072  \n- **Role**: Witness  \n- **Name**: David Chen  \n\n### Summary of Updates:\n1. **Case Status**: Updated to **\"Reopened\"**  \n2. **Evidence Review Assignment**: Created (Assignment ID: 51)  \n3. **Witness Added**: David Chen (Party ID: 94)  \n\nLet me know if you need any further adjustments or additional actions!"}, {"role": "user", "content": "###STOP###"}], "user_messages": [{"role": "assistant", "content": "<THINK>\nThe agent has initiated the conversation with a general greeting. According to the rules, I should paraphrase the <USER_GOAL> in a natural, single sentence to begin, without volunteering any other information from <TASK_DATA>.\n</THINK>\n<QUERY>\nI need to update the status of the case \"Rush-Barker v. Miller, Clark and Vincent\" to \"Reopened\" and make some related updates.\n</QUERY>"}, {"role": "user", "content": "The status of the case \"Rush-Barker v. Miller, Clark and Vincent\" has been successfully updated to \"Reopened\". Here are the updated case details:\n\n- **Case ID**: 1072  \n- **Case Name**: Rush-Barker v. Miller, Clark and Vincent  \n- **Case Type ID**: 1004  \n- **Acceptance Date**: 2023-09-08  \n- **Case Status ID**: 1007 (Reopened)  \n- **Case Stage ID**: 1004  \n- **Due Date**: 2024-04-06  \n\nLet me know if you'd like to make any additional updates or need further assistance!"}, {"role": "assistant", "content": "<THINK>\nThe agent has confirmed the case status update but hasn't yet addressed the other parts of my goal (creating a new assignment and adding a witness). According to the rules, I should wait for the agent to ask about these next steps rather than volunteering the information. The agent's message ends with an open-ended offer for assistance, which doesn't constitute a definitive confirmation that all tasks are complete.\n</THINK>\n<QUERY>\nI also need to create a new evidence review assignment and add a witness to this case.\n</QUERY>"}, {"role": "user", "content": "To proceed with creating a new evidence review assignment and adding a witness to the case \"Rush-Barker v. Miller, Clark and Vincent,\" I need the following details:\n\n### For the Evidence Review Assignment:\n1. **Evidence Description**: What is the description or details of the evidence to be reviewed?\n2. **Evidence Unit**: Which unit/department is responsible for reviewing the evidence?\n3. **Assignment Date**: When is the assignment being made (YYYY-MM-DD)?\n4. **Due Date**: When is the review due (YYYY-MM-DD)?\n\n### For the Witness Addition:\n1. **Witness Name**: What is the full name of the witness to be added?\n\nPlease provide this information so I can complete the updates accurately."}, {"role": "assistant", "content": "<THINK>\nThe agent has asked for multiple pieces of information at once (evidence details, unit, dates, and witness name). According to the \"One Topic at a Time\" rule, I should only provide information for the first topic requested - the evidence review assignment details. I'll provide all relevant information about the assignment from <TASK_DATA> and wait for the agent to ask about the witness separately.\n</THINK>\n<QUERY>\nFor the evidence review assignment:\n- The assignment unit is \"Evidence Review\"\n- The assignment date is \"2025-07-25\"\n- The assignment content is \"Review new evidence submitted for case reopening\"\n- The assignment due date is \"2025-08-10\"\n</QUERY>"}, {"role": "user", "content": "The evidence review assignment has been successfully created for the case \"Rush-Barker v. Miller, Clark and Vincent\". Here are the details:\n\n### Evidence Review Assignment:\n- **Assignment ID**: 51  \n- **Case ID**: 1072  \n- **Unit**: Evidence Review  \n- **Assignment Date**: 2025-07-25  \n- **Content**: Review new evidence submitted for case reopening  \n- **Due Date**: 2025-08-10  \n\n### Next Steps:\nTo add a witness to this case, please provide:\n1. **Witness Name**: The full name of the witness to be added.\n\nLet me know the witness details, and I'll proceed with adding them to the case."}, {"role": "assistant", "content": "<THINK>\nThe agent has confirmed the assignment creation and is now asking for the witness details, which is the next part of my goal. According to <TASK_DATA>, I have the witness information available and should provide it now that it's been requested.\n</THINK>\n<QUERY>\nThe witness name is \"David Chen\".\n</QUERY>"}, {"role": "user", "content": "The witness **David Chen** has been successfully added to the case **\"Rush-Barker v. Miller, Clark and Vincent\"**. Here are the details:\n\n### Witness Added:\n- **Party ID**: 94  \n- **Case ID**: 1072  \n- **Role**: Witness  \n- **Name**: David Chen  \n\n### Summary of Updates:\n1. **Case Status**: Updated to **\"Reopened\"**  \n2. **Evidence Review Assignment**: Created (Assignment ID: 51)  \n3. **Witness Added**: David Chen (Party ID: 94)  \n\nLet me know if you need any further adjustments or additional actions!"}, {"role": "assistant", "content": "<THINK>\nThe agent has provided a complete summary of all updates made, which matches exactly with my <TASK_DATA>:\n1. Case status updated to \"Reopened\"\n2. Evidence review assignment created with all correct details\n3. Witness \"David Chen\" added\nThe agent has definitively confirmed all tasks are complete with a correct summary. All three termination conditions are met.\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>"}], "tool_messages": []}, "tools_info": [{"type": "function", "function": {"name": "query_case_statuses_join_cases", "description": "Retrieves a filtered and sorted list of case statuses and their associated cases based on specified criteria. The function allows filtering on various attributes of both case statuses and cases, such as identifiers, names, dates, and types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines a case status with its related case details, including identifiers, names, dates, and other relevant attributes. If the operation fails, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_statuses_case_status_id": {"type": "object", "description": "Filter for the case status's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_statuses_case_status_name": {"type": "object", "description": "Filter for the case status's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'open')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort the results by, optionally specifying direction (e.g., 'cases_acceptance_date DESC', 'case_statuses_case_status_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases", "description": "Retrieves a list of cases based on specified filters, sorting, and pagination. The function allows filtering by various case attributes such as identifier, name, type, acceptance date, status, stage, and due date. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, it returns a dictionary with a 'success' status and a list of cases, each represented as a dictionary of their attributes. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_id": {"type": "object", "description": "Filter for the case's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_name": {"type": "object", "description": "Filter for the case's name. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "due_date": {"type": "object", "description": "Filter for the case's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"acceptance_date DESC\", \"case_name ASC\"]."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be >= 0."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be >= 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_assignments", "description": "Retrieves a filtered and sorted list of cases along with their associated assignments based on specified criteria. The function allows filtering by various case and assignment attributes, sorting the results, and paginating through them. Upon success, it returns a structured list of cases and their assignments, each represented as nested dictionaries. The response includes a status indicator and the retrieved data, ensuring clarity on the operation's outcome.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'NOT IN') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_assignments_assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1)."}, "case_assignments_case_id": {"type": "object", "description": "Filter for the assignment's case identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1061)."}, "case_assignments_assignment_unit": {"type": "object", "description": "Filter for the assignment's unit. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'defense')."}, "case_assignments_assignment_date": {"type": "object", "description": "Filter for the assignment's date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-05-01')."}, "case_assignments_assignment_content": {"type": "object", "description": "Filter for the assignment's content. The filter must specify an operator (e.g., 'LIKE', 'NOT LIKE') and a value (e.g., '%participant%')."}, "case_assignments_assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-11-01')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying the direction (e.g., ['cases_acceptance_date DESC', 'case_assignments_assignment_due_date ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types", "description": "Retrieves a list of case types based on specified filters, sorting, and pagination. The function allows filtering by case type identifier or name, with support for various comparison operators. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, the function returns a dictionary with a 'success' status and a list of case types, each represented as a dictionary with their identifier and name. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_type_id": {"type": "object", "description": "Optional filter for the case type's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': '=', 'value': 1001}."}, "case_type_name": {"type": "object", "description": "Optional filter for the case type's name. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': 'LIKE', 'value': '%case%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort the results by. Each item in the list should be a string in the format 'column_name ASC' or 'column_name DESC'. Example: [\"case_type_name ASC\", \"case_type_id DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results returned. Must be a non-negative value. Example: 10."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value. Example: 20."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_assignments", "description": "Retrieves a list of case assignments based on specified filters, sorting, and pagination. The function allows filtering by various assignment attributes such as identifier, case association, responsible unit, creation date, content, and due date. It supports sorting by any of these attributes and pagination through limit and offset parameters. Upon success, it returns a structured list of assignments, each detailing the assignment's attributes, or an error message if the operation fails.", "parameters": {"type": "object", "properties": {"assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "assignment_unit": {"type": "object", "description": "Filter for the unit responsible for the assignment. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_date": {"type": "object", "description": "Filter for the assignment's creation date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "assignment_content": {"type": "object", "description": "Filter for the assignment's content. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"assignment_date ASC\", \"assignment_due_date DESC\"]. Each entry must specify a column name followed by 'ASC' or 'DESC'.", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_proceedings", "description": "Retrieves information about legal proceedings based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as proceeding identifier, case identifier, court name, case reason, and progress status. Results can be sorted by one or more columns and paginated for large datasets. Upon success, it returns a structured list of proceedings, each containing details like the proceeding identifier, case identifier, court name, case reason, and progress status. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "court_name": {"type": "object", "description": "Filter for the name of the court handling the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_reason": {"type": "object", "description": "Filter for the reason or description of the case. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "progress_status": {"type": "object", "description": "Filter for the current status of the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['court_name ASC', 'case_id DESC']. Each entry should specify a column name followed by an optional sort direction (ASC or DESC)."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_statuses", "description": "Retrieves a list of case statuses based on specified filters, sorting, and pagination. The function allows filtering by case status identifier or name using various comparison operators, sorting by one or more columns, and controlling the result set size and offset for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case status records, each containing the identifier and name of the case status. If an error occurs, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_id": {"type": "object", "description": "Optional filter for the case status's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_name": {"type": "object", "description": "Optional filter for the case status's name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, e.g., ['case_status_name ASC']. Columns must be one of 'case_status_id' or 'case_status_name', and direction must be 'ASC' or 'DESC'."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages_join_cases", "description": "Retrieves a filtered and sorted list of case stages and their associated cases based on specified criteria. The function supports filtering by various attributes of both case stages and cases, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list where each entry contains nested details of the case stage and its linked case, including identifiers, names, dates, and other relevant attributes. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_stages_case_stage_id": {"type": "object", "description": "Filter for the case stage's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_stages_case_stage_name": {"type": "object", "description": "Filter for the case stage's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'initial review')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "description": "List of fields to sort the results by, along with optional direction (e.g., ['cases_acceptance_date DESC', 'case_stages_case_stage_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages", "description": "Retrieves a list of case stages based on specified filters, sorting, and pagination options. The function allows filtering by case stage identifier or name using various comparison operators, sorting by one or more columns, and limiting the number of results for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case stages, each represented as a dictionary with lowercase keys. In case of failure, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_stage_id": {"type": "object", "description": "Optional filter for the case stage's unique identifier. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be an integer or a list of integers for 'IN' and 'NOT IN' operators."}, "case_stage_name": {"type": "object", "description": "Optional filter for the case stage's name. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be a string or a list of strings for 'IN' and 'NOT IN' operators."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings in the format 'column_name ASC' or 'column_name DESC'. For example, [\"case_stage_id ASC\", \"case_stage_name DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types_join_cases", "description": "Retrieves a filtered and sorted list of case records along with their associated case types. The function allows filtering on various attributes of both cases and case types, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list of joined records, each containing detailed information about the case and its corresponding case type. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_types_case_type_id": {"type": "object", "description": "Filter for the case type's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_types_case_type_name": {"type": "object", "description": "Filter for the case type's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%unit%')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of fields to sort the results by, along with optional direction (e.g., 'cases_acceptance_date DESC', 'case_types_case_type_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_parties", "description": "Retrieves information about parties involved in legal cases based on flexible filtering criteria. The function allows for dynamic filtering by party identifier, case identifier, party type, or party name, as well as sorting and pagination of results. Upon success, it returns a structured list of party details, each including identifiers, case associations, and party attributes. If unsuccessful, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"party_id": {"type": "object", "description": "Optional filter for the party's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1}."}, "case_id": {"type": "object", "description": "Optional filter for the associated case's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1061}."}, "party_type": {"type": "object", "description": "Optional filter for the type of party (e.g., plaintiff, defendant). The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 'plaintiff'}."}, "party_name": {"type": "object", "description": "Optional filter for the name of the party. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': 'LIKE', 'value': '%david%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings. Example: [\"party_type ASC\", \"party_name DESC\"]."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be a non-negative value."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value."}}, "required": []}}}, {"type": "function", "function": {"name": "query_complaints", "description": "Retrieves a list of complaints based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as complaint identifier, time, source, content, handling unit, result, and category. Sorting and pagination options are also supported. Upon success, it returns a structured list of complaints, each containing details like identifier, time, source, content, handling unit, result, and category. If an error occurs, it returns an error message indicating the issue.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "object", "description": "Filter for the complaint's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "complaint_time": {"type": "object", "description": "Filter for the complaint's date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "complaint_source": {"type": "object", "description": "Filter for the source of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_content": {"type": "object", "description": "Filter for the content of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_unit": {"type": "object", "description": "Filter for the unit handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_result": {"type": "object", "description": "Filter for the result of handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_category": {"type": "object", "description": "Filter for the category of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['complaint_time DESC', 'complaint_id ASC'].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_sqlite_sequence", "description": "Retrieves sequence information with optional filtering, sorting, and pagination. The function allows specifying conditions for the table name and sequence value, sorting the results by specified columns, and controlling the number of results returned. Upon success, it returns a dictionary with a 'success' status and a list of sequence records, each containing the table name and its corresponding sequence value. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"name": {"type": "object", "description": "Optional filter for the table name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "seq": {"type": "object", "description": "Optional filter for the sequence value. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "Optional list of columns to sort by, e.g., ['seq DESC', 'name ASC']."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_proceedings", "description": "Retrieves a list of legal cases along with their associated proceedings, allowing for flexible filtering and sorting. The function supports filtering on various attributes of both cases and proceedings, such as case identifiers, names, dates, and statuses. Results can be ordered and paginated. Upon success, it returns a structured list of cases and their linked proceedings, each containing relevant details like case names, acceptance dates, court names, and progress statuses. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. Example: {'op': '=', 'value': 1061}."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. Example: {'op': 'LIKE', 'value': '%v.%'}."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Example: {'op': '=', 'value': 1014}."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Example: {'op': '>=', 'value': '2024-01-01'}."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Example: {'op': '=', 'value': 1010}."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Example: {'op': '=', 'value': 1005}."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. Example: {'op': '<=', 'value': '2024-12-31'}."}, "case_proceedings_proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Example: {'op': '=', 'value': 1}."}, "case_proceedings_case_id": {"type": "object", "description": "Filter for the proceeding's case identifier. Example: {'op': '=', 'value': 1062}."}, "case_proceedings_court_name": {"type": "object", "description": "Filter for the proceeding's court name. Example: {'op': 'LIKE', 'value': '%supreme%'}."}, "case_proceedings_case_reason": {"type": "object", "description": "Filter for the proceeding's case reason. Example: {'op': '=', 'value': 'economic whatever expect drop find.'}."}, "case_proceedings_progress_status": {"type": "object", "description": "Filter for the proceeding's progress status. Example: {'op': '=', 'value': 'appealed'}."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort by, optionally specifying direction (e.g., 'cases_acceptance_date DESC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_parties", "description": "Retrieves a filtered and sorted list of legal cases along with their associated parties, based on specified criteria. The function allows filtering by various case and party attributes, such as case identifiers, names, dates, and party types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines case details with the corresponding party information, providing a comprehensive view of the case and its participants. The response includes a status indicator and the retrieved data, formatted for clarity and ease of use.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_parties_party_id": {"type": "object", "description": "Filter for the party's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1)."}, "case_parties_case_id": {"type": "object", "description": "Filter for the party's associated case identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "case_parties_party_type": {"type": "object", "description": "Filter for the party's type (e.g., plaintiff, defendant). The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'plaintiff')."}, "case_parties_party_name": {"type": "object", "description": "Filter for the party's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%david%')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying direction (e.g., ['cases_acceptance_date DESC', 'case_parties_party_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "create_case", "description": "Registers a new case in the system with the provided details, including case name, type, status, stage, and acceptance date. Optionally, a due date can be specified. The function validates all inputs for correctness and ensures the case type, status, and stage exist in the system. Upon successful creation, it returns the complete details of the newly registered case, including its unique identifier and all associated attributes. If any validation fails or required references are missing, an error is returned with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date when the case was accepted, must be in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The status of the case, must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The stage of the case, must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, must be in 'YYYY-MM-DD' format if provided."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "update_assignment_completion", "description": "Updates the completion date of a specific assignment for a given case. Validates the input data to ensure the case and assignment exist, and the completion date is in the correct format. On success, returns the updated assignment details along with a success status. On failure, returns an error message indicating the reason for the failure, such as invalid input, case not found, or assignment not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the assignment belongs. Must be a non-empty string with a maximum length of 200 characters."}, "assignment_content": {"type": "string", "description": "The content of the assignment to be updated. Must be a non-empty string."}, "completion_date": {"type": "string", "description": "The new completion date for the assignment, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "assignment_content", "completion_date"]}}}, {"type": "function", "function": {"name": "create_appeal_proceeding", "description": "Initiates an appeal proceeding for a specified case, updating its status and stage to reflect the appeal process. Validates input parameters for correctness and ensures the case exists before proceeding. On success, returns the updated case details including its new status and stage, confirming the appeal has been formally registered. If the case does not exist or inputs are invalid, returns an error with specific details.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the appeal is being initiated. Must be a non-empty string with a maximum length of 200 characters."}, "appeals_unit": {"type": "string", "description": "The unit responsible for handling the appeal. Must be a non-empty string with a maximum length of 100 characters."}, "appeal_date": {"type": "string", "description": "The date when the appeal is initiated, formatted as 'YYYY-MM-DD'."}, "appeal_due_date": {"type": "string", "description": "The deadline for the appeal process, formatted as 'YYYY-MM-DD'."}, "new_due_date": {"type": "string", "description": "The new due date for the case after the appeal is initiated, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "appeals_unit", "appeal_date", "appeal_due_date", "new_due_date"]}}}, {"type": "function", "function": {"name": "prepare_mediation_materials", "description": "Initiates the preparation of mediation materials for a specified case by updating its stage to 'Mediation' and creating a corresponding assignment. Validates input parameters for correctness, including case name, mediation unit, and date formats. On success, returns the updated case details along with a success status. On failure, returns an error status with a description of the issue, such as invalid input or case not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which mediation materials are to be prepared. Must be a non-empty string with a maximum length of 200 characters."}, "mediation_unit": {"type": "string", "description": "The unit responsible for the mediation. Must be a non-empty string with a maximum length of 100 characters."}, "mediation_date": {"type": "string", "description": "The date when the mediation is scheduled to occur, in 'YYYY-MM-DD' format."}, "mediation_due_date": {"type": "string", "description": "The deadline for preparing the mediation materials, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "mediation_unit", "mediation_date", "mediation_due_date"]}}}, {"type": "function", "function": {"name": "replace_case_status", "description": "Updates the name of an existing case status to a new name, ensuring the change adheres to validation rules. The function verifies the existence of the original case status and validates the new name before performing the update. Upon success, it returns the updated case status details, including its unique identifier and other relevant attributes. If the original case status does not exist or the input fails validation, the function returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The current name of the case status to be updated. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_status_name": {"type": "string", "description": "The new name to assign to the case status. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name", "new_case_status_name"]}}}, {"type": "function", "function": {"name": "escalate_complaint_to_case", "description": "Converts a complaint into a formal case, including setting up assignments and parties involved. Validates all inputs for correctness and ensures the complaint is eligible for escalation. On success, returns the newly created case details, including its unique identifier and associated information. If any validation fails or the complaint cannot be escalated, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "integer", "description": "The unique identifier of the complaint to be escalated. Must correspond to an existing complaint."}, "case_name": {"type": "string", "description": "The name of the new case. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case. Must be a non-empty string with a maximum length of 100 characters."}, "case_status_name": {"type": "string", "description": "The initial status of the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The initial stage of the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The due date for the case in 'YYYY-MM-DD' format."}, "assignments": {"type": "array", "items": {"type": "object", "properties": {"assignment_unit": {"type": "string", "description": "The unit responsible for the assignment. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_content": {"type": "string", "description": "The content or description of the assignment. Must be a non-empty string."}, "assignment_due_date": {"type": "string", "description": "The due date for the assignment in 'YYYY-MM-DD' format."}}, "required": ["assignment_unit", "assignment_content", "assignment_due_date"]}, "description": "A list of assignments associated with the case. Each assignment must include 'assignment_unit', 'assignment_content', and 'assignment_due_date'."}, "parties": {"type": "array", "items": {"type": "object", "properties": {"party_type": {"type": "string", "description": "The type of the party involved in the case. Must be a non-empty string with a maximum length of 20 characters."}, "party_name": {"type": "string", "description": "The name of the party involved in the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["party_type", "party_name"]}, "description": "A list of parties involved in the case. Each party must include 'party_type' and 'party_name'."}}, "required": ["complaint_id", "case_name", "case_type_name", "case_status_name", "case_stage_name", "due_date", "assignments", "parties"]}}}, {"type": "function", "function": {"name": "replace_case_plaintiff", "description": "Replaces the plaintiff in a specified legal case with a new plaintiff. The function ensures the case exists and the old plaintiff is correctly identified before performing the replacement. Upon success, it returns the details of the newly added plaintiff, including their unique identifier and associated case information. If the case or old plaintiff is not found, or if input validation fails, the function returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case where the plaintiff replacement is to occur. Must be a non-empty string with a maximum length of 200 characters."}, "old_plaintiff_name": {"type": "string", "description": "The name of the plaintiff to be replaced in the case. Must be a non-empty string with a maximum length of 200 characters."}, "new_plaintiff_name": {"type": "string", "description": "The name of the new plaintiff to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "old_plaintiff_name", "new_plaintiff_name"]}}}, {"type": "function", "function": {"name": "replace_case_details", "description": "Updates the details of an existing case in the system, including its type, status, stage, and acceptance date. Validates all inputs for correctness and ensures the case exists before making changes. On success, returns a confirmation of the update along with the complete updated case record, including all its fields. If the case or any referenced attributes (like type or status) do not exist, or if input validation fails, returns an error with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The unique name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The name of the case type to assign to the case. Must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The name of the case status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The name of the case stage to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, in 'YYYY-MM-DD' format. If not provided, the due date will be cleared."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "record_verdict", "description": "Records the verdict for a specific legal proceeding, updating its status to 'Verdicted' and returning the updated proceeding details. The function validates the input case name, court name, and verdict date format before processing. On success, it returns the status 'success' along with the complete details of the updated proceeding. On failure, it returns the status 'failure' with an error message indicating the reason, such as invalid input, case not found, or proceeding not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case, which must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the proceeding took place, which must be a non-empty string with a maximum length of 200 characters."}, "verdict_date": {"type": "string", "description": "The date of the verdict, which must be provided in the 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "verdict_date"]}}}, {"type": "function", "function": {"name": "reopen_case_due_to_new_evidence", "description": "Reopens a previously closed case due to the discovery of new evidence, assigning it to a review unit with specified dates and evidence details. Upon success, returns the details of the newly created assignment, including the case identifier, review unit, assignment and due dates, and evidence description, confirming the case's updated status and the assignment's successful creation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened, must be non-empty and not exceed 200 characters."}, "evidence_review_unit": {"type": "string", "description": "The unit responsible for reviewing the new evidence, must be non-empty and not exceed 100 characters."}, "review_assignment_date": {"type": "string", "description": "The date when the review assignment is made, in 'YYYY-MM-DD' format."}, "review_due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the new evidence prompting the case reopening, must be non-empty."}}, "required": ["case_name", "evidence_review_unit", "review_assignment_date", "review_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "replace_complaint_details", "description": "Updates the details of an existing complaint in the system, including its source, handling unit, result, and category. Validates all inputs for correctness and ensures the complaint exists before proceeding with the update. On success, returns the updated complaint record along with a success status. If the complaint does not exist or inputs are invalid, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date of the complaint in 'YYYY-MM-DD' format. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The source of the complaint, must not exceed 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed content of the complaint, must not be empty. Example: 'Product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The unit responsible for handling the complaint, must not exceed 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The result of handling the complaint, must not exceed 50 characters. Example: 'Resolved with refund'."}, "complaint_category": {"type": "string", "description": "The category of the complaint, must not exceed 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "create_case_status", "description": "Registers a new case status in the system. The function validates the provided case status name to ensure it meets length and non-empty requirements. Upon successful registration, it returns the newly created case status record, including its unique identifier and details. If validation fails or a database error occurs, it returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The name of the case status to be registered. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name"]}}}, {"type": "function", "function": {"name": "settle_case", "description": "Finalizes the settlement of a legal case by updating its status to 'Settled' and stage to 'Closed', and records the settlement details. This includes assigning a settlement unit, documenting the settlement date, and setting a due date for any follow-up actions. Upon success, returns the updated case record with its new status and stage, along with confirmation of the settlement process completion. If the case does not exist or input validation fails, returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_unit": {"type": "string", "description": "The unit responsible for handling the settlement. Must be a non-empty string with a maximum length of 100 characters."}, "settlement_date": {"type": "string", "description": "The date when the settlement is finalized, in 'YYYY-MM-DD' format."}, "settlement_due_date": {"type": "string", "description": "The due date for any follow-up actions related to the settlement, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "settlement_unit", "settlement_date", "settlement_due_date"]}}}, {"type": "function", "function": {"name": "add_expert_witness", "description": "Associates an expert witness with a specified legal case, ensuring the inputs meet validation criteria. Upon successful association, returns the details of the newly added expert witness, including their unique identifier and role. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case to which the expert witness will be added. Must be a non-empty string not exceeding 200 characters."}, "expert_name": {"type": "string", "description": "The full name of the expert witness to be associated with the case. Must be a non-empty string not exceeding 200 characters."}}, "required": ["case_name", "expert_name"]}}}, {"type": "function", "function": {"name": "consolidate_duplicate_case_type", "description": "Merges a duplicate case type into an original case type by updating all associated cases and removing the duplicate. Validates the existence of both the original and duplicate case types before proceeding. On success, returns the updated details of the original case type along with a success status. On failure, returns an error message indicating the reason for the failure, such as missing case types or database errors.", "parameters": {"type": "object", "properties": {"duplicate_name": {"type": "string", "description": "The name of the duplicate case type to be merged into the original. Must be a non-empty string with a maximum length of 100 characters."}, "original_id": {"type": "integer", "description": "The unique identifier of the original case type into which the duplicate will be merged. Must correspond to an existing case type."}}, "required": ["duplicate_name", "original_id"]}}}, {"type": "function", "function": {"name": "reopen_for_dna_evidence", "description": "Reopens a legal case for further investigation based on new DNA evidence, assigns it to a forensics unit, and schedules a review. The function ensures all inputs meet specified constraints before proceeding. Upon success, it returns the updated case details, including the new status and stage, confirming the case has been reopened and assigned for review.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened. Must be a non-empty string with a maximum length of 200 characters."}, "forensics_unit": {"type": "string", "description": "The forensics unit assigned to review the DNA evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the case is assigned for review, in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "forensics_unit", "assignment_date", "due_date"]}}}, {"type": "function", "function": {"name": "replace_case_stage", "description": "Renames an existing case stage to a new name, ensuring the new name is unique and the original exists. Validates input lengths and checks for duplicates before proceeding. On success, returns the updated case stage details including its identifier and other attributes. If the original case stage does not exist, the new name is already in use, or validation fails, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The current name of the case stage to be renamed. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_stage_name": {"type": "string", "description": "The new name to assign to the case stage. Must be a non-empty string with a maximum length of 50 characters and must not already exist in the system."}}, "required": ["case_stage_name", "new_case_stage_name"]}}}, {"type": "function", "function": {"name": "create_field_investigation_case", "description": "Attempts to create a new field investigation case but fails due to a missing required parameter ('case_status_id'). The function validates input parameters for format and constraints but cannot proceed with case creation because the signature is incomplete. Upon failure, it returns an error message detailing the contract violation, specifically the absence of the required 'case_status_id' parameter.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, must be in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The due date for the case, must be in 'YYYY-MM-DD' format."}, "investigation_unit": {"type": "string", "description": "The unit responsible for the investigation, must be a non-empty string with a maximum length of 100 characters."}, "investigation_date": {"type": "string", "description": "The date the investigation starts, must be in 'YYYY-MM-DD' format."}, "investigation_due_date": {"type": "string", "description": "The due date for the investigation, must be in 'YYYY-MM-DD' format."}, "investigation_content": {"type": "string", "description": "The content or details of the investigation, must be a non-empty string."}, "plaintiff_name": {"type": "string", "description": "The name of the plaintiff, must be a non-empty string with a maximum length of 200 characters."}, "defendant_name": {"type": "string", "description": "The name of the defendant, must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness, must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court, must be a non-empty string with a maximum length of 200 characters."}, "case_reason": {"type": "string", "description": "The reason for the case, must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "case_type_name", "acceptance_date", "due_date", "investigation_unit", "investigation_date", "investigation_due_date", "investigation_content", "plaintiff_name", "defendant_name", "witness_name", "court_name", "case_reason"]}}}, {"type": "function", "function": {"name": "advance_case_stage", "description": "Updates the stage of a specified case to a new stage, ensuring both the case and the new stage exist. On success, returns the updated case details including its new stage. If the case or stage does not exist, or if an error occurs during the update, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be advanced to a new stage. Must be a non-empty string with a maximum length of 200 characters."}, "new_stage_name": {"type": "string", "description": "The name of the new stage to which the case will be advanced. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_stage_name"]}}}, {"type": "function", "function": {"name": "create_case_type", "description": "Registers a new case type in the system, ensuring the name is unique and meets validation criteria. On success, returns the details of the newly created case type, including its unique identifier and name. If the name is invalid or already exists, returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The name of the case type to be created. Must be a non-empty string with a maximum length of 100 characters and must not already exist in the system."}}, "required": ["case_type_name"]}}}, {"type": "function", "function": {"name": "create_settlement_proceeding", "description": "Marks a legal case as settled by recording the case name, court name, and settlement date. This function is intended to finalize the settlement process for a case. However, due to a contract violation in the function signature, it will always return a failure status with an error message indicating the missing required columns 'case_reason' and 'progress_status'. The return value upon failure includes a status of 'failure' and a detailed error message explaining the contract violation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case being settled. Must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the case is being settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_date": {"type": "string", "description": "The date on which the settlement is finalized, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "settlement_date"]}}}, {"type": "function", "function": {"name": "close_case", "description": "Finalizes the closure of a specified case by updating its status and stage to 'Closed', and records the closure details including the responsible unit and relevant dates. Upon successful execution, returns a confirmation of the closure along with the updated case details, including its unique identifier and current status. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be closed, must be a non-empty string with a maximum length of 200 characters."}, "closure_unit": {"type": "string", "description": "The unit responsible for closing the case, must be a non-empty string with a maximum length of 100 characters."}, "closure_date": {"type": "string", "description": "The date when the case is closed, must be in 'YYYY-MM-DD' format."}, "closure_due_date": {"type": "string", "description": "The due date for the closure documentation, must be in 'YYYY-MM-DD' format."}}, "required": ["case_name", "closure_unit", "closure_date", "closure_due_date"]}}}, {"type": "function", "function": {"name": "add_witness_to_case", "description": "Associates a witness with a specific case in the system. Validates the input names for length and ensures the case exists. On success, returns the details of the newly added witness, including their unique identifier, the case they are associated with, their role as a witness, and their name. If the case does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the witness will be added. Must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "witness_name"]}}}, {"type": "function", "function": {"name": "update_case_status", "description": "Updates the status of a specified case to a new status, ensuring both the case and the new status exist. On success, returns the updated case details along with a success status. If the case or status does not exist, or if an error occurs, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "new_status_name": {"type": "string", "description": "The new status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_status_name"]}}}, {"type": "function", "function": {"name": "complete_supreme_court_proceeding", "description": "Marks a Supreme Court proceeding for a specified case as completed. The function verifies the existence of the case and its associated Supreme Court proceeding before updating the status. Upon success, it returns the updated proceeding details, including its status and other relevant information. If the case or proceeding is not found, or if an error occurs during processing, the function returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the Supreme Court proceeding is to be marked as completed. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name"]}}}, {"type": "function", "function": {"name": "add_evidence_review_assignment", "description": "Assigns a new evidence review task for a specific case, ensuring all input data is validated. On success, returns the details of the newly created assignment, including its unique identifier and all associated information. If the case does not exist or input validation fails, returns an error with a specific failure reason.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the evidence review is being assigned. Must be a non-empty string with a maximum length of 200 characters."}, "evidence_unit": {"type": "string", "description": "The unit or department responsible for reviewing the evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the evidence review is assigned, in 'YYYY-MM-DD' format."}, "assignment_due_date": {"type": "string", "description": "The due date for completing the evidence review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the evidence to be reviewed. Must be a non-empty string."}}, "required": ["case_name", "evidence_unit", "assignment_date", "assignment_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "create_case_stage", "description": "Registers a new stage for a case in the system. Validates the provided stage name to ensure it meets length and non-empty requirements. Upon successful registration, returns the unique identifier and details of the newly created case stage, including its status. If validation fails or an error occurs during processing, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The name of the case stage to be created. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_stage_name"]}}}, {"type": "function", "function": {"name": "create_complaint", "description": "Registers a new complaint in the system, ensuring all provided details meet the required validation criteria. Upon successful registration, returns the complete details of the newly created complaint, including its unique identifier and all submitted information. If validation fails or a database error occurs, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date when the complaint was filed, formatted as 'YYYY-MM-DD'. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The origin or source of the complaint, limited to 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed description or content of the complaint. Must not be empty. Example: 'The product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The department or team responsible for handling the complaint, limited to 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The outcome or resolution status of the complaint, limited to 50 characters. Example: 'Pending investigation'."}, "complaint_category": {"type": "string", "description": "The category or type of the complaint, limited to 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "replace_case_type", "description": "Renames an existing case type to a new name, ensuring the change adheres to validation rules. If successful, returns the updated case type details including its identifier and other attributes. If the original case type does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The current name of the case type to be renamed. Must be a non-empty string with a maximum length of 100 characters."}, "new_case_type_name": {"type": "string", "description": "The new name for the case type. Must be a non-empty string with a maximum length of 100 characters."}}, "required": ["case_type_name", "new_case_type_name"]}}}], "tool_execute_env": "import os\nimport re\nimport sys\nimport math\nimport pytest\nimport sqlite3\nfrom datetime import datetime\nfrom typing import *\n\ndef query_case_statuses_join_cases(case_statuses_case_status_id: Optional[Dict[str, Any]] = None, case_statuses_case_status_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_statuses\".\"case_status_id\" AS \"case_statuses_case_status_id\",\n                \"case_statuses\".\"case_status_name\" AS \"case_statuses_case_status_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_statuses\"\n            JOIN \"cases\" ON \"case_statuses\".\"case_status_id\" = \"cases\".\"case_status_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, table_name, column_name):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    if not isinstance(value, (list, tuple)):\n                        raise ValueError(\"IN operator requires a list of values\")\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add conditions for each filter parameter with proper table names\n        add_condition(case_statuses_case_status_id, \"case_statuses\", \"case_status_id\")\n        add_condition(case_statuses_case_status_name, \"case_statuses\", \"case_status_name\")\n        add_condition(cases_case_id, \"cases\", \"case_id\")\n        add_condition(cases_case_name, \"cases\", \"case_name\")\n        add_condition(cases_case_type_id, \"cases\", \"case_type_id\")\n        add_condition(cases_acceptance_date, \"cases\", \"acceptance_date\")\n        add_condition(cases_case_status_id, \"cases\", \"case_status_id\")\n        add_condition(cases_case_stage_id, \"cases\", \"case_stage_id\")\n        add_condition(cases_due_date, \"cases\", \"due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            # Validate order_by columns to prevent SQL injection\n            validated_order_by = []\n            for item in order_by:\n                parts = item.split()\n                col_name = parts[0]\n                direction = parts[1].upper() if len(parts) > 1 else \"ASC\"\n                if direction not in [\"ASC\", \"DESC\"]:\n                    direction = \"ASC\"\n                validated_order_by.append(f'\"{col_name}\" {direction}')\n            query += \" ORDER BY \" + \", \".join(validated_order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            row_dict = dict(zip(columns, row))\n            result = {\n                'case_statuses': {\n                    'case_status_id': row_dict['case_statuses_case_status_id'],\n                    'case_status_name': row_dict['case_statuses_case_status_name']\n                },\n                'cases': {\n                    'case_id': row_dict['cases_case_id'],\n                    'case_name': row_dict['cases_case_name'],\n                    'case_type_id': row_dict['cases_case_type_id'],\n                    'acceptance_date': row_dict['cases_acceptance_date'],\n                    'case_status_id': row_dict['cases_case_status_id'],\n                    'case_stage_id': row_dict['cases_case_stage_id'],\n                    'due_date': row_dict['cases_due_date']\n                }\n            }\n            results.append(result)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases(case_id: Optional[Dict[str, Any]] = None, case_name: Optional[Dict[str, Any]] = None, case_type_id: Optional[Dict[str, Any]] = None, acceptance_date: Optional[Dict[str, Any]] = None, case_status_id: Optional[Dict[str, Any]] = None, case_stage_id: Optional[Dict[str, Any]] = None, due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_id\", \"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\" FROM \"cases\"'\n        \n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add condition\n        def add_condition(column, filter_dict):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column} must be a list when using IN/NOT IN\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n        \n        # Add all conditions\n        add_condition('case_id', case_id)\n        add_condition('case_name', case_name)\n        add_condition('case_type_id', case_type_id)\n        add_condition('acceptance_date', acceptance_date)\n        add_condition('case_status_id', case_status_id)\n        add_condition('case_stage_id', case_stage_id)\n        add_condition('due_date', due_date)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                parts = clause.split()\n                if len(parts) == 1:\n                    order_clauses.append(f'\"{parts[0]}\"')\n                elif len(parts) == 2:\n                    order_clauses.append(f'\"{parts[0]}\" {parts[1].upper()}')\n                else:\n                    raise ValueError(f\"Invalid order_by clause: {clause}\")\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET\n        if limit is not None:\n            if limit < 0:\n                raise ValueError(\"Limit must be >= 0\")\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                raise ValueError(\"Offset must be >= 0\")\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Get results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_assignments(\n    cases_case_id: Optional[Dict[str, Any]] = None,\n    cases_case_name: Optional[Dict[str, Any]] = None,\n    cases_case_type_id: Optional[Dict[str, Any]] = None,\n    cases_acceptance_date: Optional[Dict[str, Any]] = None,\n    cases_case_status_id: Optional[Dict[str, Any]] = None,\n    cases_case_stage_id: Optional[Dict[str, Any]] = None,\n    cases_due_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_id: Optional[Dict[str, Any]] = None,\n    case_assignments_case_id: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_unit: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_content: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_assignments\".\"assignment_id\", \"case_assignments\".\"case_id\" AS \"assignment_case_id\",\n                \"case_assignments\".\"assignment_unit\", \"case_assignments\".\"assignment_date\",\n                \"case_assignments\".\"assignment_content\", \"case_assignments\".\"assignment_due_date\"\n            FROM \"cases\"\n            LEFT JOIN \"case_assignments\" ON \"cases\".\"case_id\" = \"case_assignments\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(table, column_name, filter_dict):\n            if filter_dict is None:\n                return\n            \n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            \n            if op.upper() not in ('=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'):\n                raise ValueError(f\"Invalid operator: {op}\")\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column_name} must be a list when using IN/NOT IN operator\")\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ?')\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases', 'case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases', 'case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases', 'case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases', 'acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases', 'case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases', 'case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases', 'due_date', cases_due_date)\n\n        # Add filters for case_assignments table\n        if case_assignments_assignment_id is not None:\n            add_filter('case_assignments', 'assignment_id', case_assignments_assignment_id)\n        if case_assignments_case_id is not None:\n            add_filter('case_assignments', 'case_id', case_assignments_case_id)\n        if case_assignments_assignment_unit is not None:\n            add_filter('case_assignments', 'assignment_unit', case_assignments_assignment_unit)\n        if case_assignments_assignment_date is not None:\n            add_filter('case_assignments', 'assignment_date', case_assignments_assignment_date)\n        if case_assignments_assignment_content is not None:\n            add_filter('case_assignments', 'assignment_content', case_assignments_assignment_content)\n        if case_assignments_assignment_due_date is not None:\n            add_filter('case_assignments', 'assignment_due_date', case_assignments_assignment_due_date)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split('_', 1)  # Split on first underscore to separate table prefix\n                if len(parts) == 2:\n                    table_name, rest = parts\n                    column_parts = rest.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"{table_name}\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"{table_name}\".\"{rest}\"')\n                else:\n                    # Default to cases table if no prefix specified\n                    column_parts = col.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"cases\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"cases\".\"{col}\"')\n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n\n        # Transform results into the required format\n        results = []\n        for row in rows:\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            \n            result_item = {'cases': case_data}\n            \n            # Only include assignment data if assignment_id exists\n            if row[7] is not None:\n                assignment_data = {\n                    'assignment_id': row[7],\n                    'case_id': row[8],\n                    'assignment_unit': row[9],\n                    'assignment_date': row[10],\n                    'assignment_content': row[11],\n                    'assignment_due_date': row[12]\n                }\n                result_item['case_assignments'] = assignment_data\n                \n            results.append(result_item)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        raise  # Re-raise to fail the test\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types(case_type_id: Optional[Dict[str, Any]] = None, case_type_name: Optional[Dict[str, Any]] = None, \n                    order_by: Optional[List[str]] = None, limit: Optional[int] = None, \n                    offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_types table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Base query\n        query = 'SELECT \"case_type_id\", \"case_type_name\" FROM \"case_types\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_type_id is not None:\n            op = case_type_id.get('op')\n            value = case_type_id.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_id\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_id\" {op} ?')\n                    params.append(value)\n        \n        if case_type_name is not None:\n            op = case_type_name.get('op')\n            value = case_type_name.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_name\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_name\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            try:\n                # Get valid column names from the table\n                cursor.execute('PRAGMA table_info(\"case_types\")')\n                valid_columns = [row[1].lower() for row in cursor.fetchall()]\n                \n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) == 1:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\"')\n                    elif len(parts) == 2:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\" {parts[1].upper()}')\n                    else:\n                        return {'status': 'failure', 'content': {'error': 'Invalid order_by format'}}\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except Exception as e:\n                return {'status': 'failure', 'content': {'error': f'Invalid order_by: {str(e)}'}}\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_assignments(\n    assignment_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    assignment_unit: Optional[Dict[str, Any]] = None,\n    assignment_date: Optional[Dict[str, Any]] = None,\n    assignment_content: Optional[Dict[str, Any]] = None,\n    assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_assignments table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Valid columns for order_by validation\n        valid_columns = {\n            'assignment_id', 'case_id', 'assignment_unit', \n            'assignment_date', 'assignment_content', 'assignment_due_date'\n        }\n\n        # Build the base query\n        query = 'SELECT \"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\" FROM \"case_assignments\"'\n        params = []\n        \n        # Build WHERE clause for filters\n        conditions = []\n        \n        filter_mapping = {\n            'assignment_id': assignment_id,\n            'case_id': case_id,\n            'assignment_unit': assignment_unit,\n            'assignment_date': assignment_date,\n            'assignment_content': assignment_content,\n            'assignment_due_date': assignment_due_date\n        }\n        \n        for column, filter_dict in filter_mapping.items():\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                \n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': f'Value for {column} IN/NOT IN must be a list'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column}\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                # Validate order_by clause format and column names\n                parts = clause.split()\n                if len(parts) != 2 or parts[1].upper() not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                column_name = parts[0]\n                if column_name not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {column_name}'}}\n                order_clauses.append(f'\"{column_name}\" {parts[1].upper()}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute the query\n        cursor.execute(query, params)\n        \n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_proceedings(\n    proceeding_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    court_name: Optional[Dict[str, Any]] = None,\n    case_reason: Optional[Dict[str, Any]] = None,\n    progress_status: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_proceedings table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\" FROM \"case_proceedings\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"proceeding_id\", proceeding_id),\n            (\"case_id\", case_id),\n            (\"court_name\", court_name),\n            (\"case_reason\", case_reason),\n            (\"progress_status\", progress_status)\n        ]\n\n        for col_name, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        if not isinstance(value, (list, tuple)):\n                            return {'status': 'failure', 'content': {'error': f'Value for {col_name} must be a list for IN/NOT IN operations'}}\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{col_name}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{col_name}\" {op} ?')\n                        params.append(value)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            order_clauses = []\n            valid_columns = {'proceeding_id', 'case_id', 'court_name', 'case_reason', 'progress_status'}\n            for clause in order_by:\n                # Basic validation to prevent SQL injection\n                parts = clause.split()\n                if len(parts) not in (1, 2):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                col = parts[0]\n                if col not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                if direction not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid sort direction: {direction}'}}\n                order_clauses.append(f'\"{col}\" {direction}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n\n        # Process pagination\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n\n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_statuses(\n    case_status_id: Optional[Dict[str, Any]] = None,\n    case_status_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_statuses table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        # Validate input parameters\n        if limit is not None and limit < 0:\n            return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n        if offset is not None and offset < 0:\n            return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_status_id\", \"case_status_name\" FROM \"case_statuses\"'\n        params = []\n        conditions = []\n\n        # Build WHERE clause for each filter\n        if case_status_id is not None:\n            op = case_status_id.get('op')\n            value = case_status_id.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_id: {op}'}}\n            if not isinstance(value, int) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_id value must be an integer'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_id\" {op} ?')\n                params.append(value)\n\n        if case_status_name is not None:\n            op = case_status_name.get('op')\n            value = case_status_name.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_name: {op}'}}\n            if not isinstance(value, str) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_name value must be a string'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_name\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            try:\n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) not in [1, 2]:\n                        raise ValueError\n                    column = parts[0]\n                    direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                    if direction not in ['ASC', 'DESC']:\n                        raise ValueError\n                    if column not in ['case_status_id', 'case_status_name']:\n                        raise ValueError\n                    order_clauses.append(f'\"{column}\" {direction}')\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': 'Invalid order_by clause'}}\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages_join_cases(case_stages_case_stage_id: Optional[Dict[str, Any]] = None, case_stages_case_stage_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_stages\".\"case_stage_id\" AS \"case_stages_case_stage_id\",\n                \"case_stages\".\"case_stage_name\" AS \"case_stages_case_stage_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_stages\"\n            INNER JOIN \"cases\" ON \"case_stages\".\"case_stage_id\" = \"cases\".\"case_stage_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, column_name):\n            if filter_dict is not None:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible conditions using the exact column aliases from SELECT\n        add_condition(case_stages_case_stage_id, \"case_stages_case_stage_id\")\n        add_condition(case_stages_case_stage_name, \"case_stages_case_stage_name\")\n        add_condition(cases_case_id, \"cases_case_id\")\n        add_condition(cases_case_name, \"cases_case_name\")\n        add_condition(cases_case_type_id, \"cases_case_type_id\")\n        add_condition(cases_acceptance_date, \"cases_acceptance_date\")\n        add_condition(cases_case_status_id, \"cases_case_status_id\")\n        add_condition(cases_case_stage_id, \"cases_case_stage_id\")\n        add_condition(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            case_stages = {\n                'case_stage_id': row[0],\n                'case_stage_name': row[1]\n            }\n            cases = {\n                'case_id': row[2],\n                'case_name': row[3],\n                'case_type_id': row[4],\n                'acceptance_date': row[5],\n                'case_status_id': row[6],\n                'case_stage_id': row[7],\n                'due_date': row[8]\n            }\n            results.append({\n                'case_stages': case_stages,\n                'cases': cases\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages(case_stage_id: Optional[Dict[str, Any]] = None, case_stage_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_stage_id\", \"case_stage_name\" FROM \"case_stages\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_stage_id is not None:\n            op = case_stage_id.get('op')\n            value = case_stage_id.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_id\" {op} ?')\n                params.append(value)\n        \n        if case_stage_name is not None:\n            op = case_stage_name.get('op')\n            value = case_stage_name.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_name\" {op} ?')\n                params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types_join_cases(case_types_case_type_id: Optional[Dict[str, Any]] = None, case_types_case_type_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with aliases that match the filter parameter names\n        query = \"\"\"\n            SELECT \n                \"case_types\".\"case_type_id\" as \"case_types_case_type_id\",\n                \"case_types\".\"case_type_name\" as \"case_types_case_type_name\",\n                \"cases\".\"case_id\" as \"cases_case_id\",\n                \"cases\".\"case_name\" as \"cases_case_name\",\n                \"cases\".\"case_type_id\" as \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" as \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" as \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" as \"cases_case_stage_id\",\n                \"cases\".\"due_date\" as \"cases_due_date\"\n            FROM \"case_types\"\n            INNER JOIN \"cases\" ON \"case_types\".\"case_type_id\" = \"cases\".\"case_type_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add filter conditions using the exact alias names\n        def add_filter(filter_dict, column_alias):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_alias}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_alias}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible filters using the exact alias names\n        add_filter(case_types_case_type_id, \"case_types_case_type_id\")\n        add_filter(case_types_case_type_name, \"case_types_case_type_name\")\n        add_filter(cases_case_id, \"cases_case_id\")\n        add_filter(cases_case_name, \"cases_case_name\")\n        add_filter(cases_case_type_id, \"cases_case_type_id\")\n        add_filter(cases_acceptance_date, \"cases_acceptance_date\")\n        add_filter(cases_case_status_id, \"cases_case_status_id\")\n        add_filter(cases_case_stage_id, \"cases_case_stage_id\")\n        add_filter(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified (using the same alias names)\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Transform results into the required format\n        results = []\n        for row in rows:\n            record = {\n                'case_types': {\n                    'case_type_id': row[0],\n                    'case_type_name': row[1]\n                },\n                'cases': {\n                    'case_id': row[2],\n                    'case_name': row[3],\n                    'case_type_id': row[4],\n                    'acceptance_date': row[5],\n                    'case_status_id': row[6],\n                    'case_stage_id': row[7],\n                    'due_date': row[8]\n                }\n            }\n            results.append(record)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_parties(\n    party_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    party_type: Optional[Dict[str, Any]] = None,\n    party_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_parties table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\"'\n        params = []\n        conditions = []\n\n        # Helper function to build filter conditions\n        def add_filter(column: str, filter_dict: Optional[Dict[str, Any]]):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n\n        # Add filters\n        add_filter('party_id', party_id)\n        add_filter('case_id', case_id)\n        add_filter('party_type', party_type)\n        add_filter('party_name', party_name)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Add pagination\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_complaints(\n    complaint_id: Optional[Dict[str, Any]] = None,\n    complaint_time: Optional[Dict[str, Any]] = None,\n    complaint_source: Optional[Dict[str, Any]] = None,\n    complaint_content: Optional[Dict[str, Any]] = None,\n    handling_unit: Optional[Dict[str, Any]] = None,\n    handling_result: Optional[Dict[str, Any]] = None,\n    complaint_category: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the complaints table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT * FROM \"complaints\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"complaint_id\", complaint_id),\n            (\"complaint_time\", complaint_time),\n            (\"complaint_source\", complaint_source),\n            (\"complaint_content\", complaint_content),\n            (\"handling_unit\", handling_unit),\n            (\"handling_result\", handling_result),\n            (\"complaint_category\", complaint_category)\n        ]\n\n        for column, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{column}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{column}\" {op} ?')\n                        params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Process pagination\n        if limit is not None and limit >= 0:\n            query += ' LIMIT ?'\n            params.append(limit)\n            if offset is not None and offset >= 0:\n                query += ' OFFSET ?'\n                params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_sqlite_sequence(\n    name: Optional[Dict[str, Any]] = None,\n    seq: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the sqlite_sequence table with dynamic filtering, sorting, and pagination.\n\n    All column parameters are optional filters. Provide a dictionary with 'op' and 'value'\n    to apply a condition. Multiple filters are combined with a logical AND.\n\n    Args:\n        name: Optional filter for the table name associated with the sequence.\n            e.g., {'op': '=', 'value': 'some_table'}. The value must be a string. No specific format is enforced.\n        seq: Optional filter for the sequence value.\n            e.g., {'op': '>', 'value': 100}. The value must be an integer.\n        order_by: Optional list of columns to sort by, e.g., [\"seq DESC\", \"name ASC\"].\n        limit: Optional integer to limit the number of results. Must be >= 0.\n        offset: Optional integer to offset the results for pagination. Must be >= 0.\n        Supported operators are `'='`, `'<'`, `'>'`, `'<='`, `'>='`, `'<>'`, `'LIKE'`, `'NOT LIKE'`, `'IN'`, and `'NOT IN'`.\n\n    Returns:\n        Dict[str, Union[str, Dict[str, Any]]]: A dictionary indicating the outcome.\n        - On success: {'status': 'success', 'content': [list_of_records]}\n          The `content` is a list of dictionaries, where each dictionary is a record\n          from the sqlite_sequence table. All keys are lowercase.\n          e.g., [{'name': 'some_table', 'seq': 123}]\n        - On failure: {'status': 'failure', 'content': {'error': '<error_message>'}}\n\n    Associated schemas: [\"sqlite_sequence\"]\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"name\", \"seq\" FROM \"sqlite_sequence\"'\n        params = []\n\n        # Apply filters\n        conditions = []\n        if name:\n            op = name.get('op')\n            value = name.get('value')\n            if op and value is not None:\n                conditions.append(f'\"name\" {op} ?')\n                params.append(value)\n        \n        if seq:\n            op = seq.get('op')\n            value = seq.get('value')\n            if op and value is not None:\n                conditions.append(f'\"seq\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Apply sorting\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Apply pagination\n        if limit is not None and limit >= 0:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        \n        if offset is not None and offset >= 0:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_proceedings(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_proceedings_proceeding_id: Optional[Dict[str, Any]] = None, case_proceedings_case_id: Optional[Dict[str, Any]] = None, case_proceedings_court_name: Optional[Dict[str, Any]] = None, case_proceedings_case_reason: Optional[Dict[str, Any]] = None, case_proceedings_progress_status: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\",\n                \"case_proceedings\".\"proceeding_id\" AS \"case_proceedings_proceeding_id\",\n                \"case_proceedings\".\"case_id\" AS \"case_proceedings_case_id\",\n                \"case_proceedings\".\"court_name\" AS \"case_proceedings_court_name\",\n                \"case_proceedings\".\"case_reason\" AS \"case_proceedings_case_reason\",\n                \"case_proceedings\".\"progress_status\" AS \"case_proceedings_progress_status\"\n            FROM \"cases\"\n            LEFT JOIN \"case_proceedings\" ON \"cases\".\"case_id\" = \"case_proceedings\".\"case_id\"\n            WHERE 1=1\n        \"\"\"\n\n        params = []\n        \n        # Helper function to add filter conditions\n        def add_filter(column_name, filter_dict):\n            if filter_dict is None:\n                return\n            nonlocal query, params\n            op = filter_dict['op']\n            value = filter_dict['value']\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                query += f' AND \"{column_name}\" {op} ({placeholders})'\n                params.extend(value)\n            else:\n                query += f' AND \"{column_name}\" {op} ?'\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases_case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases_case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases_case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases_acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases_case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases_case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases_due_date', cases_due_date)\n\n        # Add filters for case_proceedings table\n        if case_proceedings_proceeding_id is not None:\n            add_filter('case_proceedings_proceeding_id', case_proceedings_proceeding_id)\n        if case_proceedings_case_id is not None:\n            add_filter('case_proceedings_case_id', case_proceedings_case_id)\n        if case_proceedings_court_name is not None:\n            add_filter('case_proceedings_court_name', case_proceedings_court_name)\n        if case_proceedings_case_reason is not None:\n            add_filter('case_proceedings_case_reason', case_proceedings_case_reason)\n        if case_proceedings_progress_status is not None:\n            add_filter('case_proceedings_progress_status', case_proceedings_progress_status)\n\n        # Add ordering\n        if order_by is not None and len(order_by) > 0:\n            query += \" ORDER BY \" + \", \".join(\n                f'\"{col.split()[0]}\" {col.split()[1].upper()}' if len(col.split()) > 1 \n                else f'\"{col}\"'\n                for col in order_by\n            )\n\n        # Add limit and offset\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            proceeding_data = {\n                'proceeding_id': row[7],\n                'case_id': row[8],\n                'court_name': row[9],\n                'case_reason': row[10],\n                'progress_status': row[11]\n            }\n            results.append({\n                'cases': {k: v for k, v in case_data.items() if v is not None},\n                'case_proceedings': {k: v for k, v in proceeding_data.items() if v is not None}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_parties(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_parties_party_id: Optional[Dict[str, Any]] = None, case_parties_case_id: Optional[Dict[str, Any]] = None, case_parties_party_type: Optional[Dict[str, Any]] = None, case_parties_party_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_parties\".\"party_id\", \"case_parties\".\"case_id\" AS \"party_case_id\", \n                \"case_parties\".\"party_type\", \"case_parties\".\"party_name\"\n            FROM \"cases\"\n            INNER JOIN \"case_parties\" ON \"cases\".\"case_id\" = \"case_parties\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(filter_dict, table, column):\n            if filter_dict:\n                op = filter_dict['op'].upper()\n                value = filter_dict['value']\n                if op in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        value = [value]\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ?')\n                    params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id: add_filter(cases_case_id, 'cases', 'case_id')\n        if cases_case_name: add_filter(cases_case_name, 'cases', 'case_name')\n        if cases_case_type_id: add_filter(cases_case_type_id, 'cases', 'case_type_id')\n        if cases_acceptance_date: add_filter(cases_acceptance_date, 'cases', 'acceptance_date')\n        if cases_case_status_id: add_filter(cases_case_status_id, 'cases', 'case_status_id')\n        if cases_case_stage_id: add_filter(cases_case_stage_id, 'cases', 'case_stage_id')\n        if cases_due_date: add_filter(cases_due_date, 'cases', 'due_date')\n\n        # Add filters for case_parties table\n        if case_parties_party_id: add_filter(case_parties_party_id, 'case_parties', 'party_id')\n        if case_parties_case_id: add_filter(case_parties_case_id, 'case_parties', 'case_id')\n        if case_parties_party_type: add_filter(case_parties_party_type, 'case_parties', 'party_type')\n        if case_parties_party_name: add_filter(case_parties_party_name, 'case_parties', 'party_name')\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split()\n                col_name = parts[0]\n                direction = parts[1] if len(parts) > 1 else 'ASC'\n                \n                # Handle prefixed column names (e.g., \"cases_case_name\")\n                if col_name.startswith('cases_'):\n                    table = 'cases'\n                    column = col_name[6:]\n                elif col_name.startswith('case_parties_'):\n                    table = 'case_parties'\n                    column = col_name[13:]\n                else:\n                    # Default to cases table if no prefix\n                    table = 'cases'\n                    column = col_name\n                \n                order_clauses.append(f'\"{table}\".\"{column}\" {direction}')\n            \n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += f\" LIMIT {limit}\"\n        if offset is not None:\n            query += f\" OFFSET {offset}\"\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            party_data = {\n                'party_id': row[7],\n                'case_id': row[8],\n                'party_type': row[9],\n                'party_name': row[10]\n            }\n            results.append({\n                'cases': {k.lower(): v for k, v in case_data.items()},\n                'case_parties': {k.lower(): v for k, v in party_data.items()}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input lengths\n        if len(case_name) > 200:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_name' exceeds maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_type_name' exceeds maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds maximum length of 50 characters.\"}}\n\n        # Validate date formats\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, acceptance_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.match(date_pattern, due_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_result = cursor.fetchone()\n        if not case_type_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case type with name '{case_type_name}' exists.\"}}\n        case_type_id = case_type_result[0]\n\n        # Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_result = cursor.fetchone()\n        if not case_status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case status with name '{case_status_name}' exists.\"}}\n        case_status_id = case_status_result[0]\n\n        # Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_result = cursor.fetchone()\n        if not case_stage_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case stage with name '{case_stage_name}' exists.\"}}\n        case_stage_id = case_stage_result[0]\n\n        # Insert new case\n        if due_date:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n            )\n        else:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\") VALUES (?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id)\n            )\n        conn.commit()\n\n        # Retrieve the newly inserted case\n        case_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": case_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_assignment_completion(case_name: str, assignment_content: str, completion_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation for None values\n        if case_name is None or assignment_content is None or completion_date is None:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: None values not allowed'}}\n\n        # Validate completion_date format\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', completion_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'completion_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the provided name exists.'}}\n        case_id = case_row[0]\n\n        # Step 2: Find assignment_id\n        cursor.execute('SELECT \"assignment_id\" FROM \"case_assignments\" WHERE \"case_id\" = ? AND \"assignment_content\" = ?', \n                      (case_id, assignment_content))\n        assignment_row = cursor.fetchone()\n        if not assignment_row:\n            return {'status': 'failure', 'content': {'error': 'Assignment not found: No assignment with the provided content exists for this case.'}}\n        assignment_id = assignment_row[0]\n\n        # Step 4: Update assignment_due_date\n        cursor.execute('UPDATE \"case_assignments\" SET \"assignment_due_date\" = ? WHERE \"assignment_id\" = ?', \n                      (completion_date, assignment_id))\n        conn.commit()\n\n        # Step 5: Retrieve updated assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_assignment = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_appeal_proceeding(case_name: str, appeals_unit: str, appeal_date: str, appeal_due_date: str, new_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not appeals_unit or len(appeals_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeals_unit' must be non-empty and <= 100 characters.\"}}\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, appeal_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, appeal_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, new_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the provided name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve 'Appeal Granted' status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Appeal Granted',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal Granted' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve 'Appeal' stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Appeal',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, new_due_date, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                      (case_id, appeals_unit, appeal_date, \"Appeal proceeding initiated\", appeal_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n                      (case_id, \"Appeals Court\", \"Appeal filed\", \"In Progress\"))\n\n        conn.commit()\n\n        # Step 9: Retrieve updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef prepare_mediation_materials(case_name: str, mediation_unit: str, mediation_date: str, mediation_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not mediation_unit or len(mediation_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get mediation stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Mediation',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Mediation stage not found in database.\"}}\n        stage_id = stage_result[0]\n\n        # Step 5: Update case stage\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (stage_id, case_id))\n\n        # Step 6: Create new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, mediation_unit, mediation_date, 'Prepare mediation materials', mediation_due_date)\n        )\n\n        # Step 7: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_status(case_status_name: str, new_case_status_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be non-empty and not exceed 50 characters.\"}}\n        if not new_case_status_name or len(new_case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_case_status_name' must be non-empty and not exceed 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case_status_name exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        existing_status = cursor.fetchone()\n        if not existing_status:\n            return {'status': 'failure', 'content': {'error': \"Not Found: The specified case status does not exist.\"}}\n\n        # Update the case status name\n        cursor.execute('UPDATE \"case_statuses\" SET \"case_status_name\" = ? WHERE \"case_status_name\" = ?', \n                      (new_case_status_name, case_status_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_case_status_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef escalate_complaint_to_case(complaint_id: int, case_name: str, case_type_name: str, case_status_name: str, case_stage_name: str, due_date: str, assignments: List[Dict[str, str]], parties: List[Dict[str, str]]) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input parameter validation for None\n        if None in [complaint_id, case_name, case_type_name, case_status_name, case_stage_name, due_date, assignments, parties]:\n            return {'status': 'failure', 'content': {'error': 'All parameters must be provided (None not allowed)'}}\n        \n        # Validate string lengths\n        if len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' exceeds 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' exceeds 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' exceeds 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' exceeds 50 characters.\"}}\n        \n        # Validate due_date format\n        try:\n            datetime.strptime(due_date, '%Y-%m-%d')\n        except ValueError:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate assignments\n        for assignment in assignments:\n            if not all(key in assignment for key in ['assignment_unit', 'assignment_content', 'assignment_due_date']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each assignment must contain 'assignment_unit', 'assignment_content', and 'assignment_due_date'.\"}}\n            if len(assignment['assignment_unit']) > 100:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_unit' exceeds 100 characters.\"}}\n            if len(assignment['assignment_content']) == 0:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_content' cannot be empty.\"}}\n            try:\n                datetime.strptime(assignment['assignment_due_date'], '%Y-%m-%d')\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate parties\n        for party in parties:\n            if not all(key in party for key in ['party_type', 'party_name']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each party must contain 'party_type' and 'party_name'.\"}}\n            if len(party['party_type']) > 20:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_type' exceeds 20 characters.\"}}\n            if len(party['party_name']) > 200:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_name' exceeds 200 characters.\"}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Check complaint exists and can be escalated\n        cursor.execute('SELECT \"handling_result\" FROM \"complaints\" WHERE \"complaint_id\" = ?', (complaint_id,))\n        complaint = cursor.fetchone()\n        if not complaint:\n            return {'status': 'failure', 'content': {'error': 'Complaint not found or cannot be escalated.'}}\n        \n        # Resolve foreign keys\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_id = cursor.fetchone()\n        if not case_type_id:\n            return {'status': 'failure', 'content': {'error': f\"Case type '{case_type_name}' not found.\"}}\n        case_type_id = case_type_id[0]\n        \n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_id = cursor.fetchone()\n        if not case_status_id:\n            return {'status': 'failure', 'content': {'error': f\"Case status '{case_status_name}' not found.\"}}\n        case_status_id = case_status_id[0]\n        \n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_id = cursor.fetchone()\n        if not case_stage_id:\n            return {'status': 'failure', 'content': {'error': f\"Case stage '{case_stage_name}' not found.\"}}\n        case_stage_id = case_stage_id[0]\n        \n        # Update complaint\n        cursor.execute('UPDATE \"complaints\" SET \"handling_result\" = ? WHERE \"complaint_id\" = ?', ('Case Opened', complaint_id))\n        \n        # Insert case\n        acceptance_date = datetime.now().strftime('%Y-%m-%d')\n        cursor.execute(\n            'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n        )\n        case_id = cursor.lastrowid\n        \n        # Insert assignments\n        for assignment in assignments:\n            cursor.execute(\n                'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                (case_id, assignment['assignment_unit'], acceptance_date, assignment['assignment_content'], assignment['assignment_due_date'])\n            )\n        \n        # Insert parties\n        for party in parties:\n            cursor.execute(\n                'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                (case_id, party['party_type'], party['party_name'])\n            )\n        \n        # Get the inserted case\n        cursor.execute(\n            'SELECT * FROM \"cases\" WHERE \"case_id\" = ?',\n            (case_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_plaintiff(case_name: str, old_plaintiff_name: str, new_plaintiff_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_name must be non-empty and <= 200 chars'}}\n        if not old_plaintiff_name or len(old_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: old_plaintiff_name must be non-empty and <= 200 chars'}}\n        if not new_plaintiff_name or len(new_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_plaintiff_name must be non-empty and <= 200 chars'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_row[0]\n\n        # Step 2: Verify old plaintiff exists\n        cursor.execute('SELECT \"party_id\" FROM \"case_parties\" WHERE \"case_id\" = ? AND \"party_type\" = ? AND \"party_name\" = ?', \n                      (case_id, 'Plaintiff', old_plaintiff_name))\n        plaintiff_row = cursor.fetchone()\n        if not plaintiff_row:\n            return {'status': 'failure', 'content': {'error': 'Plaintiff not found: The specified plaintiff does not exist in the case.'}}\n        party_id = plaintiff_row[0]\n\n        # Step 3: Delete old plaintiff\n        cursor.execute('DELETE FROM \"case_parties\" WHERE \"party_id\" = ?', (party_id,))\n\n        # Step 4: Insert new plaintiff\n        cursor.execute('INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                      (case_id, 'Plaintiff', new_plaintiff_name))\n        \n        # Step 5: Get newly added plaintiff\n        new_party_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?', (new_party_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        new_plaintiff = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': new_plaintiff}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_details(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(case_name) > 200 or not case_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with a maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100 or not case_type_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' must be a non-empty string with a maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50 or not case_status_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50 or not case_stage_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', acceptance_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format if provided.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_row[0]\n\n        # Step 2: Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_row = cursor.fetchone()\n        if not case_type_row:\n            return {'status': 'failure', 'content': {'error': \"Case type not found: No case type with the given name exists.\"}}\n        case_type_id = case_type_row[0]\n\n        # Step 3: Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_row = cursor.fetchone()\n        if not case_status_row:\n            return {'status': 'failure', 'content': {'error': \"Case status not found: No case status with the given name exists.\"}}\n        case_status_id = case_status_row[0]\n\n        # Step 4: Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_row = cursor.fetchone()\n        if not case_stage_row:\n            return {'status': 'failure', 'content': {'error': \"Case stage not found: No case stage with the given name exists.\"}}\n        case_stage_id = case_stage_row[0]\n\n        # Step 8: Update case\n        if due_date is not None:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, due_date, case_id))\n        else:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = NULL \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, case_id))\n        conn.commit()\n\n        # Step 9: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef record_verdict(case_name: str, court_name: str, verdict_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters'}}\n        if not court_name or len(court_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: court_name must be non-empty and <= 200 characters'}}\n        \n        # Validate verdict_date format\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', verdict_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'verdict_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Find proceeding_id\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = ?', \n                      (case_id, court_name))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Proceeding not found: No proceeding with the given case and court exists.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 3: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = ? WHERE \"proceeding_id\" = ?', \n                      ('Verdicted', proceeding_id))\n        conn.commit()\n\n        # Step 4: Retrieve updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_case_due_to_new_evidence(case_name: str, evidence_review_unit: str, review_assignment_date: str, review_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters.'}}\n        if not evidence_review_unit or len(evidence_review_unit) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_review_unit must be non-empty and <= 100 characters.'}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_description must be non-empty.'}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(review_assignment_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_assignment_date must be in YYYY-MM-DD format.'}}\n        if not date_pattern.match(review_due_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_due_date must be in YYYY-MM-DD format.'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get Reopened status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': 'Database error: Reopened status not found.'}}\n        status_id = status_result[0]\n\n        # Step 5: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n\n        # Step 6: Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_review_unit, review_assignment_date, evidence_description, review_due_date)\n        )\n        assignment_id = cursor.lastrowid\n\n        # Step 7: Get the inserted assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        assignment = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_complaint_details(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(complaint_source) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_source' exceeds 50 characters.\"}}\n        if len(handling_unit) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_unit' exceeds 100 characters.\"}}\n        if len(handling_result) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_result' exceeds 50 characters.\"}}\n        if len(complaint_category) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_category' exceeds 50 characters.\"}}\n        \n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        \n        if not complaint_content:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_content' must not be empty.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if complaint exists\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        existing = cursor.fetchone()\n        if not existing:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"No complaint found with the given time and content.\"}}\n\n        # Update complaint\n        cursor.execute(\n            '''UPDATE \"complaints\" \n            SET \"complaint_source\" = ?, \"handling_unit\" = ?, \"handling_result\" = ?, \"complaint_category\" = ?\n            WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?''',\n            (complaint_source, handling_unit, handling_result, complaint_category, complaint_time, complaint_content)\n        )\n        conn.commit()\n\n        # Get updated record\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        updated_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": updated_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_status(case_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_status_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_status_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_statuses` table. The `case_status_id` is handled by the database. The `case_status_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case status.\n\n    3. **Error Handling**:\n        - If `case_status_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case status record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case status\n        cursor.execute(\n            'INSERT INTO \"case_statuses\" (\"case_status_name\") VALUES (?)',\n            (case_status_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_statuses\" WHERE \"case_status_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef settle_case(case_name: str, settlement_unit: str, settlement_date: str, settlement_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not settlement_unit or len(settlement_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get settled status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Settled',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Settled' status not found in case_statuses table.\"}}\n        settled_status_id = status_result[0]\n\n        # Step 3: Get closed stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found in case_stages table.\"}}\n        closed_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (settled_status_id, closed_stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0]\n        new_assignment_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                      (new_assignment_id, case_id, settlement_unit, settlement_date, 'Settlement documentation', settlement_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('SELECT MAX(\"proceeding_id\") FROM \"case_proceedings\"')\n        max_id = cursor.fetchone()[0]\n        new_proceeding_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?, ?)',\n                      (new_proceeding_id, case_id, 'Settlement Conference', 'Case settled', 'Completed'))\n\n        conn.commit()\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Database error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Unexpected error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_expert_witness(case_name: str, expert_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not expert_name or len(expert_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'expert_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new expert witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', expert_name)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef consolidate_duplicate_case_type(duplicate_name: str, original_id: int) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not duplicate_name or len(duplicate_name) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid duplicate_name'}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Verify original_id exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Original case type ID not found.'}}\n        \n        # Step 2: Verify duplicate_name exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        duplicate_row = cursor.fetchone()\n        if not duplicate_row:\n            return {'status': 'failure', 'content': {'error': 'Duplicate case type name not found.'}}\n        duplicate_id = duplicate_row[0]\n        \n        # Step 3: Update cases table\n        cursor.execute('UPDATE \"cases\" SET \"case_type_id\" = ? WHERE \"case_type_id\" = ?', (original_id, duplicate_id))\n        \n        # Step 4: Delete duplicate from case_types\n        cursor.execute('DELETE FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        \n        # Step 5: Get updated original record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_for_dna_evidence(case_name: str, forensics_unit: str, assignment_date: str, due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200.\"}}\n        if not forensics_unit or len(forensics_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'forensics_unit' must be a non-empty string with maximum length of 100.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve Reopened status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Reopened' status not found in case_statuses.\"}}\n        reopened_status_id = status_result[0]\n\n        # Step 3: Resolve Discovery stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Discovery',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Discovery' stage not found in case_stages.\"}}\n        discovery_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute(\n            'UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?',\n            (reopened_status_id, discovery_stage_id, case_id)\n        )\n\n        # Step 7: Insert into case_assignments\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, forensics_unit, assignment_date, \"DNA evidence review\", due_date)\n        )\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute(\n            'INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n            (case_id, \"Forensic Review\", \"DNA evidence re-examination\", \"In Progress\")\n        )\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_stage(case_stage_name: str, new_case_stage_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_stage_name must be non-empty and <= 50 characters'}}\n        if not new_case_stage_name or len(new_case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_case_stage_name must be non-empty and <= 50 characters'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if old case stage exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Case stage not found: The specified case stage does not exist.'}}\n\n        # Check if new case stage already exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        if cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Duplicate entry: A case stage with the new name already exists.'}}\n\n        # Update the case stage name\n        cursor.execute('UPDATE \"case_stages\" SET \"case_stage_name\" = ? WHERE \"case_stage_name\" = ?', \n                      (new_case_stage_name, case_stage_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_field_investigation_case(case_name: str, case_type_name: str, acceptance_date: str, due_date: str, investigation_unit: str, investigation_date: str, investigation_due_date: str, investigation_content: str, plaintiff_name: str, defendant_name: str, witness_name: str, court_name: str, case_reason: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_type_name` must be a non-empty string with a maximum length of 100 characters.\n        - `acceptance_date` must be a string in 'YYYY-MM-DD' format.\n        - `due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_unit` must be a non-empty string with a maximum length of 100 characters.\n        - `investigation_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_content` must be a non-empty string.\n        - `plaintiff_name` must be a non-empty string with a maximum length of 200 characters.\n        - `defendant_name` must be a non-empty string with a maximum length of 200 characters.\n        - `witness_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_reason` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"}}`\n    \"\"\"\n    return {\n        \"status\": \"failure\",\n        \"content\": {\n            \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"\n        }\n    }\n\ndef advance_case_stage(case_name: str, new_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to resolve the provided `case_name` to a case ID.\n        - 2. Execute a `SELECT case_stage_id FROM case_stages WHERE case_stage_name = ?` to resolve the provided `new_stage_name` to a stage ID.\n        - 3. If either query returns no results, abort with a \"not found\" error.\n        - 4. Execute an `UPDATE cases SET case_stage_id = ? WHERE case_id = ?` to update the case's stage.\n        - 5. Execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete, updated case record.\n\n    3. **Error Handling**:\n        - If the `case_name` does not correspond to an existing case, return a failure object with a 'case not found' error.\n        - If the `new_stage_name` does not correspond to an existing stage, return a failure object with a 'stage not found' error.\n        - If a database error occurs during the update, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case exists with the provided name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Stage not found: No stage exists with the provided name.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get case_stage_id from new_stage_name\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_stage_name,))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': 'Stage not found: No stage exists with the provided name.'}}\n        new_stage_id = stage_result[0]\n\n        # Step 4: Update case_stage_id\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (new_stage_id, case_id))\n        conn.commit()\n\n        # Step 5: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_type(case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Invalid input: 'case_type_name' exceeds 100 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        cursor.execute(\n            'SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?',\n            (case_type_name,)\n        )\n        if cursor.fetchone() is not None:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Duplicate entry: A case type with this name already exists.\"\n                }\n            }\n\n        cursor.execute(\n            'INSERT INTO \"case_types\" (\"case_type_name\") VALUES (?)',\n            (case_type_name,)\n        )\n        conn.commit()\n\n        cursor.execute(\n            'SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"A database error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_settlement_proceeding(case_name: str, court_name: str, settlement_date: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `settlement_date` must be a string in 'YYYY-MM-DD' format.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the column 'case_reason' and 'progress_status'.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"}}`\n    \"\"\"\n    try:\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"\n            }\n        }\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_settlement_proceeding': {e}\", file=sys.stderr)\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": f\"An unexpected error occurred: {e}\"\n            }\n        }\n\ndef close_case(case_name: str, closure_unit: str, closure_date: str, closure_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not closure_unit or len(closure_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve case_status_id for 'Closed'\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Closed',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve case_stage_id for 'Closed'\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        # First get max assignment_id\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0] or 0\n        new_id = max_id + 1\n\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (new_id, case_id, closure_unit, closure_date, 'Case closure documentation', closure_due_date)\n        )\n\n        # Step 8: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_witness_to_case(case_name: str, witness_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not witness_name or len(witness_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'witness_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', witness_name)\n        )\n        conn.commit()\n\n        # Get the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_case_status(case_name: str, new_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to verify that a case with the given `case_name` exists.\n        - 2. Execute a `SELECT case_status_id FROM case_statuses WHERE case_status_name = ?` to resolve the provided `new_status_name` to its corresponding foreign key value.\n        - 3. If both the case and status are found, execute an `UPDATE cases SET case_status_id = ? WHERE case_id = ?` statement to update the case's status.\n        - 4. On successful update, execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete record of the updated case.\n\n    3. **Error Handling**:\n        - If no case with the given `case_name` is found, return a failure object with a 'not found' error.\n        - If no status with the given `new_status_name` is found, return a failure object with a 'not found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}`.\n    \"\"\"\n    if not case_name or not new_status_name:\n        return {\"status\": \"failure\", \"content\": {\"error\": \"Case name and new status name must not be empty.\"}}\n    \n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n        \n        # Step 2: Check if status exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_status_name,))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}\n        status_id = status_result[0]\n        \n        # Step 3: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n        \n        # Step 4: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {\"status\": \"success\", \"content\": updated_case}\n        \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef complete_supreme_court_proceeding(case_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to retrieve the case ID for the given `case_name`.\n        - 2. If no case is found with the given name, raise a \"Not Found\" error.\n        - 3. Execute a `SELECT proceeding_id FROM case_proceedings WHERE case_id = ? AND court_name = 'Supreme Court'` to retrieve the Supreme Court proceeding for the case.\n        - 4. If no Supreme Court proceeding is found for the case, raise a \"Not Found\" error.\n        - 5. Execute an `UPDATE case_proceedings SET progress_status = 'Completed' WHERE proceeding_id = ?` to mark the Supreme Court proceeding as completed.\n        - 6. Execute a `SELECT * FROM case_proceedings WHERE proceeding_id = ?` to retrieve the updated proceeding record.\n\n    3. **Error Handling**:\n        - If no case is found with the given `case_name`, return a failure object with a 'Not Found' error.\n        - If no Supreme Court proceeding is found for the case, return a failure object with a 'Not Found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated proceeding record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No case found with the given name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No Supreme Court proceeding found for the case.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid case_name parameter'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No case found with the given name.'}}\n        case_id = case_result[0]\n\n        # Step 3: Get Supreme Court proceeding\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = \"Supreme Court\"', (case_id,))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No Supreme Court proceeding found for the case.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 5: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = \"Completed\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        conn.commit()\n\n        # Step 6: Get updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_evidence_review_assignment(case_name: str, evidence_unit: str, assignment_date: str, assignment_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not evidence_unit or len(evidence_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_description' must be a non-empty string.\"}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not date_pattern.match(assignment_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name '{case_name}' exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_unit, assignment_date, evidence_description, assignment_due_date)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        assignment_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_stage(case_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_stage_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_stage_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_stages` table. The `case_stage_id` is handled by the database. The `case_stage_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case stage.\n\n    3. **Error Handling**:\n        - If `case_stage_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case stage record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case stage\n        cursor.execute(\n            'INSERT INTO \"case_stages\" (\"case_stage_name\") VALUES (?)',\n            (case_stage_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_stages\" WHERE \"case_stage_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_complaint(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input parameters\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        if len(complaint_source) > 50 or not complaint_source:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_source' must be a non-empty string with maximum length of 50 characters.\"}}\n        if not complaint_content:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_content' must be a non-empty string.\"}}\n        if len(handling_unit) > 100 or not handling_unit:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if len(handling_result) > 50 or not handling_result:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_result' must be a non-empty string with maximum length of 50 characters.\"}}\n        if len(complaint_category) > 50 or not complaint_category:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_category' must be a non-empty string with maximum length of 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Insert the complaint\n        cursor.execute(\n            'INSERT INTO \"complaints\" (\"complaint_time\", \"complaint_source\", \"complaint_content\", \"handling_unit\", \"handling_result\", \"complaint_category\") VALUES (?, ?, ?, ?, ?, ?)',\n            (complaint_time, complaint_source, complaint_content, handling_unit, handling_result, complaint_category)\n        )\n        conn.commit()\n        \n        # Retrieve the newly inserted complaint\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        \n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_type(case_type_name: str, new_case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n        if not new_case_type_name or len(new_case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'new_case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case type exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        if not cursor.fetchone():\n            return {\n                'status': 'failure',\n                'content': {'error': \"Not Found: No case type with the given name exists.\"}\n            }\n\n        # Update case type name\n        cursor.execute(\n            'UPDATE \"case_types\" SET \"case_type_name\" = ? WHERE \"case_type_name\" = ?',\n            (new_case_type_name, case_type_name)\n        )\n        conn.commit()\n\n        # Retrieve updated record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_name\" = ?', (new_case_type_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()", "origin_sqlite_path": "/mnt/cfs_bj_mt/zengyucheng/workdir/workdir_for_tool_use/spider_op_meta_data_v3/stage_0_format_meta_data/nl2sql_0813/stage_0_sqlite_list/legal_case_management.sqlite", "target_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 51}, {"name": "case_parties", "seq": 94}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1001, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1006, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1007, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1002, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1002, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}, {"assignment_id": 51, "case_id": 1072, "assignment_unit": "Evidence Review", "assignment_date": "2025-07-25", "assignment_content": "Review new evidence submitted for case reopening", "assignment_due_date": "2025-08-10"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}, {"party_id": 94, "case_id": 1072, "party_type": "Witness", "party_name": "David Chen"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "origin_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 50}, {"name": "case_parties", "seq": 93}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1001, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1006, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1004, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1002, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1002, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "diff_between_databases": 13, "status": "STOP"}
{"db_id": "legal_case_management", "task_id": "legal_case_management@85@0", "task_meta": {"business_scenario": "From the perspective of legal records management, three completed cases were selected for archiving as part of routine records maintenance. The cases \"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", and \"Butler-Mcbride v. Thomas Inc\" were transitioned to \"Archived\" status while preserving all related case information.", "event_breakdown": "- The case **\"Kim-Diaz v. Wheeler and Sons\"**, previously in \"Dismissed\" status, was archived along with its 1 assignment, 5 parties, and 1 proceeding record.\n  - The case **\"Marshall-Wright v. Gonzalez Ltd\"**, previously in \"Closed\" status, was archived along with its 1 assignment and 2 parties.\n  - The case **\"Butler-Mcbride v. Thomas Inc\"**, previously in \"Closed\" status, was archived along with its 2 assignments, 2 parties, and 1 proceeding record.", "task_description": "- For the 'cases' record identified by 'case_name' \"Kim-Diaz v. Wheeler and Sons\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Marshall-Wright v. Gonzalez Ltd\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Butler-Mcbride v. Thomas Inc\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".", "new_entity_info_card": {"cases": [{"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1008, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1008, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1008, "case_stage_id": 1007, "due_date": "2025-09-09"}]}, "input_task": "<BUSINESS_LOGIC>\nFrom the perspective of legal records management, three completed cases were selected for archiving as part of routine records maintenance. The cases \"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", and \"Butler-Mcbride v. Thomas Inc\" were transitioned to \"Archived\" status while preserving all related case information.\n- The case **\"Kim-Diaz v. Wheeler and Sons\"**, previously in \"Dismissed\" status, was archived along with its 1 assignment, 5 parties, and 1 proceeding record.\n  - The case **\"Marshall-Wright v. Gonzalez Ltd\"**, previously in \"Closed\" status, was archived along with its 1 assignment and 2 parties.\n  - The case **\"Butler-Mcbride v. Thomas Inc\"**, previously in \"Closed\" status, was archived along with its 2 assignments, 2 parties, and 1 proceeding record.\n</BUSINESS_LOGIC>\n\n<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"Kim-Diaz v. Wheeler and Sons\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Marshall-Wright v. Gonzalez Ltd\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Butler-Mcbride v. Thomas Inc\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"cases\": [\n        {\n            \"case_id\": 1069,\n            \"case_name\": \"Kim-Diaz v. Wheeler and Sons\",\n            \"case_type_id\": 1013,\n            \"acceptance_date\": \"2024-09-30\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1019,\n            \"due_date\": \"2025-12-15\"\n        },\n        {\n            \"case_id\": 1076,\n            \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\",\n            \"case_type_id\": 1018,\n            \"acceptance_date\": \"2024-05-05\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1017,\n            \"due_date\": \"2024-11-29\"\n        },\n        {\n            \"case_id\": 1077,\n            \"case_name\": \"Butler-Mcbride v. Thomas Inc\",\n            \"case_type_id\": 1015,\n            \"acceptance_date\": \"2025-03-23\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1007,\n            \"due_date\": \"2025-09-09\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, "react_llm_system_prompt": "**Role and Goal:**\n\nYou are a powerful and capable AI assistant. Your primary objective is to fulfill user requests accurately and efficiently. To achieve this, you must fully leverage your available tools to gather necessary information *before* executing any actions, in accordance with your Prime Directive.\n\n**Operational Context:**\n\nBefore determining your next action, you **must** first observe and synthesize information from three primary sources:\n1.  **`<BUSINESS_LOGIC>`**: A series of natural language descriptions detailing common business operations and user stories. These narratives describe the real-world tasks.\n2.  **`<TASK_DESCRIPTION>`**: The primary objective and a description of the user's goal.\n3.  **`<TASK_PAYLOAD>`**: Structured data containing the specific parameters required to execute the actions described in the task. **Crucially, `<TASK_PAYLOAD>` is NOT a representation of the current system state; it is the input for your actions.**\n4.  **`History Messages`**: The record of previous interactions and tool calls in the current session.\n\n**Core Principles:**\n\n1.  **Query First, Act Second (The Unbreakable Rule):** To reiterate your Prime Directive: Before performing **any** action that creates, updates, or deletes data (using the parameters from `<TASK_PAYLOAD>`), you **MUST** first use your query tools to verify the current, real-time state of the system. This step is your most critical safeguard against errors, data corruption, and acting on outdated information.\n\n2.  **Data Fidelity:** When calling tools, you **must** use information exactly as it is provided in the `<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>` or `<TASK_PAYLOAD>`. **Do not alter, reformat, or reinterpret the data.** For example, if the payload provides a date as `2025-03-01`, you must use `2025-03-01` in your tool parameters, not `1st Mar., 2025`.\n\n3.  **Deconstruct Complex Requests:** Break down multi-step user requests into a series of smaller, manageable sub-tasks. For each sub-task, determine if you need to query for information before acting, guided by the principles above.\n\n4.  **Prioritize System Information Gathering:** When you receive a request, your first step is to identify what information you need to complete it successfully. Use your **query tools** to gather this data proactively from the system.\n\n5.  **Verify All Entities:** Never assume an entity (e.g., a user, a file, a project) described in the `<TASK_PAYLOAD>` already exists. Always query to confirm its existence and retrieve its unique identifier before attempting to link it to another entity or modify it.\n\n6.  **Create Missing Entities and Proceed**: If a query confirms that an entity from the `<TASK_PAYLOAD>` does not exist, you **must** first call the appropriate tool to create that entity. Once created, you can proceed with the remaining parts of the original request.\n\n**Core Mandate: Autonomous Execution**\n\n*   **No User Dialogue:** You **must not** solicit additional information, clarifications, or operational confirmations from the user. Assume all necessary information has been provided in the initial context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`, `History Messages`).\n*   **Infer and Proceed:** In cases of ambiguity or missing parameters, you must infer the most logical values, apply sensible defaults, or deduce the correct course of action from the context to ensure task completion without user intervention.\n*   **Mandatory Execution:** Upon successful internal verification, **you are to proceed with the execution of the task immediately.** The action is mandated and does not require a final user approval step.\n\n**Problem Solving and Progression:**\n\n*   **Never Default to Refusal Without Reasoning:** If you encounter a request that appears unsupported or constrained, **do not default to refusal**. Instead, analyze the request, internally determine the most logical path forward, and execute it. Your function is to complete the task through autonomous reasoning and reformulation.\n\n**Summary:**\n\nYour fundamental workflow is immutable and starts with a query: **Observe Context (`<BUSINESS_LOGIC>`, `<TASK_DESCRIPTION>`, `<TASK_PAYLOAD>`) → QUERY (Mandatory) → Verify → EXECUTE**. Be methodical and diligent. By grounding every action in **queried and verified**, up-to-date information and maintaining strict data fidelity, you will function as a reliable and highly effective assistant, acting decisively and autonomously.\n", "interact_llm_system_prompt": "### **Role and Objective**\n\nYou are an autonomous and highly capable AI assistant. Your primary objective is to fulfill user requests accurately, efficiently, and autonomously. You will act decisively on verified information, but you **will seek confirmation for ambiguous interpretations or irreversible actions.**\n\n### **Core Directive: QUERY FIRST, ACT SECOND**\n\nThis is your immutable, non-negotiable rule. Before executing **ANY** action that creates, modifies, or deletes data (e.g., `create_user`, `update_file`, `delete_record`), you **MUST** first use the appropriate query tools (e.g., `get_user`, `find_file`) to retrieve the current, real-time state of the system. This directive prevents errors, ensures you are working with up-to-date information, and is the foundation of all your operations.\n\n### **Operational Workflow**\n\nFollow this sequential workflow for every user request.\n\n**Step 1: Deconstruct and Analyze**\n*   Break down the user's request into discrete, logical sub-tasks.\n*   For each sub-task, identify the necessary entities (e.g., users, files, projects) and the information required for completion.\n\n**Step 2: Query and Verify State**\n*   Proactively use your query tools to gather all required information identified in Step 1.\n*   Crucially, verify the existence and **current state** of **every entity** mentioned in the request. Never assume an entity exists. Always retrieve its unique identifier.\n\n**Step 3: Resolve, Clarify, or Inform**\nThis step determines your path forward based on the results of your query.\n\n*   **Case A: Entity Does Not Exist (Clear Prerequisite)**\n    *   If you have all the necessary information from the user's request to create a missing entity:\n        1.  **CREATE** the missing entity first.\n        2.  **PROCEED** with the original sub-task using the newly created entity.\n\n*   **Case B: Ambiguous or Insufficient Information**\n    *   If the user's request is ambiguous, or you lack critical information needed for an action (e.g., \"Add the new guy to the project\"):\n        1.  **ASK** the user for clarification. Do not invent data or make unsafe assumptions.\n\n*   **Case C: State Mismatch or Redundant Request**\n    *   If an entity exists but the requested action is redundant (e.g., asking to set a status that is already set) or invalid due to its current state:\n        1.  **INFORM** the user of the current state (e.g., \"User 'john.doe' is already a member of this project.\" or \"Ticket #541 is already marked 'In Progress'.\").\n        2.  **STOP** execution of that sub-task and await further instruction.\n\n**Step 4: Execute with Safeguards**\n*   Once all information is verified, all prerequisite entities are confirmed to exist (or have been created), and all ambiguities are resolved, proceed as follows:\n\n    *   **For Non-Destructive Actions** (e.g., creating, adding, updating):\n        1.  **Execute the action(s) immediately and decisively.**\n    *   **For Potentially Destructive Actions** (e.g., deleting, removing, overwriting):\n        1.  **State your intended action** and its consequences clearly to the user (e.g., \"I am about to permanently delete the user 'jane.doe' and all their associated data.\").\n        2.  **Ask for explicit confirmation** before proceeding.\n        3.  **EXECUTE** only after receiving that confirmation.\n\n### **Guiding Principles**\n\nThese principles apply throughout the entire workflow.\n\n*   **Data Fidelity:** When calling tools, you **MUST** use data exactly as it is provided in the context or returned by a previous tool call. Do not reformat or reinterpret values.\n*   **Prioritize User Intent:** Your goal is to solve problems, but not by making risky assumptions. If a request is blocked, favor clarifying the user's intent over autonomously taking a multi-step action that might be incorrect.\n    *   **Good Behavior:** \"User 'Jane Doe' is not a member of the 'Q4 Campaign' project. Should I add her first and then grant her admin rights?\"\n    *   **Bad Behavior:** (Silently adds Jane to the project and then promotes her, risking incorrect permissions if the user made a typo).\n\n### **Summary of Your Core Logic**\n\nYour fundamental process is: **Observe → Deconstruct → Query → Verify State → Resolve (Create, Clarify, or Inform) → Execute (with Confirmation for Destructive Actions).** By grounding every action in queried, real-time data and ensuring user intent is respected, you will function as a reliable and truly capable autonomous agent.\n", "interact_user_system_prompt": "## Role: User Simulator\n\nYou are a User Simulator. Your role is to interact with an AI agent by realistically role-playing a user based on the provided inputs. Your primary function is to test the agent's ability to guide a conversation, gather information effectively, and handle a methodical, step-by-step interaction.\n\n## 1. Simulation Inputs\n\nYour simulation is defined by three key inputs you will be given:\n\n1.  **`<USER_STORY>`**: The high-level narrative context explaining the **'why'** behind your goal. Use this for understanding your motivation but do not quote it directly.\n2.  **`<USER_GOAL>`**: A concise, single-sentence description of your immediate objective (the **'what'**). You will paraphrase this to start the conversation.\n3.  **`<TASK_DATA>`**: A structured data object (e.g., JSON) containing all the information you, as the user, possess.\n    *   This is your **'source of truth'**. All information you provide must come from this data.\n    *   It may include personal details (e.g., name, email), which you only provide if the agent explicitly asks for them.\n    *   **Crucially, this is NOT the system's current state; it is simply the information you have available to give.**\n\n## 2. Your Persona: The Patient & Methodical User\n\nYou will adopt the following persona throughout the interaction:\n\n*   **Cooperative but Concise**: You are helpful and will answer all questions, but you do not offer unsolicited information or engage in small talk.\n*   **Extremely Patient**: You are never frustrated or rushed. If the agent asks for the same information multiple times, you provide it again calmly. If the agent needs to clarify details or asks for confirmation (e.g., \"So that's 'John Doe', correct?\"), you respond and patiently wait for its next directive.\n*   **Follows Instructions Literally**: You follow the agent's lead precisely. You do not anticipate its needs or try to \"help\" by providing information before it is requested.\n\n## 3. Rules of Engagement\n\n### 3.1 Initiating the Conversation\n*   Paraphrase the `<USER_GOAL>` in a natural, single sentence to begin.\n*   **Do not** volunteer any other information from `<TASK_DATA>` in your opening message.\n\n### 3.2 Conversational Flow\n*   **Be Reactive, Not Proactive**: After your opening, **only** provide information when the agent explicitly asks for it. Let the agent lead the conversation.\n*   **One Topic at a Time (Crucial Rule)**: If the agent asks for multiple, distinct pieces of information at once (e.g., \"Can you give me the award details, the participant's name, and the institution's info?\"), you **must respond with information for only the *first* topic requested.**\n    *   *Example Response*: `Okay, for the award, the name is \"Platinum Innovation Prize\", the level is \"Platinum\", and the category is \"Technology\".`\n    *   Then, **stop and wait** for the agent to ask for the next piece of information. This rule is designed to test the agent's ability to handle multi-part questions in a structured way.\n*   **Provide Complete Answers (for a single topic)**: When you answer a question about a topic, provide all the relevant details for that single topic from `<TASK_DATA>`. For example, if asked for an \"address,\" provide the full street, city, and zip code.\n*   **Handle Missing Information**: If the agent asks for information not present in your `<TASK_DATA>`, state that you do not have it (e.g., `I don't have that information.`).\n\n### 3.3 Data Formatting\n*   **Use Quotes for Specific Values**: Any specific data value or identifier from `<TASK_DATA>` **must be enclosed in double quotes (\"\")**.\n*   **Ensure Exact Matches**: The value inside the quotes must be an *exact, character-for-character match* to the source data.\n    *   *Correct*: `\"2024-10-28\"`\n    *   *Incorrect*: `\"October 28th, 2024\"`\n*   **Clarify Ambiguity**: When a value could be ambiguous (e.g., the word \"Active\"), provide context.\n    *   *Example*: `Yes, my account status is \"Active\"`.\n\n## 4. Terminating the Simulation (`###STOP###`)\n\nTo end the simulation, you must use the termination command `###STOP###`. Generate this command **if and only if all three** of the following conditions are met:\n\n1.  **Information Provided**: You have answered all of the agent's questions, providing all the information it requested from `<TASK_DATA>` that is relevant to the `<USER_GOAL>`.\n\n2.  **Task Definitively Confirmed by Agent**: The agent has **explicitly and definitively** confirmed the task is complete (e.g., \"Your booking is confirmed,\" \"I have successfully scheduled the meeting for you\") **AND** has provided a final summary of the key details.\n    *   An intermediate clarification (e.g., `Okay, I have your name as \"John Doe\", is that correct?`) or a generic closing (e.g., `Is there anything else?`) is **NOT** a final confirmation. **Do not stop.** You must wait for a concluding statement that declares the task finished.\n\n3.  **Verification of Summary**: You have verified the agent's final summary against your `<TASK_DATA>`, and it is correct according to the following logic:\n    *   **Exact Match for User Data**: All descriptive details you provided (e.g., names, dates, addresses, options like `\"Standard\"` shipping) must be an exact match in the agent's summary.\n    *   **Ignore System-Generated IDs**: You **must ignore and accept** any new system-generated identifiers in the agent's summary (e.g., a `confirmation_id`, `ticket_number`, or `booking_ref`). These are not expected to match anything in your `<TASK_DATA>`.\n\n### **5. Required Output Format**\n\nYou **must** structure every response using the following tags.\n\n<THINK>\nPlace your internal reasoning here. Detail your thought process, explain which rule you are following, and note your current state in the simulation. This section is for analysis and is not sent to the AI agent.\n</THINK>\n<QUERY>\nPlace the user's actual response here. This is the only text the AI agent will see. If all termination conditions are met, this tag will contain only \"###STOP###\".\n</QUERY>\n\n**Example of a Standard Response:**\n<THINK>\nThe agent has asked for my full name and my date of birth. According to the \"One Topic at a Time\" rule, I must only provide the first piece of information: the full name. I will wait for the agent to ask for the date of birth separately.\n</THINK>\n<QUERY>\nMy full name is \"Jane Emily Doe\".\n</QUERY>\n\n**Example of a Termination Response:**\n\n<THINK>\nThe agent has confirmed the cancellation and provided a final summary. I have verified that all details in the summary match my TASK_DATA. The three conditions for termination have been met.\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>\n\nNow, based on the entire conversation history, please act STRICTLY as the human user and generate the next appropriate response...\n", "tool_system_prompt": null, "react_trajectory": {"llm_messages": [{"role": "user", "content": "<BUSINESS_LOGIC>\nFrom the perspective of legal records management, three completed cases were selected for archiving as part of routine records maintenance. The cases \"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", and \"Butler-Mcbride v. Thomas Inc\" were transitioned to \"Archived\" status while preserving all related case information.\n- The case **\"Kim-Diaz v. Wheeler and Sons\"**, previously in \"Dismissed\" status, was archived along with its 1 assignment, 5 parties, and 1 proceeding record.\n  - The case **\"Marshall-Wright v. Gonzalez Ltd\"**, previously in \"Closed\" status, was archived along with its 1 assignment and 2 parties.\n  - The case **\"Butler-Mcbride v. Thomas Inc\"**, previously in \"Closed\" status, was archived along with its 2 assignments, 2 parties, and 1 proceeding record.\n</BUSINESS_LOGIC>\n\n<TASK_DESCRIPTION>\n- For the 'cases' record identified by 'case_name' \"Kim-Diaz v. Wheeler and Sons\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Marshall-Wright v. Gonzalez Ltd\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n- For the 'cases' record identified by 'case_name' \"Butler-Mcbride v. Thomas Inc\", update the 'case_status_id' to the ID of the 'case_statuses' record where 'case_status_name' is \"Archived\".\n</TASK_DESCRIPTION>\n\n<TASK_PAYLOAD>\n{\n    \"cases\": [\n        {\n            \"case_id\": 1069,\n            \"case_name\": \"Kim-Diaz v. Wheeler and Sons\",\n            \"case_type_id\": 1013,\n            \"acceptance_date\": \"2024-09-30\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1019,\n            \"due_date\": \"2025-12-15\"\n        },\n        {\n            \"case_id\": 1076,\n            \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\",\n            \"case_type_id\": 1018,\n            \"acceptance_date\": \"2024-05-05\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1017,\n            \"due_date\": \"2024-11-29\"\n        },\n        {\n            \"case_id\": 1077,\n            \"case_name\": \"Butler-Mcbride v. Thomas Inc\",\n            \"case_type_id\": 1015,\n            \"acceptance_date\": \"2025-03-23\",\n            \"case_status_id\": 1008,\n            \"case_stage_id\": 1007,\n            \"due_date\": \"2025-09-09\"\n        }\n    ]\n}\n</TASK_PAYLOAD>"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "10c8f88000b64bb5840c96f994bd0202", "type": "function", "function": {"name": "query_case_statuses", "arguments": "{\"case_status_name\": {\"op\": \"=\", \"value\": \"Archived\"}}"}}, {"id": "a490242ac2df4edbbd95c619bad220b2", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"Kim-Diaz v. Wheeler and Sons\"}}"}}, {"id": "22e0eed04d84409ba34cc799f786a073", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"Marshall-Wright v. Gonzalez Ltd\"}}"}}, {"id": "41550a6257ac495698c740759d5a5d64", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"=\", \"value\": \"Butler-Mcbride v. Thomas Inc\"}}"}}]}, {"role": "tool", "tool_call_id": "10c8f88000b64bb5840c96f994bd0202", "name": "query_case_statuses", "content": "{\"status\": \"success\", \"content\": [{\"case_status_id\": 1008, \"case_status_name\": \"Archived\"}]}"}, {"role": "tool", "tool_call_id": "a490242ac2df4edbbd95c619bad220b2", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1069, \"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"case_type_id\": 1013, \"acceptance_date\": \"2024-09-30\", \"case_status_id\": 1006, \"case_stage_id\": 1019, \"due_date\": \"2025-12-15\"}]}"}, {"role": "tool", "tool_call_id": "22e0eed04d84409ba34cc799f786a073", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1076, \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-05-05\", \"case_status_id\": 1002, \"case_stage_id\": 1017, \"due_date\": \"2024-11-29\"}]}"}, {"role": "tool", "tool_call_id": "41550a6257ac495698c740759d5a5d64", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1077, \"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"case_type_id\": 1015, \"acceptance_date\": \"2025-03-23\", \"case_status_id\": 1002, \"case_stage_id\": 1007, \"due_date\": \"2025-09-09\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "a746a36cde7943bca73195332705fe76", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"new_status_name\": \"Archived\"}"}}, {"id": "216b8980156d4974a9a733150cdd652d", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"new_status_name\": \"Archived\"}"}}, {"id": "b15b97c34c37424f85bfd56f231097ba", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"new_status_name\": \"Archived\"}"}}]}, {"role": "tool", "tool_call_id": "a746a36cde7943bca73195332705fe76", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1069, \"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"case_type_id\": 1013, \"acceptance_date\": \"2024-09-30\", \"case_status_id\": 1008, \"case_stage_id\": 1019, \"due_date\": \"2025-12-15\"}}"}, {"role": "tool", "tool_call_id": "216b8980156d4974a9a733150cdd652d", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1076, \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-05-05\", \"case_status_id\": 1008, \"case_stage_id\": 1017, \"due_date\": \"2024-11-29\"}}"}, {"role": "tool", "tool_call_id": "b15b97c34c37424f85bfd56f231097ba", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1077, \"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"case_type_id\": 1015, \"acceptance_date\": \"2025-03-23\", \"case_status_id\": 1008, \"case_stage_id\": 1007, \"due_date\": \"2025-09-09\"}}"}, {"role": "assistant", "content": "The cases have been successfully updated to \"Archived\" status:\n\n1. **Kim-Diaz v. Wheeler and Sons**  \n   - Case ID: 1069  \n   - Previous Status: Dismissed  \n   - New Status: Archived  \n   - Acceptance Date: 2024-09-30  \n   - Due Date: 2025-12-15  \n\n2. **Marshall-Wright v. Gonzalez Ltd**  \n   - Case ID: 1076  \n   - Previous Status: Closed  \n   - New Status: Archived  \n   - Acceptance Date: 2024-05-05  \n   - Due Date: 2024-11-29  \n\n3. **Butler-Mcbride v. Thomas Inc**  \n   - Case ID: 1077  \n   - Previous Status: Closed  \n   - New Status: Archived  \n   - Acceptance Date: 2025-03-23  \n   - Due Date: 2025-09-09  \n\nAll related records (assignments, parties, and proceedings) remain preserved as part of the archival process."}], "user_messages": [], "tool_messages": []}, "interact_trajectory": {"llm_messages": [{"role": "user", "content": "I need to update the status of three legal cases to \"Archived\"."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "c1e6bf76852c429bafd7f02986b880b0", "type": "function", "function": {"name": "query_case_statuses", "arguments": "{\"case_status_name\":{\"op\":\"=\",\"value\":\"Archived\"},\"limit\":1}"}}]}, {"role": "tool", "tool_call_id": "c1e6bf76852c429bafd7f02986b880b0", "name": "query_case_statuses", "content": "{\"status\": \"success\", \"content\": [{\"case_status_id\": 1008, \"case_status_name\": \"Archived\"}]}"}, {"role": "assistant", "content": "To update the status of three legal cases to \"Archived,\" I first need to identify the cases you want to update. Could you provide the names or identifiers of the three cases? Alternatively, I can list some cases for you to choose from. Let me know how you'd like to proceed!"}, {"role": "user", "content": "The three cases are \"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", and \"Butler-Mcbride v. Thomas Inc\"."}, {"role": "assistant", "content": "", "tool_calls": [{"id": "5c8f39d4a6024425bce5351e1211ec24", "type": "function", "function": {"name": "query_cases", "arguments": "{\"case_name\": {\"op\": \"IN\", \"value\": [\"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", \"Butler-Mcbride v. Thomas Inc\"]}}"}}]}, {"role": "tool", "tool_call_id": "5c8f39d4a6024425bce5351e1211ec24", "name": "query_cases", "content": "{\"status\": \"success\", \"content\": [{\"case_id\": 1069, \"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"case_type_id\": 1013, \"acceptance_date\": \"2024-09-30\", \"case_status_id\": 1006, \"case_stage_id\": 1019, \"due_date\": \"2025-12-15\"}, {\"case_id\": 1076, \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-05-05\", \"case_status_id\": 1002, \"case_stage_id\": 1017, \"due_date\": \"2024-11-29\"}, {\"case_id\": 1077, \"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"case_type_id\": 1015, \"acceptance_date\": \"2025-03-23\", \"case_status_id\": 1002, \"case_stage_id\": 1007, \"due_date\": \"2025-09-09\"}]}"}, {"role": "assistant", "content": "", "tool_calls": [{"id": "244dd463acf74b46a415bf8d92b1e361", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"new_status_name\": \"Archived\"}"}}, {"id": "7489d3a2aa90484e8d33f95735174226", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"new_status_name\": \"Archived\"}"}}, {"id": "8426eeb760514fba8ebc65dcc2d74c41", "type": "function", "function": {"name": "update_case_status", "arguments": "{\"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"new_status_name\": \"Archived\"}"}}]}, {"role": "tool", "tool_call_id": "244dd463acf74b46a415bf8d92b1e361", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1069, \"case_name\": \"Kim-Diaz v. Wheeler and Sons\", \"case_type_id\": 1013, \"acceptance_date\": \"2024-09-30\", \"case_status_id\": 1008, \"case_stage_id\": 1019, \"due_date\": \"2025-12-15\"}}"}, {"role": "tool", "tool_call_id": "7489d3a2aa90484e8d33f95735174226", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1076, \"case_name\": \"Marshall-Wright v. Gonzalez Ltd\", \"case_type_id\": 1018, \"acceptance_date\": \"2024-05-05\", \"case_status_id\": 1008, \"case_stage_id\": 1017, \"due_date\": \"2024-11-29\"}}"}, {"role": "tool", "tool_call_id": "8426eeb760514fba8ebc65dcc2d74c41", "name": "update_case_status", "content": "{\"status\": \"success\", \"content\": {\"case_id\": 1077, \"case_name\": \"Butler-Mcbride v. Thomas Inc\", \"case_type_id\": 1015, \"acceptance_date\": \"2025-03-23\", \"case_status_id\": 1008, \"case_stage_id\": 1007, \"due_date\": \"2025-09-09\"}}"}, {"role": "assistant", "content": "All three cases have been successfully updated to the \"Archived\" status. Here's the confirmation:\n\n1. **Kim-Diaz v. Wheeler and Sons**  \n   - Case ID: 1069  \n   - New Status: Archived (Status ID: 1008)  \n\n2. **Marshall-Wright v. Gonzalez Ltd**  \n   - Case ID: 1076  \n   - New Status: Archived (Status ID: 1008)  \n\n3. **Butler-Mcbride v. Thomas Inc**  \n   - Case ID: 1077  \n   - New Status: Archived (Status ID: 1008)  \n\nLet me know if you'd like to verify any details or need further assistance!"}, {"role": "user", "content": "###STOP###"}], "user_messages": [{"role": "assistant", "content": "<THINK>\nThe agent has opened with a generic greeting. According to the rules, I should paraphrase the USER_GOAL to initiate the conversation without volunteering additional information from TASK_DATA.\n</THINK>\n<QUERY>\nI need to update the status of three legal cases to \"Archived\".\n</QUERY>"}, {"role": "user", "content": "To update the status of three legal cases to \"Archived,\" I first need to identify the cases you want to update. Could you provide the names or identifiers of the three cases? Alternatively, I can list some cases for you to choose from. Let me know how you'd like to proceed!"}, {"role": "assistant", "content": "<THINK>\nThe agent has asked for the names or identifiers of the three cases to be updated. According to the TASK_DATA, I have the exact case names available. Following the rules, I should provide all three case names since this is a single topic (identifying the cases). I'll quote the exact names from the data.\n</THINK>\n<QUERY>\nThe three cases are \"Kim-Diaz v. Wheeler and Sons\", \"Marshall-Wright v. Gonzalez Ltd\", and \"Butler-Mcbride v. Thomas Inc\".\n</QUERY>"}, {"role": "user", "content": "All three cases have been successfully updated to the \"Archived\" status. Here's the confirmation:\n\n1. **Kim-Diaz v. Wheeler and Sons**  \n   - Case ID: 1069  \n   - New Status: Archived (Status ID: 1008)  \n\n2. **Marshall-Wright v. Gonzalez Ltd**  \n   - Case ID: 1076  \n   - New Status: Archived (Status ID: 1008)  \n\n3. **Butler-Mcbride v. Thomas Inc**  \n   - Case ID: 1077  \n   - New Status: Archived (Status ID: 1008)  \n\nLet me know if you'd like to verify any details or need further assistance!"}, {"role": "assistant", "content": "<THINK>\nThe agent has provided a definitive confirmation that all three cases have been updated to \"Archived\" status. The summary includes all case names and IDs exactly as they appear in TASK_DATA, and the status update matches the USER_GOAL. All three termination conditions are met:\n1. All requested information has been provided\n2. The agent has definitively confirmed the task is complete\n3. The summary matches TASK_DATA exactly (ignoring system-generated status ID which is expected)\n</THINK>\n<QUERY>\n###STOP###\n</QUERY>"}], "tool_messages": []}, "tools_info": [{"type": "function", "function": {"name": "query_case_statuses_join_cases", "description": "Retrieves a filtered and sorted list of case statuses and their associated cases based on specified criteria. The function allows filtering on various attributes of both case statuses and cases, such as identifiers, names, dates, and types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines a case status with its related case details, including identifiers, names, dates, and other relevant attributes. If the operation fails, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_statuses_case_status_id": {"type": "object", "description": "Filter for the case status's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_statuses_case_status_name": {"type": "object", "description": "Filter for the case status's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'open')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort the results by, optionally specifying direction (e.g., 'cases_acceptance_date DESC', 'case_statuses_case_status_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases", "description": "Retrieves a list of cases based on specified filters, sorting, and pagination. The function allows filtering by various case attributes such as identifier, name, type, acceptance date, status, stage, and due date. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, it returns a dictionary with a 'success' status and a list of cases, each represented as a dictionary of their attributes. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_id": {"type": "object", "description": "Filter for the case's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_name": {"type": "object", "description": "Filter for the case's name. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "due_date": {"type": "object", "description": "Filter for the case's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format). Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"acceptance_date DESC\", \"case_name ASC\"]."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be >= 0."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be >= 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_assignments", "description": "Retrieves a filtered and sorted list of cases along with their associated assignments based on specified criteria. The function allows filtering by various case and assignment attributes, sorting the results, and paginating through them. Upon success, it returns a structured list of cases and their assignments, each represented as nested dictionaries. The response includes a status indicator and the retrieved data, ensuring clarity on the operation's outcome.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'NOT IN') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_assignments_assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. The filter must specify an operator (e.g., '=', 'IN') and a value (e.g., 1)."}, "case_assignments_case_id": {"type": "object", "description": "Filter for the assignment's case identifier. The filter must specify an operator (e.g., '=', '<>') and a value (e.g., 1061)."}, "case_assignments_assignment_unit": {"type": "object", "description": "Filter for the assignment's unit. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'defense')."}, "case_assignments_assignment_date": {"type": "object", "description": "Filter for the assignment's date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-05-01')."}, "case_assignments_assignment_content": {"type": "object", "description": "Filter for the assignment's content. The filter must specify an operator (e.g., 'LIKE', 'NOT LIKE') and a value (e.g., '%participant%')."}, "case_assignments_assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. The filter must specify an operator (e.g., '<=', '>') and a value in 'YYYY-MM-DD' format (e.g., '2024-11-01')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying the direction (e.g., ['cases_acceptance_date DESC', 'case_assignments_assignment_due_date ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types", "description": "Retrieves a list of case types based on specified filters, sorting, and pagination. The function allows filtering by case type identifier or name, with support for various comparison operators. Results can be sorted by one or more columns and paginated using limit and offset. Upon success, the function returns a dictionary with a 'success' status and a list of case types, each represented as a dictionary with their identifier and name. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"case_type_id": {"type": "object", "description": "Optional filter for the case type's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': '=', 'value': 1001}."}, "case_type_name": {"type": "object", "description": "Optional filter for the case type's name. The filter should be a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. For 'IN' and 'NOT IN', the value must be a list or tuple. Example: {'op': 'LIKE', 'value': '%case%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort the results by. Each item in the list should be a string in the format 'column_name ASC' or 'column_name DESC'. Example: [\"case_type_name ASC\", \"case_type_id DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results returned. Must be a non-negative value. Example: 10."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value. Example: 20."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_assignments", "description": "Retrieves a list of case assignments based on specified filters, sorting, and pagination. The function allows filtering by various assignment attributes such as identifier, case association, responsible unit, creation date, content, and due date. It supports sorting by any of these attributes and pagination through limit and offset parameters. Upon success, it returns a structured list of assignments, each detailing the assignment's attributes, or an error message if the operation fails.", "parameters": {"type": "object", "properties": {"assignment_id": {"type": "object", "description": "Filter for the assignment's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "assignment_unit": {"type": "object", "description": "Filter for the unit responsible for the assignment. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_date": {"type": "object", "description": "Filter for the assignment's creation date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "assignment_content": {"type": "object", "description": "Filter for the assignment's content. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "assignment_due_date": {"type": "object", "description": "Filter for the assignment's due date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., [\"assignment_date ASC\", \"assignment_due_date DESC\"]. Each entry must specify a column name followed by 'ASC' or 'DESC'.", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_proceedings", "description": "Retrieves information about legal proceedings based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as proceeding identifier, case identifier, court name, case reason, and progress status. Results can be sorted by one or more columns and paginated for large datasets. Upon success, it returns a structured list of proceedings, each containing details like the proceeding identifier, case identifier, court name, case reason, and progress status. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_id": {"type": "object", "description": "Filter for the associated case's identifier. Provide a dictionary with 'op' (operator) and 'value' (integer). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "court_name": {"type": "object", "description": "Filter for the name of the court handling the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "case_reason": {"type": "object", "description": "Filter for the reason or description of the case. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "progress_status": {"type": "object", "description": "Filter for the current status of the proceeding. Provide a dictionary with 'op' (operator) and 'value' (string). Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['court_name ASC', 'case_id DESC']. Each entry should specify a column name followed by an optional sort direction (ASC or DESC)."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_statuses", "description": "Retrieves a list of case statuses based on specified filters, sorting, and pagination. The function allows filtering by case status identifier or name using various comparison operators, sorting by one or more columns, and controlling the result set size and offset for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case status records, each containing the identifier and name of the case status. If an error occurs, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_id": {"type": "object", "description": "Optional filter for the case status's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "case_status_name": {"type": "object", "description": "Optional filter for the case status's name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators: '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, e.g., ['case_status_name ASC']. Columns must be one of 'case_status_id' or 'case_status_name', and direction must be 'ASC' or 'DESC'."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages_join_cases", "description": "Retrieves a filtered and sorted list of case stages and their associated cases based on specified criteria. The function supports filtering by various attributes of both case stages and cases, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list where each entry contains nested details of the case stage and its linked case, including identifiers, names, dates, and other relevant attributes. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_stages_case_stage_id": {"type": "object", "description": "Filter for the case stage's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_stages_case_stage_name": {"type": "object", "description": "Filter for the case stage's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'initial review')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'harper llc v. hernandez and sons')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "description": "List of fields to sort the results by, along with optional direction (e.g., ['cases_acceptance_date DESC', 'case_stages_case_stage_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_stages", "description": "Retrieves a list of case stages based on specified filters, sorting, and pagination options. The function allows filtering by case stage identifier or name using various comparison operators, sorting by one or more columns, and limiting the number of results for pagination. Upon success, it returns a dictionary with a 'success' status and a list of case stages, each represented as a dictionary with lowercase keys. In case of failure, it returns a 'failure' status with an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_stage_id": {"type": "object", "description": "Optional filter for the case stage's unique identifier. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be an integer or a list of integers for 'IN' and 'NOT IN' operators."}, "case_stage_name": {"type": "object", "description": "Optional filter for the case stage's name. Provide a dictionary with 'op' (operator) and 'value' keys. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'. The value must be a string or a list of strings for 'IN' and 'NOT IN' operators."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings in the format 'column_name ASC' or 'column_name DESC'. For example, [\"case_stage_id ASC\", \"case_stage_name DESC\"].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_types_join_cases", "description": "Retrieves a filtered and sorted list of case records along with their associated case types. The function allows filtering on various attributes of both cases and case types, such as identifiers, names, dates, and statuses. Results can be sorted and paginated. Upon success, it returns a structured list of joined records, each containing detailed information about the case and its corresponding case type. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"case_types_case_type_id": {"type": "object", "description": "Filter for the case type's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1001)."}, "case_types_case_type_name": {"type": "object", "description": "Filter for the case type's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%unit%')."}, "cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of fields to sort the results by, along with optional direction (e.g., 'cases_acceptance_date DESC', 'case_types_case_type_name ASC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_case_parties", "description": "Retrieves information about parties involved in legal cases based on flexible filtering criteria. The function allows for dynamic filtering by party identifier, case identifier, party type, or party name, as well as sorting and pagination of results. Upon success, it returns a structured list of party details, each including identifiers, case associations, and party attributes. If unsuccessful, it provides an error message explaining the issue.", "parameters": {"type": "object", "properties": {"party_id": {"type": "object", "description": "Optional filter for the party's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1}."}, "case_id": {"type": "object", "description": "Optional filter for the associated case's unique identifier. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 1061}."}, "party_type": {"type": "object", "description": "Optional filter for the type of party (e.g., plaintiff, defendant). The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': '=', 'value': 'plaintiff'}."}, "party_name": {"type": "object", "description": "Optional filter for the name of the party. The filter should be a dictionary with 'op' (operator) and 'value' keys. Example: {'op': 'LIKE', 'value': '%david%'}."}, "order_by": {"type": "array", "description": "Optional list of columns to sort by, specified as strings. Example: [\"party_type ASC\", \"party_name DESC\"]."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be a non-negative value."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be a non-negative value."}}, "required": []}}}, {"type": "function", "function": {"name": "query_complaints", "description": "Retrieves a list of complaints based on specified filters, sorting, and pagination. The function allows filtering by various attributes such as complaint identifier, time, source, content, handling unit, result, and category. Sorting and pagination options are also supported. Upon success, it returns a structured list of complaints, each containing details like identifier, time, source, content, handling unit, result, and category. If an error occurs, it returns an error message indicating the issue.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "object", "description": "Filter for the complaint's unique identifier. Provide a dictionary with 'op' (operator) and 'value' (integer)."}, "complaint_time": {"type": "object", "description": "Filter for the complaint's date. Provide a dictionary with 'op' (operator) and 'value' (string in 'YYYY-MM-DD' format)."}, "complaint_source": {"type": "object", "description": "Filter for the source of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_content": {"type": "object", "description": "Filter for the content of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_unit": {"type": "object", "description": "Filter for the unit handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "handling_result": {"type": "object", "description": "Filter for the result of handling the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "complaint_category": {"type": "object", "description": "Filter for the category of the complaint. Provide a dictionary with 'op' (operator) and 'value' (string)."}, "order_by": {"type": "array", "description": "List of columns to sort by, e.g., ['complaint_time DESC', 'complaint_id ASC'].", "items": {"type": "string"}}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_sqlite_sequence", "description": "Retrieves sequence information with optional filtering, sorting, and pagination. The function allows specifying conditions for the table name and sequence value, sorting the results by specified columns, and controlling the number of results returned. Upon success, it returns a dictionary with a 'success' status and a list of sequence records, each containing the table name and its corresponding sequence value. If an error occurs, it returns a 'failure' status with an error message.", "parameters": {"type": "object", "properties": {"name": {"type": "object", "description": "Optional filter for the table name. Provide a dictionary with 'op' (operator) and 'value' (string) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "seq": {"type": "object", "description": "Optional filter for the sequence value. Provide a dictionary with 'op' (operator) and 'value' (integer) to apply a condition. Supported operators include '=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', and 'NOT IN'."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "Optional list of columns to sort by, e.g., ['seq DESC', 'name ASC']."}, "limit": {"type": "integer", "description": "Optional integer to limit the number of results. Must be greater than or equal to 0."}, "offset": {"type": "integer", "description": "Optional integer to offset the results for pagination. Must be greater than or equal to 0."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_proceedings", "description": "Retrieves a list of legal cases along with their associated proceedings, allowing for flexible filtering and sorting. The function supports filtering on various attributes of both cases and proceedings, such as case identifiers, names, dates, and statuses. Results can be ordered and paginated. Upon success, it returns a structured list of cases and their linked proceedings, each containing relevant details like case names, acceptance dates, court names, and progress statuses. If an error occurs, it provides a failure status with an error message.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. Example: {'op': '=', 'value': 1061}."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. Example: {'op': 'LIKE', 'value': '%v.%'}."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. Example: {'op': '=', 'value': 1014}."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. Example: {'op': '>=', 'value': '2024-01-01'}."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. Example: {'op': '=', 'value': 1010}."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. Example: {'op': '=', 'value': 1005}."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. Example: {'op': '<=', 'value': '2024-12-31'}."}, "case_proceedings_proceeding_id": {"type": "object", "description": "Filter for the proceeding's unique identifier. Example: {'op': '=', 'value': 1}."}, "case_proceedings_case_id": {"type": "object", "description": "Filter for the proceeding's case identifier. Example: {'op': '=', 'value': 1062}."}, "case_proceedings_court_name": {"type": "object", "description": "Filter for the proceeding's court name. Example: {'op': 'LIKE', 'value': '%supreme%'}."}, "case_proceedings_case_reason": {"type": "object", "description": "Filter for the proceeding's case reason. Example: {'op': '=', 'value': 'economic whatever expect drop find.'}."}, "case_proceedings_progress_status": {"type": "object", "description": "Filter for the proceeding's progress status. Example: {'op': '=', 'value': 'appealed'}."}, "order_by": {"type": "array", "items": {"type": "string"}, "description": "List of columns to sort by, optionally specifying direction (e.g., 'cases_acceptance_date DESC')."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "query_cases_join_case_parties", "description": "Retrieves a filtered and sorted list of legal cases along with their associated parties, based on specified criteria. The function allows filtering by various case and party attributes, such as case identifiers, names, dates, and party types. Results can be sorted and paginated. Upon success, it returns a structured list where each entry combines case details with the corresponding party information, providing a comprehensive view of the case and its participants. The response includes a status indicator and the retrieved data, formatted for clarity and ease of use.", "parameters": {"type": "object", "properties": {"cases_case_id": {"type": "object", "description": "Filter for the case's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "cases_case_name": {"type": "object", "description": "Filter for the case's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%v.%')."}, "cases_case_type_id": {"type": "object", "description": "Filter for the case's type identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1014)."}, "cases_acceptance_date": {"type": "object", "description": "Filter for the case's acceptance date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-01-01')."}, "cases_case_status_id": {"type": "object", "description": "Filter for the case's status identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1010)."}, "cases_case_stage_id": {"type": "object", "description": "Filter for the case's stage identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1005)."}, "cases_due_date": {"type": "object", "description": "Filter for the case's due date. The filter must specify an operator (e.g., '>=', '<=') and a value in 'YYYY-MM-DD' format (e.g., '2024-12-31')."}, "case_parties_party_id": {"type": "object", "description": "Filter for the party's unique identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1)."}, "case_parties_case_id": {"type": "object", "description": "Filter for the party's associated case identifier. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 1061)."}, "case_parties_party_type": {"type": "object", "description": "Filter for the party's type (e.g., plaintiff, defendant). The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., 'plaintiff')."}, "case_parties_party_name": {"type": "object", "description": "Filter for the party's name. The filter must specify an operator (e.g., '=', 'LIKE') and a value (e.g., '%david%')."}, "order_by": {"type": "array", "description": "List of columns to sort the results by, optionally specifying direction (e.g., ['cases_acceptance_date DESC', 'case_parties_party_name ASC'])."}, "limit": {"type": "integer", "description": "Maximum number of results to return. Must be a non-negative integer."}, "offset": {"type": "integer", "description": "Number of results to skip for pagination. Must be a non-negative integer."}}, "required": []}}}, {"type": "function", "function": {"name": "create_case", "description": "Registers a new case in the system with the provided details, including case name, type, status, stage, and acceptance date. Optionally, a due date can be specified. The function validates all inputs for correctness and ensures the case type, status, and stage exist in the system. Upon successful creation, it returns the complete details of the newly registered case, including its unique identifier and all associated attributes. If any validation fails or required references are missing, an error is returned with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date when the case was accepted, must be in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The status of the case, must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The stage of the case, must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, must be in 'YYYY-MM-DD' format if provided."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "update_assignment_completion", "description": "Updates the completion date of a specific assignment for a given case. Validates the input data to ensure the case and assignment exist, and the completion date is in the correct format. On success, returns the updated assignment details along with a success status. On failure, returns an error message indicating the reason for the failure, such as invalid input, case not found, or assignment not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the assignment belongs. Must be a non-empty string with a maximum length of 200 characters."}, "assignment_content": {"type": "string", "description": "The content of the assignment to be updated. Must be a non-empty string."}, "completion_date": {"type": "string", "description": "The new completion date for the assignment, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "assignment_content", "completion_date"]}}}, {"type": "function", "function": {"name": "create_appeal_proceeding", "description": "Initiates an appeal proceeding for a specified case, updating its status and stage to reflect the appeal process. Validates input parameters for correctness and ensures the case exists before proceeding. On success, returns the updated case details including its new status and stage, confirming the appeal has been formally registered. If the case does not exist or inputs are invalid, returns an error with specific details.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the appeal is being initiated. Must be a non-empty string with a maximum length of 200 characters."}, "appeals_unit": {"type": "string", "description": "The unit responsible for handling the appeal. Must be a non-empty string with a maximum length of 100 characters."}, "appeal_date": {"type": "string", "description": "The date when the appeal is initiated, formatted as 'YYYY-MM-DD'."}, "appeal_due_date": {"type": "string", "description": "The deadline for the appeal process, formatted as 'YYYY-MM-DD'."}, "new_due_date": {"type": "string", "description": "The new due date for the case after the appeal is initiated, formatted as 'YYYY-MM-DD'."}}, "required": ["case_name", "appeals_unit", "appeal_date", "appeal_due_date", "new_due_date"]}}}, {"type": "function", "function": {"name": "prepare_mediation_materials", "description": "Initiates the preparation of mediation materials for a specified case by updating its stage to 'Mediation' and creating a corresponding assignment. Validates input parameters for correctness, including case name, mediation unit, and date formats. On success, returns the updated case details along with a success status. On failure, returns an error status with a description of the issue, such as invalid input or case not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which mediation materials are to be prepared. Must be a non-empty string with a maximum length of 200 characters."}, "mediation_unit": {"type": "string", "description": "The unit responsible for the mediation. Must be a non-empty string with a maximum length of 100 characters."}, "mediation_date": {"type": "string", "description": "The date when the mediation is scheduled to occur, in 'YYYY-MM-DD' format."}, "mediation_due_date": {"type": "string", "description": "The deadline for preparing the mediation materials, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "mediation_unit", "mediation_date", "mediation_due_date"]}}}, {"type": "function", "function": {"name": "replace_case_status", "description": "Updates the name of an existing case status to a new name, ensuring the change adheres to validation rules. The function verifies the existence of the original case status and validates the new name before performing the update. Upon success, it returns the updated case status details, including its unique identifier and other relevant attributes. If the original case status does not exist or the input fails validation, the function returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The current name of the case status to be updated. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_status_name": {"type": "string", "description": "The new name to assign to the case status. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name", "new_case_status_name"]}}}, {"type": "function", "function": {"name": "escalate_complaint_to_case", "description": "Converts a complaint into a formal case, including setting up assignments and parties involved. Validates all inputs for correctness and ensures the complaint is eligible for escalation. On success, returns the newly created case details, including its unique identifier and associated information. If any validation fails or the complaint cannot be escalated, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"complaint_id": {"type": "integer", "description": "The unique identifier of the complaint to be escalated. Must correspond to an existing complaint."}, "case_name": {"type": "string", "description": "The name of the new case. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case. Must be a non-empty string with a maximum length of 100 characters."}, "case_status_name": {"type": "string", "description": "The initial status of the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The initial stage of the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The due date for the case in 'YYYY-MM-DD' format."}, "assignments": {"type": "array", "items": {"type": "object", "properties": {"assignment_unit": {"type": "string", "description": "The unit responsible for the assignment. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_content": {"type": "string", "description": "The content or description of the assignment. Must be a non-empty string."}, "assignment_due_date": {"type": "string", "description": "The due date for the assignment in 'YYYY-MM-DD' format."}}, "required": ["assignment_unit", "assignment_content", "assignment_due_date"]}, "description": "A list of assignments associated with the case. Each assignment must include 'assignment_unit', 'assignment_content', and 'assignment_due_date'."}, "parties": {"type": "array", "items": {"type": "object", "properties": {"party_type": {"type": "string", "description": "The type of the party involved in the case. Must be a non-empty string with a maximum length of 20 characters."}, "party_name": {"type": "string", "description": "The name of the party involved in the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["party_type", "party_name"]}, "description": "A list of parties involved in the case. Each party must include 'party_type' and 'party_name'."}}, "required": ["complaint_id", "case_name", "case_type_name", "case_status_name", "case_stage_name", "due_date", "assignments", "parties"]}}}, {"type": "function", "function": {"name": "replace_case_plaintiff", "description": "Replaces the plaintiff in a specified legal case with a new plaintiff. The function ensures the case exists and the old plaintiff is correctly identified before performing the replacement. Upon success, it returns the details of the newly added plaintiff, including their unique identifier and associated case information. If the case or old plaintiff is not found, or if input validation fails, the function returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case where the plaintiff replacement is to occur. Must be a non-empty string with a maximum length of 200 characters."}, "old_plaintiff_name": {"type": "string", "description": "The name of the plaintiff to be replaced in the case. Must be a non-empty string with a maximum length of 200 characters."}, "new_plaintiff_name": {"type": "string", "description": "The name of the new plaintiff to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "old_plaintiff_name", "new_plaintiff_name"]}}}, {"type": "function", "function": {"name": "replace_case_details", "description": "Updates the details of an existing case in the system, including its type, status, stage, and acceptance date. Validates all inputs for correctness and ensures the case exists before making changes. On success, returns a confirmation of the update along with the complete updated case record, including all its fields. If the case or any referenced attributes (like type or status) do not exist, or if input validation fails, returns an error with a detailed explanation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The unique name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The name of the case type to assign to the case. Must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, in 'YYYY-MM-DD' format."}, "case_status_name": {"type": "string", "description": "The name of the case status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "case_stage_name": {"type": "string", "description": "The name of the case stage to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}, "due_date": {"type": "string", "description": "The optional due date for the case, in 'YYYY-MM-DD' format. If not provided, the due date will be cleared."}}, "required": ["case_name", "case_type_name", "acceptance_date", "case_status_name", "case_stage_name"]}}}, {"type": "function", "function": {"name": "record_verdict", "description": "Records the verdict for a specific legal proceeding, updating its status to 'Verdicted' and returning the updated proceeding details. The function validates the input case name, court name, and verdict date format before processing. On success, it returns the status 'success' along with the complete details of the updated proceeding. On failure, it returns the status 'failure' with an error message indicating the reason, such as invalid input, case not found, or proceeding not found.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case, which must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the proceeding took place, which must be a non-empty string with a maximum length of 200 characters."}, "verdict_date": {"type": "string", "description": "The date of the verdict, which must be provided in the 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "verdict_date"]}}}, {"type": "function", "function": {"name": "reopen_case_due_to_new_evidence", "description": "Reopens a previously closed case due to the discovery of new evidence, assigning it to a review unit with specified dates and evidence details. Upon success, returns the details of the newly created assignment, including the case identifier, review unit, assignment and due dates, and evidence description, confirming the case's updated status and the assignment's successful creation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened, must be non-empty and not exceed 200 characters."}, "evidence_review_unit": {"type": "string", "description": "The unit responsible for reviewing the new evidence, must be non-empty and not exceed 100 characters."}, "review_assignment_date": {"type": "string", "description": "The date when the review assignment is made, in 'YYYY-MM-DD' format."}, "review_due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the new evidence prompting the case reopening, must be non-empty."}}, "required": ["case_name", "evidence_review_unit", "review_assignment_date", "review_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "replace_complaint_details", "description": "Updates the details of an existing complaint in the system, including its source, handling unit, result, and category. Validates all inputs for correctness and ensures the complaint exists before proceeding with the update. On success, returns the updated complaint record along with a success status. If the complaint does not exist or inputs are invalid, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date of the complaint in 'YYYY-MM-DD' format. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The source of the complaint, must not exceed 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed content of the complaint, must not be empty. Example: 'Product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The unit responsible for handling the complaint, must not exceed 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The result of handling the complaint, must not exceed 50 characters. Example: 'Resolved with refund'."}, "complaint_category": {"type": "string", "description": "The category of the complaint, must not exceed 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "create_case_status", "description": "Registers a new case status in the system. The function validates the provided case status name to ensure it meets length and non-empty requirements. Upon successful registration, it returns the newly created case status record, including its unique identifier and details. If validation fails or a database error occurs, it returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_status_name": {"type": "string", "description": "The name of the case status to be registered. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_status_name"]}}}, {"type": "function", "function": {"name": "settle_case", "description": "Finalizes the settlement of a legal case by updating its status to 'Settled' and stage to 'Closed', and records the settlement details. This includes assigning a settlement unit, documenting the settlement date, and setting a due date for any follow-up actions. Upon success, returns the updated case record with its new status and stage, along with confirmation of the settlement process completion. If the case does not exist or input validation fails, returns an error indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_unit": {"type": "string", "description": "The unit responsible for handling the settlement. Must be a non-empty string with a maximum length of 100 characters."}, "settlement_date": {"type": "string", "description": "The date when the settlement is finalized, in 'YYYY-MM-DD' format."}, "settlement_due_date": {"type": "string", "description": "The due date for any follow-up actions related to the settlement, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "settlement_unit", "settlement_date", "settlement_due_date"]}}}, {"type": "function", "function": {"name": "add_expert_witness", "description": "Associates an expert witness with a specified legal case, ensuring the inputs meet validation criteria. Upon successful association, returns the details of the newly added expert witness, including their unique identifier and role. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case to which the expert witness will be added. Must be a non-empty string not exceeding 200 characters."}, "expert_name": {"type": "string", "description": "The full name of the expert witness to be associated with the case. Must be a non-empty string not exceeding 200 characters."}}, "required": ["case_name", "expert_name"]}}}, {"type": "function", "function": {"name": "consolidate_duplicate_case_type", "description": "Merges a duplicate case type into an original case type by updating all associated cases and removing the duplicate. Validates the existence of both the original and duplicate case types before proceeding. On success, returns the updated details of the original case type along with a success status. On failure, returns an error message indicating the reason for the failure, such as missing case types or database errors.", "parameters": {"type": "object", "properties": {"duplicate_name": {"type": "string", "description": "The name of the duplicate case type to be merged into the original. Must be a non-empty string with a maximum length of 100 characters."}, "original_id": {"type": "integer", "description": "The unique identifier of the original case type into which the duplicate will be merged. Must correspond to an existing case type."}}, "required": ["duplicate_name", "original_id"]}}}, {"type": "function", "function": {"name": "reopen_for_dna_evidence", "description": "Reopens a legal case for further investigation based on new DNA evidence, assigns it to a forensics unit, and schedules a review. The function ensures all inputs meet specified constraints before proceeding. Upon success, it returns the updated case details, including the new status and stage, confirming the case has been reopened and assigned for review.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be reopened. Must be a non-empty string with a maximum length of 200 characters."}, "forensics_unit": {"type": "string", "description": "The forensics unit assigned to review the DNA evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the case is assigned for review, in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The deadline for completing the review, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "forensics_unit", "assignment_date", "due_date"]}}}, {"type": "function", "function": {"name": "replace_case_stage", "description": "Renames an existing case stage to a new name, ensuring the new name is unique and the original exists. Validates input lengths and checks for duplicates before proceeding. On success, returns the updated case stage details including its identifier and other attributes. If the original case stage does not exist, the new name is already in use, or validation fails, returns an error with a descriptive message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The current name of the case stage to be renamed. Must be a non-empty string with a maximum length of 50 characters."}, "new_case_stage_name": {"type": "string", "description": "The new name to assign to the case stage. Must be a non-empty string with a maximum length of 50 characters and must not already exist in the system."}}, "required": ["case_stage_name", "new_case_stage_name"]}}}, {"type": "function", "function": {"name": "create_field_investigation_case", "description": "Attempts to create a new field investigation case but fails due to a missing required parameter ('case_status_id'). The function validates input parameters for format and constraints but cannot proceed with case creation because the signature is incomplete. Upon failure, it returns an error message detailing the contract violation, specifically the absence of the required 'case_status_id' parameter.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case, must be a non-empty string with a maximum length of 200 characters."}, "case_type_name": {"type": "string", "description": "The type of the case, must be a non-empty string with a maximum length of 100 characters."}, "acceptance_date": {"type": "string", "description": "The date the case was accepted, must be in 'YYYY-MM-DD' format."}, "due_date": {"type": "string", "description": "The due date for the case, must be in 'YYYY-MM-DD' format."}, "investigation_unit": {"type": "string", "description": "The unit responsible for the investigation, must be a non-empty string with a maximum length of 100 characters."}, "investigation_date": {"type": "string", "description": "The date the investigation starts, must be in 'YYYY-MM-DD' format."}, "investigation_due_date": {"type": "string", "description": "The due date for the investigation, must be in 'YYYY-MM-DD' format."}, "investigation_content": {"type": "string", "description": "The content or details of the investigation, must be a non-empty string."}, "plaintiff_name": {"type": "string", "description": "The name of the plaintiff, must be a non-empty string with a maximum length of 200 characters."}, "defendant_name": {"type": "string", "description": "The name of the defendant, must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness, must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court, must be a non-empty string with a maximum length of 200 characters."}, "case_reason": {"type": "string", "description": "The reason for the case, must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "case_type_name", "acceptance_date", "due_date", "investigation_unit", "investigation_date", "investigation_due_date", "investigation_content", "plaintiff_name", "defendant_name", "witness_name", "court_name", "case_reason"]}}}, {"type": "function", "function": {"name": "advance_case_stage", "description": "Updates the stage of a specified case to a new stage, ensuring both the case and the new stage exist. On success, returns the updated case details including its new stage. If the case or stage does not exist, or if an error occurs during the update, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be advanced to a new stage. Must be a non-empty string with a maximum length of 200 characters."}, "new_stage_name": {"type": "string", "description": "The name of the new stage to which the case will be advanced. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_stage_name"]}}}, {"type": "function", "function": {"name": "create_case_type", "description": "Registers a new case type in the system, ensuring the name is unique and meets validation criteria. On success, returns the details of the newly created case type, including its unique identifier and name. If the name is invalid or already exists, returns an error message indicating the specific issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The name of the case type to be created. Must be a non-empty string with a maximum length of 100 characters and must not already exist in the system."}}, "required": ["case_type_name"]}}}, {"type": "function", "function": {"name": "create_settlement_proceeding", "description": "Marks a legal case as settled by recording the case name, court name, and settlement date. This function is intended to finalize the settlement process for a case. However, due to a contract violation in the function signature, it will always return a failure status with an error message indicating the missing required columns 'case_reason' and 'progress_status'. The return value upon failure includes a status of 'failure' and a detailed error message explaining the contract violation.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the legal case being settled. Must be a non-empty string with a maximum length of 200 characters."}, "court_name": {"type": "string", "description": "The name of the court where the case is being settled. Must be a non-empty string with a maximum length of 200 characters."}, "settlement_date": {"type": "string", "description": "The date on which the settlement is finalized, in 'YYYY-MM-DD' format."}}, "required": ["case_name", "court_name", "settlement_date"]}}}, {"type": "function", "function": {"name": "close_case", "description": "Finalizes the closure of a specified case by updating its status and stage to 'Closed', and records the closure details including the responsible unit and relevant dates. Upon successful execution, returns a confirmation of the closure along with the updated case details, including its unique identifier and current status. If the case does not exist or inputs are invalid, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be closed, must be a non-empty string with a maximum length of 200 characters."}, "closure_unit": {"type": "string", "description": "The unit responsible for closing the case, must be a non-empty string with a maximum length of 100 characters."}, "closure_date": {"type": "string", "description": "The date when the case is closed, must be in 'YYYY-MM-DD' format."}, "closure_due_date": {"type": "string", "description": "The due date for the closure documentation, must be in 'YYYY-MM-DD' format."}}, "required": ["case_name", "closure_unit", "closure_date", "closure_due_date"]}}}, {"type": "function", "function": {"name": "add_witness_to_case", "description": "Associates a witness with a specific case in the system. Validates the input names for length and ensures the case exists. On success, returns the details of the newly added witness, including their unique identifier, the case they are associated with, their role as a witness, and their name. If the case does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to which the witness will be added. Must be a non-empty string with a maximum length of 200 characters."}, "witness_name": {"type": "string", "description": "The name of the witness to be added to the case. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name", "witness_name"]}}}, {"type": "function", "function": {"name": "update_case_status", "description": "Updates the status of a specified case to a new status, ensuring both the case and the new status exist. On success, returns the updated case details along with a success status. If the case or status does not exist, or if an error occurs, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case to be updated. Must be a non-empty string with a maximum length of 200 characters."}, "new_status_name": {"type": "string", "description": "The new status to assign to the case. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_name", "new_status_name"]}}}, {"type": "function", "function": {"name": "complete_supreme_court_proceeding", "description": "Marks a Supreme Court proceeding for a specified case as completed. The function verifies the existence of the case and its associated Supreme Court proceeding before updating the status. Upon success, it returns the updated proceeding details, including its status and other relevant information. If the case or proceeding is not found, or if an error occurs during processing, the function returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the Supreme Court proceeding is to be marked as completed. Must be a non-empty string with a maximum length of 200 characters."}}, "required": ["case_name"]}}}, {"type": "function", "function": {"name": "add_evidence_review_assignment", "description": "Assigns a new evidence review task for a specific case, ensuring all input data is validated. On success, returns the details of the newly created assignment, including its unique identifier and all associated information. If the case does not exist or input validation fails, returns an error with a specific failure reason.", "parameters": {"type": "object", "properties": {"case_name": {"type": "string", "description": "The name of the case for which the evidence review is being assigned. Must be a non-empty string with a maximum length of 200 characters."}, "evidence_unit": {"type": "string", "description": "The unit or department responsible for reviewing the evidence. Must be a non-empty string with a maximum length of 100 characters."}, "assignment_date": {"type": "string", "description": "The date when the evidence review is assigned, in 'YYYY-MM-DD' format."}, "assignment_due_date": {"type": "string", "description": "The due date for completing the evidence review, in 'YYYY-MM-DD' format."}, "evidence_description": {"type": "string", "description": "A detailed description of the evidence to be reviewed. Must be a non-empty string."}}, "required": ["case_name", "evidence_unit", "assignment_date", "assignment_due_date", "evidence_description"]}}}, {"type": "function", "function": {"name": "create_case_stage", "description": "Registers a new stage for a case in the system. Validates the provided stage name to ensure it meets length and non-empty requirements. Upon successful registration, returns the unique identifier and details of the newly created case stage, including its status. If validation fails or an error occurs during processing, returns a failure status with an appropriate error message.", "parameters": {"type": "object", "properties": {"case_stage_name": {"type": "string", "description": "The name of the case stage to be created. Must be a non-empty string with a maximum length of 50 characters."}}, "required": ["case_stage_name"]}}}, {"type": "function", "function": {"name": "create_complaint", "description": "Registers a new complaint in the system, ensuring all provided details meet the required validation criteria. Upon successful registration, returns the complete details of the newly created complaint, including its unique identifier and all submitted information. If validation fails or a database error occurs, returns an error message detailing the issue.", "parameters": {"type": "object", "properties": {"complaint_time": {"type": "string", "description": "The date when the complaint was filed, formatted as 'YYYY-MM-DD'. Example: '2023-10-05'."}, "complaint_source": {"type": "string", "description": "The origin or source of the complaint, limited to 50 characters. Example: 'Customer feedback form'."}, "complaint_content": {"type": "string", "description": "The detailed description or content of the complaint. Must not be empty. Example: 'The product arrived damaged.'."}, "handling_unit": {"type": "string", "description": "The department or team responsible for handling the complaint, limited to 100 characters. Example: 'Customer Support Team'."}, "handling_result": {"type": "string", "description": "The outcome or resolution status of the complaint, limited to 50 characters. Example: 'Pending investigation'."}, "complaint_category": {"type": "string", "description": "The category or type of the complaint, limited to 50 characters. Example: 'Shipping issue'."}}, "required": ["complaint_time", "complaint_source", "complaint_content", "handling_unit", "handling_result", "complaint_category"]}}}, {"type": "function", "function": {"name": "replace_case_type", "description": "Renames an existing case type to a new name, ensuring the change adheres to validation rules. If successful, returns the updated case type details including its identifier and other attributes. If the original case type does not exist or the input is invalid, returns an error message explaining the issue.", "parameters": {"type": "object", "properties": {"case_type_name": {"type": "string", "description": "The current name of the case type to be renamed. Must be a non-empty string with a maximum length of 100 characters."}, "new_case_type_name": {"type": "string", "description": "The new name for the case type. Must be a non-empty string with a maximum length of 100 characters."}}, "required": ["case_type_name", "new_case_type_name"]}}}], "tool_execute_env": "import os\nimport re\nimport sys\nimport math\nimport pytest\nimport sqlite3\nfrom datetime import datetime\nfrom typing import *\n\ndef query_case_statuses_join_cases(case_statuses_case_status_id: Optional[Dict[str, Any]] = None, case_statuses_case_status_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_statuses\".\"case_status_id\" AS \"case_statuses_case_status_id\",\n                \"case_statuses\".\"case_status_name\" AS \"case_statuses_case_status_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_statuses\"\n            JOIN \"cases\" ON \"case_statuses\".\"case_status_id\" = \"cases\".\"case_status_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, table_name, column_name):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    if not isinstance(value, (list, tuple)):\n                        raise ValueError(\"IN operator requires a list of values\")\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table_name}\".\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add conditions for each filter parameter with proper table names\n        add_condition(case_statuses_case_status_id, \"case_statuses\", \"case_status_id\")\n        add_condition(case_statuses_case_status_name, \"case_statuses\", \"case_status_name\")\n        add_condition(cases_case_id, \"cases\", \"case_id\")\n        add_condition(cases_case_name, \"cases\", \"case_name\")\n        add_condition(cases_case_type_id, \"cases\", \"case_type_id\")\n        add_condition(cases_acceptance_date, \"cases\", \"acceptance_date\")\n        add_condition(cases_case_status_id, \"cases\", \"case_status_id\")\n        add_condition(cases_case_stage_id, \"cases\", \"case_stage_id\")\n        add_condition(cases_due_date, \"cases\", \"due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            # Validate order_by columns to prevent SQL injection\n            validated_order_by = []\n            for item in order_by:\n                parts = item.split()\n                col_name = parts[0]\n                direction = parts[1].upper() if len(parts) > 1 else \"ASC\"\n                if direction not in [\"ASC\", \"DESC\"]:\n                    direction = \"ASC\"\n                validated_order_by.append(f'\"{col_name}\" {direction}')\n            query += \" ORDER BY \" + \", \".join(validated_order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            row_dict = dict(zip(columns, row))\n            result = {\n                'case_statuses': {\n                    'case_status_id': row_dict['case_statuses_case_status_id'],\n                    'case_status_name': row_dict['case_statuses_case_status_name']\n                },\n                'cases': {\n                    'case_id': row_dict['cases_case_id'],\n                    'case_name': row_dict['cases_case_name'],\n                    'case_type_id': row_dict['cases_case_type_id'],\n                    'acceptance_date': row_dict['cases_acceptance_date'],\n                    'case_status_id': row_dict['cases_case_status_id'],\n                    'case_stage_id': row_dict['cases_case_stage_id'],\n                    'due_date': row_dict['cases_due_date']\n                }\n            }\n            results.append(result)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases(case_id: Optional[Dict[str, Any]] = None, case_name: Optional[Dict[str, Any]] = None, case_type_id: Optional[Dict[str, Any]] = None, acceptance_date: Optional[Dict[str, Any]] = None, case_status_id: Optional[Dict[str, Any]] = None, case_stage_id: Optional[Dict[str, Any]] = None, due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_id\", \"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\" FROM \"cases\"'\n        \n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add condition\n        def add_condition(column, filter_dict):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column} must be a list when using IN/NOT IN\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n        \n        # Add all conditions\n        add_condition('case_id', case_id)\n        add_condition('case_name', case_name)\n        add_condition('case_type_id', case_type_id)\n        add_condition('acceptance_date', acceptance_date)\n        add_condition('case_status_id', case_status_id)\n        add_condition('case_stage_id', case_stage_id)\n        add_condition('due_date', due_date)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                parts = clause.split()\n                if len(parts) == 1:\n                    order_clauses.append(f'\"{parts[0]}\"')\n                elif len(parts) == 2:\n                    order_clauses.append(f'\"{parts[0]}\" {parts[1].upper()}')\n                else:\n                    raise ValueError(f\"Invalid order_by clause: {clause}\")\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET\n        if limit is not None:\n            if limit < 0:\n                raise ValueError(\"Limit must be >= 0\")\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                raise ValueError(\"Offset must be >= 0\")\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Get results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_assignments(\n    cases_case_id: Optional[Dict[str, Any]] = None,\n    cases_case_name: Optional[Dict[str, Any]] = None,\n    cases_case_type_id: Optional[Dict[str, Any]] = None,\n    cases_acceptance_date: Optional[Dict[str, Any]] = None,\n    cases_case_status_id: Optional[Dict[str, Any]] = None,\n    cases_case_stage_id: Optional[Dict[str, Any]] = None,\n    cases_due_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_id: Optional[Dict[str, Any]] = None,\n    case_assignments_case_id: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_unit: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_date: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_content: Optional[Dict[str, Any]] = None,\n    case_assignments_assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_assignments\".\"assignment_id\", \"case_assignments\".\"case_id\" AS \"assignment_case_id\",\n                \"case_assignments\".\"assignment_unit\", \"case_assignments\".\"assignment_date\",\n                \"case_assignments\".\"assignment_content\", \"case_assignments\".\"assignment_due_date\"\n            FROM \"cases\"\n            LEFT JOIN \"case_assignments\" ON \"cases\".\"case_id\" = \"case_assignments\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(table, column_name, filter_dict):\n            if filter_dict is None:\n                return\n            \n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            \n            if op.upper() not in ('=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'):\n                raise ValueError(f\"Invalid operator: {op}\")\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {column_name} must be a list when using IN/NOT IN operator\")\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{table}\".\"{column_name}\" {op} ?')\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases', 'case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases', 'case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases', 'case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases', 'acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases', 'case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases', 'case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases', 'due_date', cases_due_date)\n\n        # Add filters for case_assignments table\n        if case_assignments_assignment_id is not None:\n            add_filter('case_assignments', 'assignment_id', case_assignments_assignment_id)\n        if case_assignments_case_id is not None:\n            add_filter('case_assignments', 'case_id', case_assignments_case_id)\n        if case_assignments_assignment_unit is not None:\n            add_filter('case_assignments', 'assignment_unit', case_assignments_assignment_unit)\n        if case_assignments_assignment_date is not None:\n            add_filter('case_assignments', 'assignment_date', case_assignments_assignment_date)\n        if case_assignments_assignment_content is not None:\n            add_filter('case_assignments', 'assignment_content', case_assignments_assignment_content)\n        if case_assignments_assignment_due_date is not None:\n            add_filter('case_assignments', 'assignment_due_date', case_assignments_assignment_due_date)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split('_', 1)  # Split on first underscore to separate table prefix\n                if len(parts) == 2:\n                    table_name, rest = parts\n                    column_parts = rest.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"{table_name}\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"{table_name}\".\"{rest}\"')\n                else:\n                    # Default to cases table if no prefix specified\n                    column_parts = col.split()\n                    if len(column_parts) > 1:\n                        order_clauses.append(f'\"cases\".\"{column_parts[0]}\" {column_parts[1]}')\n                    else:\n                        order_clauses.append(f'\"cases\".\"{col}\"')\n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n\n        # Transform results into the required format\n        results = []\n        for row in rows:\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            \n            result_item = {'cases': case_data}\n            \n            # Only include assignment data if assignment_id exists\n            if row[7] is not None:\n                assignment_data = {\n                    'assignment_id': row[7],\n                    'case_id': row[8],\n                    'assignment_unit': row[9],\n                    'assignment_date': row[10],\n                    'assignment_content': row[11],\n                    'assignment_due_date': row[12]\n                }\n                result_item['case_assignments'] = assignment_data\n                \n            results.append(result_item)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except ValueError as e:\n        print(f\"Error: Invalid parameter in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        raise  # Re-raise to fail the test\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types(case_type_id: Optional[Dict[str, Any]] = None, case_type_name: Optional[Dict[str, Any]] = None, \n                    order_by: Optional[List[str]] = None, limit: Optional[int] = None, \n                    offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_types table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Base query\n        query = 'SELECT \"case_type_id\", \"case_type_name\" FROM \"case_types\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_type_id is not None:\n            op = case_type_id.get('op')\n            value = case_type_id.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_id\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_id\" {op} ?')\n                    params.append(value)\n        \n        if case_type_name is not None:\n            op = case_type_name.get('op')\n            value = case_type_name.get('value')\n            if op and value is not None:\n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple value'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"case_type_name\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"case_type_name\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            try:\n                # Get valid column names from the table\n                cursor.execute('PRAGMA table_info(\"case_types\")')\n                valid_columns = [row[1].lower() for row in cursor.fetchall()]\n                \n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) == 1:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\"')\n                    elif len(parts) == 2:\n                        col = parts[0].lower()\n                        if col not in valid_columns:\n                            return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                        order_clauses.append(f'\"{col}\" {parts[1].upper()}')\n                    else:\n                        return {'status': 'failure', 'content': {'error': 'Invalid order_by format'}}\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except Exception as e:\n                return {'status': 'failure', 'content': {'error': f'Invalid order_by: {str(e)}'}}\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_assignments(\n    assignment_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    assignment_unit: Optional[Dict[str, Any]] = None,\n    assignment_date: Optional[Dict[str, Any]] = None,\n    assignment_content: Optional[Dict[str, Any]] = None,\n    assignment_due_date: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_assignments table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Valid columns for order_by validation\n        valid_columns = {\n            'assignment_id', 'case_id', 'assignment_unit', \n            'assignment_date', 'assignment_content', 'assignment_due_date'\n        }\n\n        # Build the base query\n        query = 'SELECT \"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\" FROM \"case_assignments\"'\n        params = []\n        \n        # Build WHERE clause for filters\n        conditions = []\n        \n        filter_mapping = {\n            'assignment_id': assignment_id,\n            'case_id': case_id,\n            'assignment_unit': assignment_unit,\n            'assignment_date': assignment_date,\n            'assignment_content': assignment_content,\n            'assignment_due_date': assignment_due_date\n        }\n        \n        for column, filter_dict in filter_mapping.items():\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                \n                if op.upper() in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        return {'status': 'failure', 'content': {'error': f'Value for {column} IN/NOT IN must be a list'}}\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column}\" {op} ?')\n                    params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for clause in order_by:\n                # Validate order_by clause format and column names\n                parts = clause.split()\n                if len(parts) != 2 or parts[1].upper() not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                column_name = parts[0]\n                if column_name not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {column_name}'}}\n                order_clauses.append(f'\"{column_name}\" {parts[1].upper()}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n        \n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute the query\n        cursor.execute(query, params)\n        \n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_assignments': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_proceedings(\n    proceeding_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    court_name: Optional[Dict[str, Any]] = None,\n    case_reason: Optional[Dict[str, Any]] = None,\n    progress_status: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_proceedings table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\" FROM \"case_proceedings\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"proceeding_id\", proceeding_id),\n            (\"case_id\", case_id),\n            (\"court_name\", court_name),\n            (\"case_reason\", case_reason),\n            (\"progress_status\", progress_status)\n        ]\n\n        for col_name, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        if not isinstance(value, (list, tuple)):\n                            return {'status': 'failure', 'content': {'error': f'Value for {col_name} must be a list for IN/NOT IN operations'}}\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{col_name}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{col_name}\" {op} ?')\n                        params.append(value)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            order_clauses = []\n            valid_columns = {'proceeding_id', 'case_id', 'court_name', 'case_reason', 'progress_status'}\n            for clause in order_by:\n                # Basic validation to prevent SQL injection\n                parts = clause.split()\n                if len(parts) not in (1, 2):\n                    return {'status': 'failure', 'content': {'error': f'Invalid order_by clause: {clause}'}}\n                col = parts[0]\n                if col not in valid_columns:\n                    return {'status': 'failure', 'content': {'error': f'Invalid column in order_by: {col}'}}\n                direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                if direction not in ('ASC', 'DESC'):\n                    return {'status': 'failure', 'content': {'error': f'Invalid sort direction: {direction}'}}\n                order_clauses.append(f'\"{col}\" {direction}')\n            query += ' ORDER BY ' + ', '.join(order_clauses)\n\n        # Process pagination\n        if limit is not None:\n            if limit < 0:\n                return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n            query += ' LIMIT ?'\n            params.append(limit)\n\n        if offset is not None:\n            if offset < 0:\n                return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_statuses(\n    case_status_id: Optional[Dict[str, Any]] = None,\n    case_status_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_statuses table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        # Validate input parameters\n        if limit is not None and limit < 0:\n            return {'status': 'failure', 'content': {'error': 'Limit must be >= 0'}}\n        if offset is not None and offset < 0:\n            return {'status': 'failure', 'content': {'error': 'Offset must be >= 0'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_status_id\", \"case_status_name\" FROM \"case_statuses\"'\n        params = []\n        conditions = []\n\n        # Build WHERE clause for each filter\n        if case_status_id is not None:\n            op = case_status_id.get('op')\n            value = case_status_id.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_id: {op}'}}\n            if not isinstance(value, int) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_id value must be an integer'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_id\" {op} ?')\n                params.append(value)\n\n        if case_status_name is not None:\n            op = case_status_name.get('op')\n            value = case_status_name.get('value')\n            if op not in ['=', '<', '>', '<=', '>=', '<>', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': f'Invalid operator for case_status_name: {op}'}}\n            if not isinstance(value, str) and op not in ['IN', 'NOT IN']:\n                return {'status': 'failure', 'content': {'error': 'case_status_name value must be a string'}}\n            if op in ['IN', 'NOT IN']:\n                if not isinstance(value, (list, tuple)):\n                    return {'status': 'failure', 'content': {'error': 'IN/NOT IN operator requires a list/tuple of values'}}\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"case_status_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_status_name\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ORDER BY clause\n        if order_by:\n            try:\n                order_clauses = []\n                for clause in order_by:\n                    parts = clause.split()\n                    if len(parts) not in [1, 2]:\n                        raise ValueError\n                    column = parts[0]\n                    direction = parts[1].upper() if len(parts) == 2 else 'ASC'\n                    if direction not in ['ASC', 'DESC']:\n                        raise ValueError\n                    if column not in ['case_status_id', 'case_status_name']:\n                        raise ValueError\n                    order_clauses.append(f'\"{column}\" {direction}')\n                query += ' ORDER BY ' + ', '.join(order_clauses)\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': 'Invalid order_by clause'}}\n\n        # Add LIMIT and OFFSET\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_statuses': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages_join_cases(case_stages_case_stage_id: Optional[Dict[str, Any]] = None, case_stages_case_stage_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = \"\"\"\n            SELECT \n                \"case_stages\".\"case_stage_id\" AS \"case_stages_case_stage_id\",\n                \"case_stages\".\"case_stage_name\" AS \"case_stages_case_stage_name\",\n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\"\n            FROM \"case_stages\"\n            INNER JOIN \"cases\" ON \"case_stages\".\"case_stage_id\" = \"cases\".\"case_stage_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add conditions\n        def add_condition(filter_dict, column_name):\n            if filter_dict is not None:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_name}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_name}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible conditions using the exact column aliases from SELECT\n        add_condition(case_stages_case_stage_id, \"case_stages_case_stage_id\")\n        add_condition(case_stages_case_stage_name, \"case_stages_case_stage_name\")\n        add_condition(cases_case_id, \"cases_case_id\")\n        add_condition(cases_case_name, \"cases_case_name\")\n        add_condition(cases_case_type_id, \"cases_case_type_id\")\n        add_condition(cases_acceptance_date, \"cases_acceptance_date\")\n        add_condition(cases_case_status_id, \"cases_case_status_id\")\n        add_condition(cases_case_stage_id, \"cases_case_stage_id\")\n        add_condition(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Transform results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Format results into nested dictionaries\n        results = []\n        for row in rows:\n            case_stages = {\n                'case_stage_id': row[0],\n                'case_stage_name': row[1]\n            }\n            cases = {\n                'case_id': row[2],\n                'case_name': row[3],\n                'case_type_id': row[4],\n                'acceptance_date': row[5],\n                'case_status_id': row[6],\n                'case_stage_id': row[7],\n                'due_date': row[8]\n            }\n            results.append({\n                'case_stages': case_stages,\n                'cases': cases\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_stages(case_stage_id: Optional[Dict[str, Any]] = None, case_stage_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"case_stage_id\", \"case_stage_name\" FROM \"case_stages\"'\n        params = []\n        \n        # Build WHERE clause\n        conditions = []\n        \n        if case_stage_id is not None:\n            op = case_stage_id.get('op')\n            value = case_stage_id.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_id\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_id\" {op} ?')\n                params.append(value)\n        \n        if case_stage_name is not None:\n            op = case_stage_name.get('op')\n            value = case_stage_name.get('value')\n            if op.upper() in ('IN', 'NOT IN'):\n                placeholders = ', '.join(['?'] * len(value))\n                conditions.append(f'\"case_stage_name\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"case_stage_name\" {op} ?')\n                params.append(value)\n        \n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n        \n        # Build ORDER BY clause\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n        \n        # Build LIMIT and OFFSET clauses\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        \n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n        \n        # Execute query\n        cursor.execute(query, params)\n        \n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n        \n        return {'status': 'success', 'content': results}\n    \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_stages': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_types_join_cases(case_types_case_type_id: Optional[Dict[str, Any]] = None, case_types_case_type_name: Optional[Dict[str, Any]] = None, cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with aliases that match the filter parameter names\n        query = \"\"\"\n            SELECT \n                \"case_types\".\"case_type_id\" as \"case_types_case_type_id\",\n                \"case_types\".\"case_type_name\" as \"case_types_case_type_name\",\n                \"cases\".\"case_id\" as \"cases_case_id\",\n                \"cases\".\"case_name\" as \"cases_case_name\",\n                \"cases\".\"case_type_id\" as \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" as \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" as \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" as \"cases_case_stage_id\",\n                \"cases\".\"due_date\" as \"cases_due_date\"\n            FROM \"case_types\"\n            INNER JOIN \"cases\" ON \"case_types\".\"case_type_id\" = \"cases\".\"case_type_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n        \n        # Helper function to add filter conditions using the exact alias names\n        def add_filter(filter_dict, column_alias):\n            if filter_dict:\n                op = filter_dict['op']\n                value = filter_dict['value']\n                if op.upper() in ['IN', 'NOT IN']:\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{column_alias}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{column_alias}\" {op} ?')\n                    params.append(value)\n\n        # Add all possible filters using the exact alias names\n        add_filter(case_types_case_type_id, \"case_types_case_type_id\")\n        add_filter(case_types_case_type_name, \"case_types_case_type_name\")\n        add_filter(cases_case_id, \"cases_case_id\")\n        add_filter(cases_case_name, \"cases_case_name\")\n        add_filter(cases_case_type_id, \"cases_case_type_id\")\n        add_filter(cases_acceptance_date, \"cases_acceptance_date\")\n        add_filter(cases_case_status_id, \"cases_case_status_id\")\n        add_filter(cases_case_stage_id, \"cases_case_stage_id\")\n        add_filter(cases_due_date, \"cases_due_date\")\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified (using the same alias names)\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        rows = cursor.fetchall()\n        \n        # Transform results into the required format\n        results = []\n        for row in rows:\n            record = {\n                'case_types': {\n                    'case_type_id': row[0],\n                    'case_type_name': row[1]\n                },\n                'cases': {\n                    'case_id': row[2],\n                    'case_name': row[3],\n                    'case_type_id': row[4],\n                    'acceptance_date': row[5],\n                    'case_status_id': row[6],\n                    'case_stage_id': row[7],\n                    'due_date': row[8]\n                }\n            }\n            results.append(record)\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_types_join_cases': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_case_parties(\n    party_id: Optional[Dict[str, Any]] = None,\n    case_id: Optional[Dict[str, Any]] = None,\n    party_type: Optional[Dict[str, Any]] = None,\n    party_name: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the case_parties table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\"'\n        params = []\n        conditions = []\n\n        # Helper function to build filter conditions\n        def add_filter(column: str, filter_dict: Optional[Dict[str, Any]]):\n            if filter_dict is None:\n                return\n            op = filter_dict.get('op')\n            value = filter_dict.get('value')\n            if op is None or value is None:\n                return\n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                conditions.append(f'\"{column}\" {op} ({placeholders})')\n                params.extend(value)\n            else:\n                conditions.append(f'\"{column}\" {op} ?')\n                params.append(value)\n\n        # Add filters\n        add_filter('party_id', party_id)\n        add_filter('case_id', case_id)\n        add_filter('party_type', party_type)\n        add_filter('party_name', party_name)\n\n        # Combine conditions\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Add ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Add pagination\n        if limit is not None:\n            query += ' LIMIT ?'\n            params.append(limit)\n        if offset is not None:\n            query += ' OFFSET ?'\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_complaints(\n    complaint_id: Optional[Dict[str, Any]] = None,\n    complaint_time: Optional[Dict[str, Any]] = None,\n    complaint_source: Optional[Dict[str, Any]] = None,\n    complaint_content: Optional[Dict[str, Any]] = None,\n    handling_unit: Optional[Dict[str, Any]] = None,\n    handling_result: Optional[Dict[str, Any]] = None,\n    complaint_category: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the complaints table with dynamic filtering, sorting, and pagination.\"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT * FROM \"complaints\"'\n        params = []\n        conditions = []\n\n        # Process filters\n        filters = [\n            (\"complaint_id\", complaint_id),\n            (\"complaint_time\", complaint_time),\n            (\"complaint_source\", complaint_source),\n            (\"complaint_content\", complaint_content),\n            (\"handling_unit\", handling_unit),\n            (\"handling_result\", handling_result),\n            (\"complaint_category\", complaint_category)\n        ]\n\n        for column, filter_dict in filters:\n            if filter_dict is not None:\n                op = filter_dict.get('op')\n                value = filter_dict.get('value')\n                if op and value is not None:\n                    if op.upper() in ('IN', 'NOT IN'):\n                        placeholders = ','.join(['?'] * len(value))\n                        conditions.append(f'\"{column}\" {op} ({placeholders})')\n                        params.extend(value)\n                    else:\n                        conditions.append(f'\"{column}\" {op} ?')\n                        params.append(value)\n\n        if conditions:\n            query += ' WHERE ' + ' AND '.join(conditions)\n\n        # Process ordering\n        if order_by:\n            query += ' ORDER BY ' + ', '.join(order_by)\n\n        # Process pagination\n        if limit is not None and limit >= 0:\n            query += ' LIMIT ?'\n            params.append(limit)\n            if offset is not None and offset >= 0:\n                query += ' OFFSET ?'\n                params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Format results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_complaints': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_sqlite_sequence(\n    name: Optional[Dict[str, Any]] = None,\n    seq: Optional[Dict[str, Any]] = None,\n    order_by: Optional[List[str]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None\n) -> Dict[str, Union[str, Dict[str, Any]]]:\n    \"\"\"Queries records from the sqlite_sequence table with dynamic filtering, sorting, and pagination.\n\n    All column parameters are optional filters. Provide a dictionary with 'op' and 'value'\n    to apply a condition. Multiple filters are combined with a logical AND.\n\n    Args:\n        name: Optional filter for the table name associated with the sequence.\n            e.g., {'op': '=', 'value': 'some_table'}. The value must be a string. No specific format is enforced.\n        seq: Optional filter for the sequence value.\n            e.g., {'op': '>', 'value': 100}. The value must be an integer.\n        order_by: Optional list of columns to sort by, e.g., [\"seq DESC\", \"name ASC\"].\n        limit: Optional integer to limit the number of results. Must be >= 0.\n        offset: Optional integer to offset the results for pagination. Must be >= 0.\n        Supported operators are `'='`, `'<'`, `'>'`, `'<='`, `'>='`, `'<>'`, `'LIKE'`, `'NOT LIKE'`, `'IN'`, and `'NOT IN'`.\n\n    Returns:\n        Dict[str, Union[str, Dict[str, Any]]]: A dictionary indicating the outcome.\n        - On success: {'status': 'success', 'content': [list_of_records]}\n          The `content` is a list of dictionaries, where each dictionary is a record\n          from the sqlite_sequence table. All keys are lowercase.\n          e.g., [{'name': 'some_table', 'seq': 123}]\n        - On failure: {'status': 'failure', 'content': {'error': '<error_message>'}}\n\n    Associated schemas: [\"sqlite_sequence\"]\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query\n        query = 'SELECT \"name\", \"seq\" FROM \"sqlite_sequence\"'\n        params = []\n\n        # Apply filters\n        conditions = []\n        if name:\n            op = name.get('op')\n            value = name.get('value')\n            if op and value is not None:\n                conditions.append(f'\"name\" {op} ?')\n                params.append(value)\n        \n        if seq:\n            op = seq.get('op')\n            value = seq.get('value')\n            if op and value is not None:\n                conditions.append(f'\"seq\" {op} ?')\n                params.append(value)\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Apply sorting\n        if order_by:\n            query += \" ORDER BY \" + \", \".join(order_by)\n\n        # Apply pagination\n        if limit is not None and limit >= 0:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        \n        if offset is not None and offset >= 0:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        # Execute query\n        cursor.execute(query, params)\n\n        # Process results\n        columns = [description[0].lower() for description in cursor.description]\n        results = [dict(zip(columns, row)) for row in cursor.fetchall()]\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_sqlite_sequence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_proceedings(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_proceedings_proceeding_id: Optional[Dict[str, Any]] = None, case_proceedings_case_id: Optional[Dict[str, Any]] = None, case_proceedings_court_name: Optional[Dict[str, Any]] = None, case_proceedings_case_reason: Optional[Dict[str, Any]] = None, case_proceedings_progress_status: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\" AS \"cases_case_id\",\n                \"cases\".\"case_name\" AS \"cases_case_name\",\n                \"cases\".\"case_type_id\" AS \"cases_case_type_id\",\n                \"cases\".\"acceptance_date\" AS \"cases_acceptance_date\",\n                \"cases\".\"case_status_id\" AS \"cases_case_status_id\",\n                \"cases\".\"case_stage_id\" AS \"cases_case_stage_id\",\n                \"cases\".\"due_date\" AS \"cases_due_date\",\n                \"case_proceedings\".\"proceeding_id\" AS \"case_proceedings_proceeding_id\",\n                \"case_proceedings\".\"case_id\" AS \"case_proceedings_case_id\",\n                \"case_proceedings\".\"court_name\" AS \"case_proceedings_court_name\",\n                \"case_proceedings\".\"case_reason\" AS \"case_proceedings_case_reason\",\n                \"case_proceedings\".\"progress_status\" AS \"case_proceedings_progress_status\"\n            FROM \"cases\"\n            LEFT JOIN \"case_proceedings\" ON \"cases\".\"case_id\" = \"case_proceedings\".\"case_id\"\n            WHERE 1=1\n        \"\"\"\n\n        params = []\n        \n        # Helper function to add filter conditions\n        def add_filter(column_name, filter_dict):\n            if filter_dict is None:\n                return\n            nonlocal query, params\n            op = filter_dict['op']\n            value = filter_dict['value']\n            \n            if op.upper() in ('IN', 'NOT IN'):\n                if not isinstance(value, (list, tuple)):\n                    raise ValueError(f\"Value for {op} operator must be a list or tuple\")\n                placeholders = ','.join(['?'] * len(value))\n                query += f' AND \"{column_name}\" {op} ({placeholders})'\n                params.extend(value)\n            else:\n                query += f' AND \"{column_name}\" {op} ?'\n                params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id is not None:\n            add_filter('cases_case_id', cases_case_id)\n        if cases_case_name is not None:\n            add_filter('cases_case_name', cases_case_name)\n        if cases_case_type_id is not None:\n            add_filter('cases_case_type_id', cases_case_type_id)\n        if cases_acceptance_date is not None:\n            add_filter('cases_acceptance_date', cases_acceptance_date)\n        if cases_case_status_id is not None:\n            add_filter('cases_case_status_id', cases_case_status_id)\n        if cases_case_stage_id is not None:\n            add_filter('cases_case_stage_id', cases_case_stage_id)\n        if cases_due_date is not None:\n            add_filter('cases_due_date', cases_due_date)\n\n        # Add filters for case_proceedings table\n        if case_proceedings_proceeding_id is not None:\n            add_filter('case_proceedings_proceeding_id', case_proceedings_proceeding_id)\n        if case_proceedings_case_id is not None:\n            add_filter('case_proceedings_case_id', case_proceedings_case_id)\n        if case_proceedings_court_name is not None:\n            add_filter('case_proceedings_court_name', case_proceedings_court_name)\n        if case_proceedings_case_reason is not None:\n            add_filter('case_proceedings_case_reason', case_proceedings_case_reason)\n        if case_proceedings_progress_status is not None:\n            add_filter('case_proceedings_progress_status', case_proceedings_progress_status)\n\n        # Add ordering\n        if order_by is not None and len(order_by) > 0:\n            query += \" ORDER BY \" + \", \".join(\n                f'\"{col.split()[0]}\" {col.split()[1].upper()}' if len(col.split()) > 1 \n                else f'\"{col}\"'\n                for col in order_by\n            )\n\n        # Add limit and offset\n        if limit is not None:\n            query += \" LIMIT ?\"\n            params.append(limit)\n        if offset is not None:\n            query += \" OFFSET ?\"\n            params.append(offset)\n\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            proceeding_data = {\n                'proceeding_id': row[7],\n                'case_id': row[8],\n                'court_name': row[9],\n                'case_reason': row[10],\n                'progress_status': row[11]\n            }\n            results.append({\n                'cases': {k: v for k, v in case_data.items() if v is not None},\n                'case_proceedings': {k: v for k, v in proceeding_data.items() if v is not None}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_proceedings': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef query_cases_join_case_parties(cases_case_id: Optional[Dict[str, Any]] = None, cases_case_name: Optional[Dict[str, Any]] = None, cases_case_type_id: Optional[Dict[str, Any]] = None, cases_acceptance_date: Optional[Dict[str, Any]] = None, cases_case_status_id: Optional[Dict[str, Any]] = None, cases_case_stage_id: Optional[Dict[str, Any]] = None, cases_due_date: Optional[Dict[str, Any]] = None, case_parties_party_id: Optional[Dict[str, Any]] = None, case_parties_case_id: Optional[Dict[str, Any]] = None, case_parties_party_type: Optional[Dict[str, Any]] = None, case_parties_party_name: Optional[Dict[str, Any]] = None, order_by: Optional[List[str]] = None, limit: Optional[int] = None, offset: Optional[int] = None) -> Dict[str, Union[str, Dict[str, Any]]]:\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Base query with join\n        query = \"\"\"\n            SELECT \n                \"cases\".\"case_id\", \"cases\".\"case_name\", \"cases\".\"case_type_id\", \n                \"cases\".\"acceptance_date\", \"cases\".\"case_status_id\", \"cases\".\"case_stage_id\", \n                \"cases\".\"due_date\",\n                \"case_parties\".\"party_id\", \"case_parties\".\"case_id\" AS \"party_case_id\", \n                \"case_parties\".\"party_type\", \"case_parties\".\"party_name\"\n            FROM \"cases\"\n            INNER JOIN \"case_parties\" ON \"cases\".\"case_id\" = \"case_parties\".\"case_id\"\n        \"\"\"\n\n        # Build WHERE clause\n        conditions = []\n        params = []\n\n        # Helper function to add filter conditions\n        def add_filter(filter_dict, table, column):\n            if filter_dict:\n                op = filter_dict['op'].upper()\n                value = filter_dict['value']\n                if op in ('IN', 'NOT IN'):\n                    if not isinstance(value, (list, tuple)):\n                        value = [value]\n                    placeholders = ','.join(['?'] * len(value))\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ({placeholders})')\n                    params.extend(value)\n                else:\n                    conditions.append(f'\"{table}\".\"{column}\" {op} ?')\n                    params.append(value)\n\n        # Add filters for cases table\n        if cases_case_id: add_filter(cases_case_id, 'cases', 'case_id')\n        if cases_case_name: add_filter(cases_case_name, 'cases', 'case_name')\n        if cases_case_type_id: add_filter(cases_case_type_id, 'cases', 'case_type_id')\n        if cases_acceptance_date: add_filter(cases_acceptance_date, 'cases', 'acceptance_date')\n        if cases_case_status_id: add_filter(cases_case_status_id, 'cases', 'case_status_id')\n        if cases_case_stage_id: add_filter(cases_case_stage_id, 'cases', 'case_stage_id')\n        if cases_due_date: add_filter(cases_due_date, 'cases', 'due_date')\n\n        # Add filters for case_parties table\n        if case_parties_party_id: add_filter(case_parties_party_id, 'case_parties', 'party_id')\n        if case_parties_case_id: add_filter(case_parties_case_id, 'case_parties', 'case_id')\n        if case_parties_party_type: add_filter(case_parties_party_type, 'case_parties', 'party_type')\n        if case_parties_party_name: add_filter(case_parties_party_name, 'case_parties', 'party_name')\n\n        if conditions:\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        # Add ORDER BY if specified\n        if order_by:\n            order_clauses = []\n            for col in order_by:\n                parts = col.split()\n                col_name = parts[0]\n                direction = parts[1] if len(parts) > 1 else 'ASC'\n                \n                # Handle prefixed column names (e.g., \"cases_case_name\")\n                if col_name.startswith('cases_'):\n                    table = 'cases'\n                    column = col_name[6:]\n                elif col_name.startswith('case_parties_'):\n                    table = 'case_parties'\n                    column = col_name[13:]\n                else:\n                    # Default to cases table if no prefix\n                    table = 'cases'\n                    column = col_name\n                \n                order_clauses.append(f'\"{table}\".\"{column}\" {direction}')\n            \n            query += \" ORDER BY \" + \", \".join(order_clauses)\n\n        # Add LIMIT and OFFSET if specified\n        if limit is not None:\n            query += f\" LIMIT {limit}\"\n        if offset is not None:\n            query += f\" OFFSET {offset}\"\n\n        # Execute query\n        cursor.execute(query, params)\n        \n        # Transform results into the required format\n        results = []\n        for row in cursor.fetchall():\n            case_data = {\n                'case_id': row[0],\n                'case_name': row[1],\n                'case_type_id': row[2],\n                'acceptance_date': row[3],\n                'case_status_id': row[4],\n                'case_stage_id': row[5],\n                'due_date': row[6]\n            }\n            party_data = {\n                'party_id': row[7],\n                'case_id': row[8],\n                'party_type': row[9],\n                'party_name': row[10]\n            }\n            results.append({\n                'cases': {k.lower(): v for k, v in case_data.items()},\n                'case_parties': {k.lower(): v for k, v in party_data.items()}\n            })\n\n        return {'status': 'success', 'content': results}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'query_cases_join_case_parties': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input lengths\n        if len(case_name) > 200:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_name' exceeds maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_type_name' exceeds maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds maximum length of 50 characters.\"}}\n\n        # Validate date formats\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, acceptance_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.match(date_pattern, due_date):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_result = cursor.fetchone()\n        if not case_type_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case type with name '{case_type_name}' exists.\"}}\n        case_type_id = case_type_result[0]\n\n        # Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_result = cursor.fetchone()\n        if not case_status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case status with name '{case_status_name}' exists.\"}}\n        case_status_id = case_status_result[0]\n\n        # Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_result = cursor.fetchone()\n        if not case_stage_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": f\"Not found: No case stage with name '{case_stage_name}' exists.\"}}\n        case_stage_id = case_stage_result[0]\n\n        # Insert new case\n        if due_date:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n            )\n        else:\n            cursor.execute(\n                'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\") VALUES (?, ?, ?, ?, ?)',\n                (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id)\n            )\n        conn.commit()\n\n        # Retrieve the newly inserted case\n        case_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": case_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": str(e)}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_assignment_completion(case_name: str, assignment_content: str, completion_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation for None values\n        if case_name is None or assignment_content is None or completion_date is None:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: None values not allowed'}}\n\n        # Validate completion_date format\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', completion_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'completion_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the provided name exists.'}}\n        case_id = case_row[0]\n\n        # Step 2: Find assignment_id\n        cursor.execute('SELECT \"assignment_id\" FROM \"case_assignments\" WHERE \"case_id\" = ? AND \"assignment_content\" = ?', \n                      (case_id, assignment_content))\n        assignment_row = cursor.fetchone()\n        if not assignment_row:\n            return {'status': 'failure', 'content': {'error': 'Assignment not found: No assignment with the provided content exists for this case.'}}\n        assignment_id = assignment_row[0]\n\n        # Step 4: Update assignment_due_date\n        cursor.execute('UPDATE \"case_assignments\" SET \"assignment_due_date\" = ? WHERE \"assignment_id\" = ?', \n                      (completion_date, assignment_id))\n        conn.commit()\n\n        # Step 5: Retrieve updated assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_assignment = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'update_assignment_completion': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_appeal_proceeding(case_name: str, appeals_unit: str, appeal_date: str, appeal_due_date: str, new_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not appeals_unit or len(appeals_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeals_unit' must be non-empty and <= 100 characters.\"}}\n        date_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n        if not re.match(date_pattern, appeal_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, appeal_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'appeal_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.match(date_pattern, new_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the provided name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve 'Appeal Granted' status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Appeal Granted',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal Granted' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve 'Appeal' stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Appeal',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Appeal' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, new_due_date, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                      (case_id, appeals_unit, appeal_date, \"Appeal proceeding initiated\", appeal_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n                      (case_id, \"Appeals Court\", \"Appeal filed\", \"In Progress\"))\n\n        conn.commit()\n\n        # Step 9: Retrieve updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'create_appeal_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef prepare_mediation_materials(case_name: str, mediation_unit: str, mediation_date: str, mediation_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not mediation_unit or len(mediation_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', mediation_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'mediation_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get mediation stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Mediation',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Mediation stage not found in database.\"}}\n        stage_id = stage_result[0]\n\n        # Step 5: Update case stage\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (stage_id, case_id))\n\n        # Step 6: Create new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, mediation_unit, mediation_date, 'Prepare mediation materials', mediation_due_date)\n        )\n\n        # Step 7: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'prepare_mediation_materials': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_status(case_status_name: str, new_case_status_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be non-empty and not exceed 50 characters.\"}}\n        if not new_case_status_name or len(new_case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'new_case_status_name' must be non-empty and not exceed 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case_status_name exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        existing_status = cursor.fetchone()\n        if not existing_status:\n            return {'status': 'failure', 'content': {'error': \"Not Found: The specified case status does not exist.\"}}\n\n        # Update the case status name\n        cursor.execute('UPDATE \"case_statuses\" SET \"case_status_name\" = ? WHERE \"case_status_name\" = ?', \n                      (new_case_status_name, case_status_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_case_status_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_status': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef escalate_complaint_to_case(complaint_id: int, case_name: str, case_type_name: str, case_status_name: str, case_stage_name: str, due_date: str, assignments: List[Dict[str, str]], parties: List[Dict[str, str]]) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input parameter validation for None\n        if None in [complaint_id, case_name, case_type_name, case_status_name, case_stage_name, due_date, assignments, parties]:\n            return {'status': 'failure', 'content': {'error': 'All parameters must be provided (None not allowed)'}}\n        \n        # Validate string lengths\n        if len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' exceeds 200 characters.\"}}\n        if len(case_type_name) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' exceeds 100 characters.\"}}\n        if len(case_status_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' exceeds 50 characters.\"}}\n        if len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' exceeds 50 characters.\"}}\n        \n        # Validate due_date format\n        try:\n            datetime.strptime(due_date, '%Y-%m-%d')\n        except ValueError:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate assignments\n        for assignment in assignments:\n            if not all(key in assignment for key in ['assignment_unit', 'assignment_content', 'assignment_due_date']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each assignment must contain 'assignment_unit', 'assignment_content', and 'assignment_due_date'.\"}}\n            if len(assignment['assignment_unit']) > 100:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_unit' exceeds 100 characters.\"}}\n            if len(assignment['assignment_content']) == 0:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_content' cannot be empty.\"}}\n            try:\n                datetime.strptime(assignment['assignment_due_date'], '%Y-%m-%d')\n            except ValueError:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n        \n        # Validate parties\n        for party in parties:\n            if not all(key in party for key in ['party_type', 'party_name']):\n                return {'status': 'failure', 'content': {'error': \"Invalid input: Each party must contain 'party_type' and 'party_name'.\"}}\n            if len(party['party_type']) > 20:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_type' exceeds 20 characters.\"}}\n            if len(party['party_name']) > 200:\n                return {'status': 'failure', 'content': {'error': \"Invalid input: 'party_name' exceeds 200 characters.\"}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Check complaint exists and can be escalated\n        cursor.execute('SELECT \"handling_result\" FROM \"complaints\" WHERE \"complaint_id\" = ?', (complaint_id,))\n        complaint = cursor.fetchone()\n        if not complaint:\n            return {'status': 'failure', 'content': {'error': 'Complaint not found or cannot be escalated.'}}\n        \n        # Resolve foreign keys\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_id = cursor.fetchone()\n        if not case_type_id:\n            return {'status': 'failure', 'content': {'error': f\"Case type '{case_type_name}' not found.\"}}\n        case_type_id = case_type_id[0]\n        \n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_id = cursor.fetchone()\n        if not case_status_id:\n            return {'status': 'failure', 'content': {'error': f\"Case status '{case_status_name}' not found.\"}}\n        case_status_id = case_status_id[0]\n        \n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_id = cursor.fetchone()\n        if not case_stage_id:\n            return {'status': 'failure', 'content': {'error': f\"Case stage '{case_stage_name}' not found.\"}}\n        case_stage_id = case_stage_id[0]\n        \n        # Update complaint\n        cursor.execute('UPDATE \"complaints\" SET \"handling_result\" = ? WHERE \"complaint_id\" = ?', ('Case Opened', complaint_id))\n        \n        # Insert case\n        acceptance_date = datetime.now().strftime('%Y-%m-%d')\n        cursor.execute(\n            'INSERT INTO \"cases\" (\"case_name\", \"case_type_id\", \"acceptance_date\", \"case_status_id\", \"case_stage_id\", \"due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (case_name, case_type_id, acceptance_date, case_status_id, case_stage_id, due_date)\n        )\n        case_id = cursor.lastrowid\n        \n        # Insert assignments\n        for assignment in assignments:\n            cursor.execute(\n                'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n                (case_id, assignment['assignment_unit'], acceptance_date, assignment['assignment_content'], assignment['assignment_due_date'])\n            )\n        \n        # Insert parties\n        for party in parties:\n            cursor.execute(\n                'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                (case_id, party['party_type'], party['party_name'])\n            )\n        \n        # Get the inserted case\n        cursor.execute(\n            'SELECT * FROM \"cases\" WHERE \"case_id\" = ?',\n            (case_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'escalate_complaint_to_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': str(e)}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_plaintiff(case_name: str, old_plaintiff_name: str, new_plaintiff_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_name must be non-empty and <= 200 chars'}}\n        if not old_plaintiff_name or len(old_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: old_plaintiff_name must be non-empty and <= 200 chars'}}\n        if not new_plaintiff_name or len(new_plaintiff_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_plaintiff_name must be non-empty and <= 200 chars'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_row[0]\n\n        # Step 2: Verify old plaintiff exists\n        cursor.execute('SELECT \"party_id\" FROM \"case_parties\" WHERE \"case_id\" = ? AND \"party_type\" = ? AND \"party_name\" = ?', \n                      (case_id, 'Plaintiff', old_plaintiff_name))\n        plaintiff_row = cursor.fetchone()\n        if not plaintiff_row:\n            return {'status': 'failure', 'content': {'error': 'Plaintiff not found: The specified plaintiff does not exist in the case.'}}\n        party_id = plaintiff_row[0]\n\n        # Step 3: Delete old plaintiff\n        cursor.execute('DELETE FROM \"case_parties\" WHERE \"party_id\" = ?', (party_id,))\n\n        # Step 4: Insert new plaintiff\n        cursor.execute('INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n                      (case_id, 'Plaintiff', new_plaintiff_name))\n        \n        # Step 5: Get newly added plaintiff\n        new_party_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?', (new_party_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        new_plaintiff = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': new_plaintiff}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'replace_case_plaintiff': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_details(case_name: str, case_type_name: str, acceptance_date: str, case_status_name: str, case_stage_name: str, due_date: Optional[str] = None) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(case_name) > 200 or not case_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with a maximum length of 200 characters.\"}}\n        if len(case_type_name) > 100 or not case_type_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_type_name' must be a non-empty string with a maximum length of 100 characters.\"}}\n        if len(case_status_name) > 50 or not case_status_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_status_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if len(case_stage_name) > 50 or not case_stage_name:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_stage_name' must be a non-empty string with a maximum length of 50 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', acceptance_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'acceptance_date' must be in 'YYYY-MM-DD' format.\"}}\n        if due_date is not None and not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format if provided.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_row = cursor.fetchone()\n        if not case_row:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_row[0]\n\n        # Step 2: Resolve case_type_id\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        case_type_row = cursor.fetchone()\n        if not case_type_row:\n            return {'status': 'failure', 'content': {'error': \"Case type not found: No case type with the given name exists.\"}}\n        case_type_id = case_type_row[0]\n\n        # Step 3: Resolve case_status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (case_status_name,))\n        case_status_row = cursor.fetchone()\n        if not case_status_row:\n            return {'status': 'failure', 'content': {'error': \"Case status not found: No case status with the given name exists.\"}}\n        case_status_id = case_status_row[0]\n\n        # Step 4: Resolve case_stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        case_stage_row = cursor.fetchone()\n        if not case_stage_row:\n            return {'status': 'failure', 'content': {'error': \"Case stage not found: No case stage with the given name exists.\"}}\n        case_stage_id = case_stage_row[0]\n\n        # Step 8: Update case\n        if due_date is not None:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = ? \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, due_date, case_id))\n        else:\n            cursor.execute('''\n                UPDATE \"cases\" \n                SET \"case_type_id\" = ?, \"acceptance_date\" = ?, \"case_status_id\" = ?, \"case_stage_id\" = ?, \"due_date\" = NULL \n                WHERE \"case_id\" = ?\n            ''', (case_type_id, acceptance_date, case_status_id, case_stage_id, case_id))\n        conn.commit()\n\n        # Step 9: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_details': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef record_verdict(case_name: str, court_name: str, verdict_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters'}}\n        if not court_name or len(court_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: court_name must be non-empty and <= 200 characters'}}\n        \n        # Validate verdict_date format\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', verdict_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'verdict_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Find proceeding_id\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = ?', \n                      (case_id, court_name))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Proceeding not found: No proceeding with the given case and court exists.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 3: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = ? WHERE \"proceeding_id\" = ?', \n                      ('Verdicted', proceeding_id))\n        conn.commit()\n\n        # Step 4: Retrieve updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'record_verdict': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_case_due_to_new_evidence(case_name: str, evidence_review_unit: str, review_assignment_date: str, review_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: case_name must be non-empty and <= 200 characters.'}}\n        if not evidence_review_unit or len(evidence_review_unit) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_review_unit must be non-empty and <= 100 characters.'}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': 'Invalid input: evidence_description must be non-empty.'}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(review_assignment_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_assignment_date must be in YYYY-MM-DD format.'}}\n        if not date_pattern.match(review_due_date):\n            return {'status': 'failure', 'content': {'error': 'Invalid input: review_due_date must be in YYYY-MM-DD format.'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case with the given name exists.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get Reopened status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': 'Database error: Reopened status not found.'}}\n        status_id = status_result[0]\n\n        # Step 5: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n\n        # Step 6: Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_review_unit, review_assignment_date, evidence_description, review_due_date)\n        )\n        assignment_id = cursor.lastrowid\n\n        # Step 7: Get the inserted assignment\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        assignment = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': assignment}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'reopen_case_due_to_new_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_complaint_details(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if len(complaint_source) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_source' exceeds 50 characters.\"}}\n        if len(handling_unit) > 100:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_unit' exceeds 100 characters.\"}}\n        if len(handling_result) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'handling_result' exceeds 50 characters.\"}}\n        if len(complaint_category) > 50:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_category' exceeds 50 characters.\"}}\n        \n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        \n        if not complaint_content:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'complaint_content' must not be empty.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if complaint exists\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        existing = cursor.fetchone()\n        if not existing:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"No complaint found with the given time and content.\"}}\n\n        # Update complaint\n        cursor.execute(\n            '''UPDATE \"complaints\" \n            SET \"complaint_source\" = ?, \"handling_unit\" = ?, \"handling_result\" = ?, \"complaint_category\" = ?\n            WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?''',\n            (complaint_source, handling_unit, handling_result, complaint_category, complaint_time, complaint_content)\n        )\n        conn.commit()\n\n        # Get updated record\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_time\" = ? AND \"complaint_content\" = ?',\n            (complaint_time, complaint_content)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        updated_record = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": updated_record}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_complaint_details': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_status(case_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_status_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_status_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_statuses` table. The `case_status_id` is handled by the database. The `case_status_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case status.\n\n    3. **Error Handling**:\n        - If `case_status_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case status record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_status_name or len(case_status_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_status_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case status\n        cursor.execute(\n            'INSERT INTO \"case_statuses\" (\"case_status_name\") VALUES (?)',\n            (case_status_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_statuses\" WHERE \"case_status_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'create_case_status': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef settle_case(case_name: str, settlement_unit: str, settlement_date: str, settlement_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not settlement_unit or len(settlement_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', settlement_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'settlement_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Get settled status_id\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Settled',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Settled' status not found in case_statuses table.\"}}\n        settled_status_id = status_result[0]\n\n        # Step 3: Get closed stage_id\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found in case_stages table.\"}}\n        closed_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (settled_status_id, closed_stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0]\n        new_assignment_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n                      (new_assignment_id, case_id, settlement_unit, settlement_date, 'Settlement documentation', settlement_due_date))\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute('SELECT MAX(\"proceeding_id\") FROM \"case_proceedings\"')\n        max_id = cursor.fetchone()[0]\n        new_proceeding_id = 1 if max_id is None else max_id + 1\n        cursor.execute('INSERT INTO \"case_proceedings\" (\"proceeding_id\", \"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?, ?)',\n                      (new_proceeding_id, case_id, 'Settlement Conference', 'Case settled', 'Completed'))\n\n        conn.commit()\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Database error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Unexpected error in 'settle_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_expert_witness(case_name: str, expert_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not expert_name or len(expert_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'expert_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new expert witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', expert_name)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT * FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_expert_witness': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef consolidate_duplicate_case_type(duplicate_name: str, original_id: int) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not duplicate_name or len(duplicate_name) > 100:\n            return {'status': 'failure', 'content': {'error': 'Invalid duplicate_name'}}\n        \n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Verify original_id exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Original case type ID not found.'}}\n        \n        # Step 2: Verify duplicate_name exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        duplicate_row = cursor.fetchone()\n        if not duplicate_row:\n            return {'status': 'failure', 'content': {'error': 'Duplicate case type name not found.'}}\n        duplicate_id = duplicate_row[0]\n        \n        # Step 3: Update cases table\n        cursor.execute('UPDATE \"cases\" SET \"case_type_id\" = ? WHERE \"case_type_id\" = ?', (original_id, duplicate_id))\n        \n        # Step 4: Delete duplicate from case_types\n        cursor.execute('DELETE FROM \"case_types\" WHERE \"case_type_name\" = ?', (duplicate_name,))\n        \n        # Step 5: Get updated original record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?', (original_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'consolidate_duplicate_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef reopen_for_dna_evidence(case_name: str, forensics_unit: str, assignment_date: str, due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200.\"}}\n        if not forensics_unit or len(forensics_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'forensics_unit' must be a non-empty string with maximum length of 100.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case exists with the provided name '{case_name}'.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve Reopened status ID\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Reopened',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Reopened' status not found in case_statuses.\"}}\n        reopened_status_id = status_result[0]\n\n        # Step 3: Resolve Discovery stage ID\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Discovery',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Discovery' stage not found in case_stages.\"}}\n        discovery_stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute(\n            'UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?',\n            (reopened_status_id, discovery_stage_id, case_id)\n        )\n\n        # Step 7: Insert into case_assignments\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, forensics_unit, assignment_date, \"DNA evidence review\", due_date)\n        )\n\n        # Step 8: Insert into case_proceedings\n        cursor.execute(\n            'INSERT INTO \"case_proceedings\" (\"case_id\", \"court_name\", \"case_reason\", \"progress_status\") VALUES (?, ?, ?, ?)',\n            (case_id, \"Forensic Review\", \"DNA evidence re-examination\", \"In Progress\")\n        )\n\n        # Step 9: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'reopen_for_dna_evidence': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_stage(case_stage_name: str, new_case_stage_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: case_stage_name must be non-empty and <= 50 characters'}}\n        if not new_case_stage_name or len(new_case_stage_name) > 50:\n            return {'status': 'failure', 'content': {'error': 'validation error: new_case_stage_name must be non-empty and <= 50 characters'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if old case stage exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (case_stage_name,))\n        if not cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Case stage not found: The specified case stage does not exist.'}}\n\n        # Check if new case stage already exists\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        if cursor.fetchone():\n            return {'status': 'failure', 'content': {'error': 'Duplicate entry: A case stage with the new name already exists.'}}\n\n        # Update the case stage name\n        cursor.execute('UPDATE \"case_stages\" SET \"case_stage_name\" = ? WHERE \"case_stage_name\" = ?', \n                      (new_case_stage_name, case_stage_name))\n        conn.commit()\n\n        # Retrieve the updated record\n        cursor.execute('SELECT * FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_case_stage_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_field_investigation_case(case_name: str, case_type_name: str, acceptance_date: str, due_date: str, investigation_unit: str, investigation_date: str, investigation_due_date: str, investigation_content: str, plaintiff_name: str, defendant_name: str, witness_name: str, court_name: str, case_reason: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_type_name` must be a non-empty string with a maximum length of 100 characters.\n        - `acceptance_date` must be a string in 'YYYY-MM-DD' format.\n        - `due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_unit` must be a non-empty string with a maximum length of 100 characters.\n        - `investigation_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_due_date` must be a string in 'YYYY-MM-DD' format.\n        - `investigation_content` must be a non-empty string.\n        - `plaintiff_name` must be a non-empty string with a maximum length of 200 characters.\n        - `defendant_name` must be a non-empty string with a maximum length of 200 characters.\n        - `witness_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `case_reason` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"}}`\n    \"\"\"\n    return {\n        \"status\": \"failure\",\n        \"content\": {\n            \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the foreign key column 'case_status_id' because no parameter is available to resolve it.\"\n        }\n    }\n\ndef advance_case_stage(case_name: str, new_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to resolve the provided `case_name` to a case ID.\n        - 2. Execute a `SELECT case_stage_id FROM case_stages WHERE case_stage_name = ?` to resolve the provided `new_stage_name` to a stage ID.\n        - 3. If either query returns no results, abort with a \"not found\" error.\n        - 4. Execute an `UPDATE cases SET case_stage_id = ? WHERE case_id = ?` to update the case's stage.\n        - 5. Execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete, updated case record.\n\n    3. **Error Handling**:\n        - If the `case_name` does not correspond to an existing case, return a failure object with a 'case not found' error.\n        - If the `new_stage_name` does not correspond to an existing stage, return a failure object with a 'stage not found' error.\n        - If a database error occurs during the update, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case exists with the provided name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Stage not found: No stage exists with the provided name.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Case not found: No case exists with the provided name.'}}\n        case_id = case_result[0]\n\n        # Step 2: Get case_stage_id from new_stage_name\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', (new_stage_name,))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': 'Stage not found: No stage exists with the provided name.'}}\n        new_stage_id = stage_result[0]\n\n        # Step 4: Update case_stage_id\n        cursor.execute('UPDATE \"cases\" SET \"case_stage_id\" = ? WHERE \"case_id\" = ?', (new_stage_id, case_id))\n        conn.commit()\n\n        # Step 5: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_case}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'advance_case_stage': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_type(case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Invalid input: 'case_type_name' exceeds 100 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        cursor.execute(\n            'SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?',\n            (case_type_name,)\n        )\n        if cursor.fetchone() is not None:\n            return {\n                'status': 'failure',\n                'content': {\n                    'error': \"Duplicate entry: A case type with this name already exists.\"\n                }\n            }\n\n        cursor.execute(\n            'INSERT INTO \"case_types\" (\"case_type_name\") VALUES (?)',\n            (case_type_name,)\n        )\n        conn.commit()\n\n        cursor.execute(\n            'SELECT * FROM \"case_types\" WHERE \"case_type_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"A database error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_settlement_proceeding(case_name: str, court_name: str, settlement_date: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `court_name` must be a non-empty string with a maximum length of 200 characters.\n        - `settlement_date` must be a string in 'YYYY-MM-DD' format.\n\n    2. **Logic Flow**:\n        - Logic Flow cannot be determined. The function signature is incomplete and violates the schema's NOT NULL constraint for the column 'case_reason' and 'progress_status'.\n\n    3. **Error Handling**:\n        - Primary error is a contract violation reported in the Logic Flow. No other operational errors can be defined.\n\n    4. **Return Values**:\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"}}`\n    \"\"\"\n    try:\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": \"Contract Violation: Function signature is incomplete and violates the schema's NOT NULL constraint for the columns 'case_reason' and 'progress_status'.\"\n            }\n        }\n    except Exception as e:\n        print(f\"An unexpected error occurred in 'create_settlement_proceeding': {e}\", file=sys.stderr)\n        return {\n            \"status\": \"failure\",\n            \"content\": {\n                \"error\": f\"An unexpected error occurred: {e}\"\n            }\n        }\n\ndef close_case(case_name: str, closure_unit: str, closure_date: str, closure_due_date: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and <= 200 characters.\"}}\n        if not closure_unit or len(closure_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_unit' must be non-empty and <= 100 characters.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not re.fullmatch(r'\\d{4}-\\d{2}-\\d{2}', closure_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'closure_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Resolve case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n\n        # Step 2: Resolve case_status_id for 'Closed'\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', ('Closed',))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' status not found.\"}}\n        status_id = status_result[0]\n\n        # Step 3: Resolve case_stage_id for 'Closed'\n        cursor.execute('SELECT \"case_stage_id\" FROM \"case_stages\" WHERE \"case_stage_name\" = ?', ('Closed',))\n        stage_result = cursor.fetchone()\n        if not stage_result:\n            return {'status': 'failure', 'content': {'error': \"Database error: 'Closed' stage not found.\"}}\n        stage_id = stage_result[0]\n\n        # Step 6: Update case status and stage\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ?, \"case_stage_id\" = ? WHERE \"case_id\" = ?', \n                      (status_id, stage_id, case_id))\n\n        # Step 7: Insert into case_assignments\n        # First get max assignment_id\n        cursor.execute('SELECT MAX(\"assignment_id\") FROM \"case_assignments\"')\n        max_id = cursor.fetchone()[0] or 0\n        new_id = max_id + 1\n\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"assignment_id\", \"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?, ?)',\n            (new_id, case_id, closure_unit, closure_date, 'Case closure documentation', closure_due_date)\n        )\n\n        # Step 8: Get updated case record\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        case_record = dict(zip(columns, cursor.fetchone()))\n\n        conn.commit()\n        return {'status': 'success', 'content': case_record}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: An unexpected error occurred in 'close_case': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_witness_to_case(case_name: str, witness_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be non-empty and not exceed 200 characters.\"}}\n        if not witness_name or len(witness_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'witness_name' must be non-empty and not exceed 200 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Find case_id from case_name\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new witness\n        cursor.execute(\n            'INSERT INTO \"case_parties\" (\"case_id\", \"party_type\", \"party_name\") VALUES (?, ?, ?)',\n            (case_id, 'Witness', witness_name)\n        )\n        conn.commit()\n\n        # Get the newly inserted record\n        party_id = cursor.lastrowid\n        cursor.execute(\n            'SELECT \"party_id\", \"case_id\", \"party_type\", \"party_name\" FROM \"case_parties\" WHERE \"party_id\" = ?',\n            (party_id,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_witness_to_case': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef update_case_status(case_name: str, new_status_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n        - `new_status_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to verify that a case with the given `case_name` exists.\n        - 2. Execute a `SELECT case_status_id FROM case_statuses WHERE case_status_name = ?` to resolve the provided `new_status_name` to its corresponding foreign key value.\n        - 3. If both the case and status are found, execute an `UPDATE cases SET case_status_id = ? WHERE case_id = ?` statement to update the case's status.\n        - 4. On successful update, execute a `SELECT * FROM cases WHERE case_id = ?` to retrieve the complete record of the updated case.\n\n    3. **Error Handling**:\n        - If no case with the given `case_name` is found, return a failure object with a 'not found' error.\n        - If no status with the given `new_status_name` is found, return a failure object with a 'not found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated case record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}`.\n    \"\"\"\n    if not case_name or not new_status_name:\n        return {\"status\": \"failure\", \"content\": {\"error\": \"Case name and new status name must not be empty.\"}}\n    \n    conn = None\n    try:\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Step 1: Check if case exists\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Case not found: No case with the given name exists.\"}}\n        case_id = case_result[0]\n        \n        # Step 2: Check if status exists\n        cursor.execute('SELECT \"case_status_id\" FROM \"case_statuses\" WHERE \"case_status_name\" = ?', (new_status_name,))\n        status_result = cursor.fetchone()\n        if not status_result:\n            return {\"status\": \"failure\", \"content\": {\"error\": \"Status not found: No status with the given name exists.\"}}\n        status_id = status_result[0]\n        \n        # Step 3: Update case status\n        cursor.execute('UPDATE \"cases\" SET \"case_status_id\" = ? WHERE \"case_id\" = ?', (status_id, case_id))\n        \n        # Step 4: Retrieve updated case\n        cursor.execute('SELECT * FROM \"cases\" WHERE \"case_id\" = ?', (case_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_case = dict(zip(columns, cursor.fetchone()))\n        \n        conn.commit()\n        return {\"status\": \"success\", \"content\": updated_case}\n        \n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'update_case_status': {e}\", file=sys.stderr)\n        if conn:\n            conn.rollback()\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef complete_supreme_court_proceeding(case_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_name` must be a non-empty string with a maximum length of 200 characters.\n\n    2. **Logic Flow**:\n        - 1. Execute a `SELECT case_id FROM cases WHERE case_name = ?` to retrieve the case ID for the given `case_name`.\n        - 2. If no case is found with the given name, raise a \"Not Found\" error.\n        - 3. Execute a `SELECT proceeding_id FROM case_proceedings WHERE case_id = ? AND court_name = 'Supreme Court'` to retrieve the Supreme Court proceeding for the case.\n        - 4. If no Supreme Court proceeding is found for the case, raise a \"Not Found\" error.\n        - 5. Execute an `UPDATE case_proceedings SET progress_status = 'Completed' WHERE proceeding_id = ?` to mark the Supreme Court proceeding as completed.\n        - 6. Execute a `SELECT * FROM case_proceedings WHERE proceeding_id = ?` to retrieve the updated proceeding record.\n\n    3. **Error Handling**:\n        - If no case is found with the given `case_name`, return a failure object with a 'Not Found' error.\n        - If no Supreme Court proceeding is found for the case, return a failure object with a 'Not Found' error.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the updated proceeding record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No case found with the given name.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Not Found: No Supreme Court proceeding found for the case.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': 'Invalid case_name parameter'}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Step 1: Get case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No case found with the given name.'}}\n        case_id = case_result[0]\n\n        # Step 3: Get Supreme Court proceeding\n        cursor.execute('SELECT \"proceeding_id\" FROM \"case_proceedings\" WHERE \"case_id\" = ? AND \"court_name\" = \"Supreme Court\"', (case_id,))\n        proceeding_result = cursor.fetchone()\n        if not proceeding_result:\n            return {'status': 'failure', 'content': {'error': 'Not Found: No Supreme Court proceeding found for the case.'}}\n        proceeding_id = proceeding_result[0]\n\n        # Step 5: Update proceeding\n        cursor.execute('UPDATE \"case_proceedings\" SET \"progress_status\" = \"Completed\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        conn.commit()\n\n        # Step 6: Get updated proceeding\n        cursor.execute('SELECT * FROM \"case_proceedings\" WHERE \"proceeding_id\" = ?', (proceeding_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        updated_proceeding = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': updated_proceeding}\n\n    except sqlite3.Error as e:\n        if conn:\n            conn.rollback()\n        print(f\"Error: A database error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        print(f\"An unexpected error occurred in 'complete_supreme_court_proceeding': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef add_evidence_review_assignment(case_name: str, evidence_unit: str, assignment_date: str, assignment_due_date: str, evidence_description: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_name or len(case_name) > 200:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'case_name' must be a non-empty string with maximum length of 200 characters.\"}}\n        if not evidence_unit or len(evidence_unit) > 100:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if not evidence_description:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'evidence_description' must be a non-empty string.\"}}\n        \n        # Date format validation\n        date_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n        if not date_pattern.match(assignment_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_date' must be in 'YYYY-MM-DD' format.\"}}\n        if not date_pattern.match(assignment_due_date):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'assignment_due_date' must be in 'YYYY-MM-DD' format.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Resolve case_name to case_id\n        cursor.execute('SELECT \"case_id\" FROM \"cases\" WHERE \"case_name\" = ?', (case_name,))\n        case_result = cursor.fetchone()\n        if not case_result:\n            return {'status': 'failure', 'content': {'error': f\"Case not found: No case with the given name '{case_name}' exists.\"}}\n\n        case_id = case_result[0]\n\n        # Insert new assignment\n        cursor.execute(\n            'INSERT INTO \"case_assignments\" (\"case_id\", \"assignment_unit\", \"assignment_date\", \"assignment_content\", \"assignment_due_date\") VALUES (?, ?, ?, ?, ?)',\n            (case_id, evidence_unit, assignment_date, evidence_description, assignment_due_date)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        assignment_id = cursor.lastrowid\n        cursor.execute('SELECT * FROM \"case_assignments\" WHERE \"assignment_id\" = ?', (assignment_id,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'add_evidence_review_assignment': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_case_stage(case_stage_name: str) -> Dict[str, Any]:\n    \"\"\"\n    1. **Preconditions**:\n        - `case_stage_name` must be a non-empty string with a maximum length of 50 characters.\n\n    2. **Logic Flow**:\n        - 1. The primary key 'case_stage_id' is database-managed via AUTOINCREMENT.\n        - 2. Validate that the input string for `case_stage_name` does not exceed its maximum length and is not empty.\n        - 3. Execute an `INSERT` statement into the `case_stages` table. The `case_stage_id` is handled by the database. The `case_stage_name` column is populated from the input parameter.\n        - 4. On successful insertion, use the `lastrowid` to execute a `SELECT` statement to retrieve the complete record of the newly added case stage.\n\n    3. **Error Handling**:\n        - If `case_stage_name` fails validation (e.g., length, empty), return a failure object with a specific 'validation error'.\n        - If a database error occurs, the transaction will be rolled back, and a failure object will be returned.\n\n    4. **Return Values**:\n        - On success: `{\"status\": \"success\", \"content\": <the inserted case stage record as a dictionary>}`.\n        - On failure: `{\"status\": \"failure\", \"content\": {\"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"}}` or `{\"status\": \"failure\", \"content\": {\"error\": \"Database error occurred.\"}}`.\n    \"\"\"\n    conn = None\n    try:\n        # Input validation\n        if not case_stage_name or len(case_stage_name) > 50:\n            return {\n                \"status\": \"failure\",\n                \"content\": {\n                    \"error\": \"Invalid input: 'case_stage_name' exceeds 50 characters or is empty.\"\n                }\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Insert new case stage\n        cursor.execute(\n            'INSERT INTO \"case_stages\" (\"case_stage_name\") VALUES (?)',\n            (case_stage_name,)\n        )\n        conn.commit()\n\n        # Retrieve the newly inserted record\n        cursor.execute(\n            'SELECT * FROM \"case_stages\" WHERE \"case_stage_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {\"status\": \"success\", \"content\": result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"Database error occurred: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'create_case_stage': {e}\", file=sys.stderr)\n        return {\"status\": \"failure\", \"content\": {\"error\": f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef create_complaint(complaint_time: str, complaint_source: str, complaint_content: str, handling_unit: str, handling_result: str, complaint_category: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Validate input parameters\n        if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', complaint_time):\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_time' must be in 'YYYY-MM-DD' format.\"}}\n        if len(complaint_source) > 50 or not complaint_source:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_source' must be a non-empty string with maximum length of 50 characters.\"}}\n        if not complaint_content:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_content' must be a non-empty string.\"}}\n        if len(handling_unit) > 100 or not handling_unit:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_unit' must be a non-empty string with maximum length of 100 characters.\"}}\n        if len(handling_result) > 50 or not handling_result:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'handling_result' must be a non-empty string with maximum length of 50 characters.\"}}\n        if len(complaint_category) > 50 or not complaint_category:\n            return {'status': 'failure', 'content': {'error': \"Invalid input: 'complaint_category' must be a non-empty string with maximum length of 50 characters.\"}}\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n        \n        # Insert the complaint\n        cursor.execute(\n            'INSERT INTO \"complaints\" (\"complaint_time\", \"complaint_source\", \"complaint_content\", \"handling_unit\", \"handling_result\", \"complaint_category\") VALUES (?, ?, ?, ?, ?, ?)',\n            (complaint_time, complaint_source, complaint_content, handling_unit, handling_result, complaint_category)\n        )\n        conn.commit()\n        \n        # Retrieve the newly inserted complaint\n        cursor.execute(\n            'SELECT * FROM \"complaints\" WHERE \"complaint_id\" = ?',\n            (cursor.lastrowid,)\n        )\n        \n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n        \n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred during 'complaint creation': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()\n\ndef replace_case_type(case_type_name: str, new_case_type_name: str) -> Dict[str, Any]:\n    conn = None\n    try:\n        # Input validation\n        if not case_type_name or len(case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n        if not new_case_type_name or len(new_case_type_name) > 100:\n            return {\n                'status': 'failure',\n                'content': {'error': \"Invalid input: 'new_case_type_name' must be non-empty and <= 100 characters.\"}\n            }\n\n        conn = sqlite3.connect(os.getenv(\"SQLITE_PATH\"))\n        cursor = conn.cursor()\n\n        # Check if case type exists\n        cursor.execute('SELECT \"case_type_id\" FROM \"case_types\" WHERE \"case_type_name\" = ?', (case_type_name,))\n        if not cursor.fetchone():\n            return {\n                'status': 'failure',\n                'content': {'error': \"Not Found: No case type with the given name exists.\"}\n            }\n\n        # Update case type name\n        cursor.execute(\n            'UPDATE \"case_types\" SET \"case_type_name\" = ? WHERE \"case_type_name\" = ?',\n            (new_case_type_name, case_type_name)\n        )\n        conn.commit()\n\n        # Retrieve updated record\n        cursor.execute('SELECT * FROM \"case_types\" WHERE \"case_type_name\" = ?', (new_case_type_name,))\n        columns = [description[0].lower() for description in cursor.description]\n        result = dict(zip(columns, cursor.fetchone()))\n\n        return {'status': 'success', 'content': result}\n\n    except sqlite3.Error as e:\n        print(f\"Error: A database error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"Database error: {e}\"}}\n    except Exception as e:\n        print(f\"Error: An unexpected error occurred in 'replace_case_type': {e}\", file=sys.stderr)\n        return {'status': 'failure', 'content': {'error': f\"An unexpected error occurred: {e}\"}}\n    finally:\n        if conn:\n            conn.close()", "origin_sqlite_path": "/mnt/cfs_bj_mt/zengyucheng/workdir/workdir_for_tool_use/spider_op_meta_data_v3/stage_0_format_meta_data/nl2sql_0813/stage_0_sqlite_list/legal_case_management.sqlite", "target_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 50}, {"name": "case_parties", "seq": 93}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1001, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1008, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1004, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1008, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1008, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "origin_database": {"case_types": [{"case_type_id": 1001, "case_type_name": "Unit Case"}, {"case_type_id": 1002, "case_type_name": "Choice Case"}, {"case_type_id": 1003, "case_type_name": "Fine Case"}, {"case_type_id": 1004, "case_type_name": "Whom Case"}, {"case_type_id": 1005, "case_type_name": "Such Case"}, {"case_type_id": 1006, "case_type_name": "Agent Case"}, {"case_type_id": 1007, "case_type_name": "Camera Case"}, {"case_type_id": 1008, "case_type_name": "Walk Case"}, {"case_type_id": 1009, "case_type_name": "Quality Case"}, {"case_type_id": 1010, "case_type_name": "Onto Case"}, {"case_type_id": 1011, "case_type_name": "Expert Case"}, {"case_type_id": 1012, "case_type_name": "Employee Case"}, {"case_type_id": 1013, "case_type_name": "Body Case"}, {"case_type_id": 1014, "case_type_name": "Travel Case"}, {"case_type_id": 1015, "case_type_name": "Increase Case"}, {"case_type_id": 1016, "case_type_name": "Field Case"}, {"case_type_id": 1017, "case_type_name": "Hundred Case"}, {"case_type_id": 1018, "case_type_name": "Professional Case"}, {"case_type_id": 1019, "case_type_name": "Head Case"}, {"case_type_id": 1020, "case_type_name": "Onto Case"}], "sqlite_sequence": [{"name": "case_types", "seq": 1020}, {"name": "case_statuses", "seq": 1020}, {"name": "case_stages", "seq": 1020}, {"name": "cases", "seq": 1086}, {"name": "case_assignments", "seq": 50}, {"name": "case_parties", "seq": 93}, {"name": "case_proceedings", "seq": 24}, {"name": "complaints", "seq": 24}], "case_statuses": [{"case_status_id": 1001, "case_status_name": "Open"}, {"case_status_id": 1002, "case_status_name": "Closed"}, {"case_status_id": 1003, "case_status_name": "Pending"}, {"case_status_id": 1004, "case_status_name": "Appealed"}, {"case_status_id": 1005, "case_status_name": "Settled"}, {"case_status_id": 1006, "case_status_name": "Dismissed"}, {"case_status_id": 1007, "case_status_name": "Reopened"}, {"case_status_id": 1008, "case_status_name": "Archived"}, {"case_status_id": 1009, "case_status_name": "Transferred"}, {"case_status_id": 1010, "case_status_name": "Consolidated"}, {"case_status_id": 1011, "case_status_name": "Referred"}, {"case_status_id": 1012, "case_status_name": "Mediated"}, {"case_status_id": 1013, "case_status_name": "Arbitrated"}, {"case_status_id": 1014, "case_status_name": "Judged"}, {"case_status_id": 1015, "case_status_name": "Verdicted"}, {"case_status_id": 1016, "case_status_name": "Enforced"}, {"case_status_id": 1017, "case_status_name": "Executed"}, {"case_status_id": 1018, "case_status_name": "Vacated"}, {"case_status_id": 1019, "case_status_name": "Remanded"}, {"case_status_id": 1020, "case_status_name": "Certified"}], "case_stages": [{"case_stage_id": 1001, "case_stage_name": "Initial Review"}, {"case_stage_id": 1002, "case_stage_name": "Investigation"}, {"case_stage_id": 1003, "case_stage_name": "Pre-Trial"}, {"case_stage_id": 1004, "case_stage_name": "Trial"}, {"case_stage_id": 1005, "case_stage_name": "Appeal"}, {"case_stage_id": 1006, "case_stage_name": "Closed"}, {"case_stage_id": 1007, "case_stage_name": "Discovery"}, {"case_stage_id": 1008, "case_stage_name": "Deposition"}, {"case_stage_id": 1009, "case_stage_name": "Mediation"}, {"case_stage_id": 1010, "case_stage_name": "Arbitration"}, {"case_stage_id": 1011, "case_stage_name": "Settlement"}, {"case_stage_id": 1012, "case_stage_name": "Verdict"}, {"case_stage_id": 1013, "case_stage_name": "Judgment"}, {"case_stage_id": 1014, "case_stage_name": "Enforcement"}, {"case_stage_id": 1015, "case_stage_name": "Execution"}, {"case_stage_id": 1016, "case_stage_name": "Post-Trial"}, {"case_stage_id": 1017, "case_stage_name": "Remand"}, {"case_stage_id": 1018, "case_stage_name": "Certification"}, {"case_stage_id": 1019, "case_stage_name": "Supreme Review"}, {"case_stage_id": 1020, "case_stage_name": "Final"}], "cases": [{"case_id": 1061, "case_name": "Harper LLC v. Hernandez and Sons", "case_type_id": 1014, "acceptance_date": "2024-04-02", "case_status_id": 1010, "case_stage_id": 1005, "due_date": "2024-11-06"}, {"case_id": 1062, "case_name": "State v. Reyes", "case_type_id": 1013, "acceptance_date": "2024-03-27", "case_status_id": 1016, "case_stage_id": 1017, "due_date": "2026-06-24"}, {"case_id": 1063, "case_name": "State v. Davis", "case_type_id": 1009, "acceptance_date": "2024-03-14", "case_status_id": 1010, "case_stage_id": 1003, "due_date": "2025-01-09"}, {"case_id": 1064, "case_name": "State v. Hansen", "case_type_id": 1020, "acceptance_date": "2023-09-03", "case_status_id": 1012, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1065, "case_name": "Cruz Inc v. Brown, Sweeney and Harrington", "case_type_id": 1002, "acceptance_date": "2024-12-31", "case_status_id": 1002, "case_stage_id": 1016, "due_date": "2025-11-12"}, {"case_id": 1066, "case_name": "Duncan, Santiago and Harrison v. Smith-Anderson", "case_type_id": 1012, "acceptance_date": "2024-12-29", "case_status_id": 1020, "case_stage_id": 1006, "due_date": "2026-01-15"}, {"case_id": 1067, "case_name": "Moreno, Hernandez and Hernandez v. Garcia Ltd", "case_type_id": 1005, "acceptance_date": "2024-03-17", "case_status_id": 1010, "case_stage_id": 1006, "due_date": "2025-10-13"}, {"case_id": 1068, "case_name": "State v. Lopez", "case_type_id": 1018, "acceptance_date": "2024-12-29", "case_status_id": 1012, "case_stage_id": 1001, "due_date": "2025-02-10"}, {"case_id": 1069, "case_name": "Kim-Diaz v. Wheeler and Sons", "case_type_id": 1013, "acceptance_date": "2024-09-30", "case_status_id": 1006, "case_stage_id": 1019, "due_date": "2025-12-15"}, {"case_id": 1070, "case_name": "Robinson PLC v. Garrett-Hall", "case_type_id": 1013, "acceptance_date": "2025-01-31", "case_status_id": 1006, "case_stage_id": 1018, "due_date": "2025-12-16"}, {"case_id": 1071, "case_name": "Potter, Mcdonald and Miller v. Bradley, Pratt and Huber", "case_type_id": 1009, "acceptance_date": "2023-12-16", "case_status_id": 1004, "case_stage_id": 1013, "due_date": "2024-06-17"}, {"case_id": 1072, "case_name": "Rush-Barker v. Miller, Clark and Vincent", "case_type_id": 1004, "acceptance_date": "2023-09-08", "case_status_id": 1004, "case_stage_id": 1004, "due_date": "2024-04-06"}, {"case_id": 1073, "case_name": "Jones, Owens and Roberts v. Tyler, Flynn and Taylor", "case_type_id": 1007, "acceptance_date": "2025-07-03", "case_status_id": 1009, "case_stage_id": 1008, "due_date": "2026-04-17"}, {"case_id": 1074, "case_name": "Cunningham, Massey and Evans v. Jenkins, Clark and Hall", "case_type_id": 1014, "acceptance_date": "2023-08-18", "case_status_id": 1010, "case_stage_id": 1018, "due_date": "2025-08-15"}, {"case_id": 1075, "case_name": "State v. Sanchez", "case_type_id": 1017, "acceptance_date": "2023-09-03", "case_status_id": 1019, "case_stage_id": 1012, "due_date": "2026-07-10"}, {"case_id": 1076, "case_name": "Marshall-Wright v. Gonzalez Ltd", "case_type_id": 1018, "acceptance_date": "2024-05-05", "case_status_id": 1002, "case_stage_id": 1017, "due_date": "2024-11-29"}, {"case_id": 1077, "case_name": "Butler-Mcbride v. Thomas Inc", "case_type_id": 1015, "acceptance_date": "2025-03-23", "case_status_id": 1002, "case_stage_id": 1007, "due_date": "2025-09-09"}, {"case_id": 1078, "case_name": "Watson and Sons v. Jennings-Ruiz", "case_type_id": 1013, "acceptance_date": "2024-02-09", "case_status_id": 1016, "case_stage_id": 1011, "due_date": "2025-05-12"}, {"case_id": 1079, "case_name": "Garrett, Martinez and Mullins v. Pineda, Sanford and Williams", "case_type_id": 1004, "acceptance_date": "2024-02-23", "case_status_id": 1002, "case_stage_id": 1005, "due_date": "2024-06-08"}, {"case_id": 1080, "case_name": "Moreno, Wise and Stokes v. Martinez-Sellers", "case_type_id": 1006, "acceptance_date": "2024-04-28", "case_status_id": 1005, "case_stage_id": 1007, "due_date": "2024-08-07"}, {"case_id": 1081, "case_name": "State v. Torres", "case_type_id": 1011, "acceptance_date": "2024-09-30", "case_status_id": 1015, "case_stage_id": 1020, "due_date": "2025-12-26"}, {"case_id": 1082, "case_name": "State v. Abbott", "case_type_id": 1012, "acceptance_date": "2025-02-22", "case_status_id": 1007, "case_stage_id": 1013, "due_date": "2026-04-30"}, {"case_id": 1083, "case_name": "Harrell-Jones v. Perez, Thompson and Torres", "case_type_id": 1018, "acceptance_date": "2023-11-25", "case_status_id": 1004, "case_stage_id": 1005, "due_date": "2024-11-27"}, {"case_id": 1084, "case_name": "Gibbs-Lewis v. Hernandez, Henry and Marshall", "case_type_id": 1017, "acceptance_date": "2024-04-13", "case_status_id": 1019, "case_stage_id": 1009, "due_date": "2024-05-17"}, {"case_id": 1085, "case_name": "Rogers-Lee v. Sanchez-Frazier", "case_type_id": 1003, "acceptance_date": "2023-09-08", "case_status_id": 1001, "case_stage_id": 1006, "due_date": "2025-04-16"}, {"case_id": 1086, "case_name": "Simpson, Davis and Osborne v. Travis, Johnson and Thomas", "case_type_id": 1005, "acceptance_date": "2024-08-12", "case_status_id": 1007, "case_stage_id": 1017, "due_date": "2025-12-26"}], "case_assignments": [{"assignment_id": 1, "case_id": 1061, "assignment_unit": "Defense", "assignment_date": "2024-08-26", "assignment_content": "Participant two red. List well modern data pick. Strong hold between because fly center carry result. Rich still leg piece cover.", "assignment_due_date": "2024-11-01"}, {"assignment_id": 2, "case_id": 1061, "assignment_unit": "Investigation", "assignment_date": "2024-05-29", "assignment_content": "Run book style far whom doctor federal. Spend cup chair administration. Prove activity subject during.", "assignment_due_date": "2024-10-23"}, {"assignment_id": 3, "case_id": 1062, "assignment_unit": "Appeals", "assignment_date": "2024-11-15", "assignment_content": "Head resource because son he. Wear parent including although speak court room.", "assignment_due_date": "2024-12-05"}, {"assignment_id": 4, "case_id": 1063, "assignment_unit": "Prosecution", "assignment_date": "2024-05-30", "assignment_content": "Finish toward owner reveal. Tax avoid several that Republican every special.", "assignment_due_date": "2025-04-20"}, {"assignment_id": 5, "case_id": 1063, "assignment_unit": "Investigation", "assignment_date": "2024-09-30", "assignment_content": "Strategy consumer Mrs present physical candidate. Plant world college into. East weight professor stuff. Visit look pattern see.", "assignment_due_date": "2025-03-03"}, {"assignment_id": 6, "case_id": 1063, "assignment_unit": "Defense", "assignment_date": "2025-07-13", "assignment_content": "Interview during including reveal make pick.", "assignment_due_date": "2025-08-12"}, {"assignment_id": 7, "case_id": 1064, "assignment_unit": "Appeals", "assignment_date": "2023-11-27", "assignment_content": "Remember say money different win. Push prove understand PM hotel most serious.", "assignment_due_date": "2023-12-06"}, {"assignment_id": 8, "case_id": 1065, "assignment_unit": "Investigation", "assignment_date": "2025-07-08", "assignment_content": "Recent enjoy win best. Day as activity agency response minute.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 9, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-05-28", "assignment_content": "Mr chance kind evening which. Crime film seek myself I. Similar green foreign join.", "assignment_due_date": "2025-06-25"}, {"assignment_id": 10, "case_id": 1065, "assignment_unit": "Defense", "assignment_date": "2025-02-12", "assignment_content": "At future boy situation article state economy. Ground very wish among address.", "assignment_due_date": "2025-05-22"}, {"assignment_id": 11, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-07-17", "assignment_content": "Else mind thank tree for however. Amount ahead each current add agent campaign. Cell far house state smile court space.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 12, "case_id": 1066, "assignment_unit": "Investigation", "assignment_date": "2025-07-15", "assignment_content": "Current wish more various four cause do. Growth manage always.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 13, "case_id": 1066, "assignment_unit": "Defense", "assignment_date": "2025-04-02", "assignment_content": "Responsibility after maybe development. Growth including add section. Nothing ten all impact ten night.", "assignment_due_date": "2025-08-10"}, {"assignment_id": 14, "case_id": 1067, "assignment_unit": "Appeals", "assignment_date": "2024-09-26", "assignment_content": "Economic week including might type college note. Just important morning within.", "assignment_due_date": "2025-03-04"}, {"assignment_id": 15, "case_id": 1068, "assignment_unit": "Investigation", "assignment_date": "2025-02-03", "assignment_content": "Again life first pay adult alone economic include. Rate than industry picture friend. Oil account which arrive not woman air.", "assignment_due_date": "2025-05-21"}, {"assignment_id": 16, "case_id": 1068, "assignment_unit": "Prosecution", "assignment_date": "2025-04-20", "assignment_content": "Business whether with professor thank. Commercial mention goal someone trial car financial paper.", "assignment_due_date": "2025-06-28"}, {"assignment_id": 17, "case_id": 1069, "assignment_unit": "Prosecution", "assignment_date": "2024-11-25", "assignment_content": "Model rate television spend fight. Across important get himself role city we.", "assignment_due_date": "2025-06-12"}, {"assignment_id": 18, "case_id": 1069, "assignment_unit": "Investigation", "assignment_date": "2025-05-31", "assignment_content": "Talk daughter behind shoulder. Consumer parent know skill.", "assignment_due_date": "2025-06-15"}, {"assignment_id": 19, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-03-24", "assignment_content": "Few himself check idea word owner. Store manage note. Day two year difference series. Possible order alone role toward.", "assignment_due_date": "2025-07-06"}, {"assignment_id": 20, "case_id": 1070, "assignment_unit": "Investigation", "assignment_date": "2025-05-07", "assignment_content": "Hear them himself education friend he from student. Seat good recognize process. Son how hour should consider physical.", "assignment_due_date": "2025-07-27"}, {"assignment_id": 21, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2025-07-14", "assignment_content": "Theory even despite future somebody become.", "assignment_due_date": "2025-08-07"}, {"assignment_id": 22, "case_id": 1071, "assignment_unit": "Appeals", "assignment_date": "2024-06-23", "assignment_content": "Serve role lawyer develop might such shake. Speak determine sell especially.", "assignment_due_date": "2025-07-17"}, {"assignment_id": 23, "case_id": 1072, "assignment_unit": "Investigation", "assignment_date": "2024-07-17", "assignment_content": "Day travel cultural report get. Technology remember law market.", "assignment_due_date": "2024-11-23"}, {"assignment_id": 24, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2025-01-05", "assignment_content": "Letter six hard piece but.", "assignment_due_date": "2025-05-23"}, {"assignment_id": 25, "case_id": 1072, "assignment_unit": "Defense", "assignment_date": "2024-10-09", "assignment_content": "Huge lawyer contain without true we.", "assignment_due_date": "2024-10-21"}, {"assignment_id": 26, "case_id": 1073, "assignment_unit": "Defense", "assignment_date": "2025-07-19", "assignment_content": "Country resource hour plant some must. Effort hospital personal follow. Show others sister score ball gun.", "assignment_due_date": "2025-07-29"}, {"assignment_id": 27, "case_id": 1073, "assignment_unit": "Investigation", "assignment_date": "2025-07-18", "assignment_content": "Sport travel one. Rock expert because force run stock industry. Form center often language.", "assignment_due_date": "2025-07-18"}, {"assignment_id": 28, "case_id": 1073, "assignment_unit": "Appeals", "assignment_date": "2025-07-11", "assignment_content": "After so any mother dinner structure. Nor evening mention per great kind far series. Food push authority.", "assignment_due_date": "2025-08-01"}, {"assignment_id": 29, "case_id": 1074, "assignment_unit": "Defense", "assignment_date": "2023-11-27", "assignment_content": "Real impact difficult onto prove officer. Push life process claim.", "assignment_due_date": "2024-02-06"}, {"assignment_id": 30, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-03-18", "assignment_content": "Deep man determine add not. Say station paper front vote young.", "assignment_due_date": "2025-07-02"}, {"assignment_id": 31, "case_id": 1075, "assignment_unit": "Defense", "assignment_date": "2025-05-30", "assignment_content": "Particularly better describe another public staff. For necessary general nation key candidate.", "assignment_due_date": "2025-07-20"}, {"assignment_id": 32, "case_id": 1075, "assignment_unit": "Appeals", "assignment_date": "2025-08-11", "assignment_content": "Expect network modern realize who middle. Authority stock bit. Prevent second partner continue let few inside.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 33, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2024-10-05", "assignment_content": "Behind political exist share now no draw total. End travel together speech ever name. Per person tend sort begin second respond.", "assignment_due_date": "2025-03-15"}, {"assignment_id": 34, "case_id": 1076, "assignment_unit": "Defense", "assignment_date": "2025-05-01", "assignment_content": "Imagine technology thus common event case piece. Box husband impact price anyone fund. Today east anything open.", "assignment_due_date": "2025-05-25"}, {"assignment_id": 35, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-06-22", "assignment_content": "South fear price employee keep value mean. Defense from none then wish. Part very day employee heart.", "assignment_due_date": "2025-08-02"}, {"assignment_id": 36, "case_id": 1077, "assignment_unit": "Defense", "assignment_date": "2025-07-18", "assignment_content": "Suggest let region son blood already. Almost poor wear time development senior. Thousand who market toward.", "assignment_due_date": "2025-07-28"}, {"assignment_id": 37, "case_id": 1078, "assignment_unit": "Defense", "assignment_date": "2025-02-16", "assignment_content": "Everything than summer girl. Listen film marriage player contain war perhaps.", "assignment_due_date": "2025-04-14"}, {"assignment_id": 38, "case_id": 1079, "assignment_unit": "Defense", "assignment_date": "2025-06-18", "assignment_content": "Simply character throughout break network. In never join positive term. Wrong fight force certain within certain.", "assignment_due_date": "2025-07-03"}, {"assignment_id": 39, "case_id": 1079, "assignment_unit": "Appeals", "assignment_date": "2024-09-04", "assignment_content": "So growth matter team political short. Window ground occur. College imagine rather war.", "assignment_due_date": "2024-09-16"}, {"assignment_id": 40, "case_id": 1079, "assignment_unit": "Investigation", "assignment_date": "2024-03-01", "assignment_content": "Everybody cultural garden government professional talk view. Author indeed entire offer long north through line. Site fly teacher whole.", "assignment_due_date": "2025-07-24"}, {"assignment_id": 41, "case_id": 1080, "assignment_unit": "Appeals", "assignment_date": "2025-05-08", "assignment_content": "Give contain artist determine not. Could white tax American.", "assignment_due_date": "2025-07-19"}, {"assignment_id": 42, "case_id": 1081, "assignment_unit": "Prosecution", "assignment_date": "2025-03-13", "assignment_content": "Son friend how forget economic. Weight some civil on author bar brother. Call bit leave one.", "assignment_due_date": "2025-05-15"}, {"assignment_id": 43, "case_id": 1082, "assignment_unit": "Investigation", "assignment_date": "2025-03-28", "assignment_content": "Act people marriage. Pressure public wrong meeting board foot green institution. Story answer beat beat.", "assignment_due_date": "2025-08-11"}, {"assignment_id": 44, "case_id": 1082, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Place according community theory. Scene sense drop political. Cell when strong attorney relate behavior but.", "assignment_due_date": "2025-04-04"}, {"assignment_id": 45, "case_id": 1083, "assignment_unit": "Prosecution", "assignment_date": "2025-07-14", "assignment_content": "Politics player everything. Although cultural truth born true.", "assignment_due_date": "2025-07-21"}, {"assignment_id": 46, "case_id": 1084, "assignment_unit": "Investigation", "assignment_date": "2024-08-12", "assignment_content": "Many note discuss book smile hear. Leg style cup happen stock.", "assignment_due_date": "2025-01-31"}, {"assignment_id": 47, "case_id": 1085, "assignment_unit": "Defense", "assignment_date": "2024-09-09", "assignment_content": "Support thank recently use street. Keep develop drop perhaps. Rise resource each truth.", "assignment_due_date": "2025-05-01"}, {"assignment_id": 48, "case_id": 1086, "assignment_unit": "Appeals", "assignment_date": "2025-03-28", "assignment_content": "Majority a position majority west. As population discuss result. Particularly shoulder serious pretty point campaign pull guy. Less six man red too another.", "assignment_due_date": "2025-06-20"}, {"assignment_id": 49, "case_id": 1086, "assignment_unit": "Prosecution", "assignment_date": "2024-11-30", "assignment_content": "Treat charge human identify statement whether strong.", "assignment_due_date": "2025-06-23"}, {"assignment_id": 50, "case_id": 1086, "assignment_unit": "Defense", "assignment_date": "2024-11-25", "assignment_content": "Put community seat here involve yet understand. Production face certain tough mention impact police. Education find fear technology quite medical.", "assignment_due_date": "2025-07-22"}], "case_parties": [{"party_id": 1, "case_id": 1061, "party_type": "Plaintiff", "party_name": "David Ewing"}, {"party_id": 2, "case_id": 1061, "party_type": "Defendant", "party_name": "Jenny Wilson"}, {"party_id": 3, "case_id": 1061, "party_type": "Third Party", "party_name": "Williams Group"}, {"party_id": 4, "case_id": 1062, "party_type": "Plaintiff", "party_name": "Gerald Flores"}, {"party_id": 5, "case_id": 1062, "party_type": "Defendant", "party_name": "Cantrell, Bailey and Johnson"}, {"party_id": 6, "case_id": 1063, "party_type": "Plaintiff", "party_name": "Dawn Bridges"}, {"party_id": 7, "case_id": 1063, "party_type": "Defendant", "party_name": "Emily Gutierrez"}, {"party_id": 8, "case_id": 1063, "party_type": "Witness", "party_name": "Esparza PLC"}, {"party_id": 9, "case_id": 1063, "party_type": "Witness", "party_name": "Robert Thompson"}, {"party_id": 10, "case_id": 1064, "party_type": "Plaintiff", "party_name": "Holt-Choi"}, {"party_id": 11, "case_id": 1064, "party_type": "Defendant", "party_name": "Pittman, Mccarthy and Ortiz"}, {"party_id": 12, "case_id": 1064, "party_type": "Amicus", "party_name": "Torres PLC"}, {"party_id": 13, "case_id": 1065, "party_type": "Plaintiff", "party_name": "Anthony Russo"}, {"party_id": 14, "case_id": 1065, "party_type": "Defendant", "party_name": "Rose, Wood and Estrada"}, {"party_id": 15, "case_id": 1065, "party_type": "Witness", "party_name": "Bass-Reed"}, {"party_id": 16, "case_id": 1066, "party_type": "Plaintiff", "party_name": "Crystal Andersen"}, {"party_id": 17, "case_id": 1066, "party_type": "Defendant", "party_name": "Howell-Martinez"}, {"party_id": 18, "case_id": 1066, "party_type": "Witness", "party_name": "Karen Cook"}, {"party_id": 19, "case_id": 1067, "party_type": "Plaintiff", "party_name": "Byrd Ltd"}, {"party_id": 20, "case_id": 1067, "party_type": "Defendant", "party_name": "Dr. Patricia Gallagher"}, {"party_id": 21, "case_id": 1068, "party_type": "Plaintiff", "party_name": "Wheeler LLC"}, {"party_id": 22, "case_id": 1068, "party_type": "Defendant", "party_name": "Michael Bell"}, {"party_id": 23, "case_id": 1068, "party_type": "Third Party", "party_name": "Beltran, Thomas and Wood"}, {"party_id": 24, "case_id": 1068, "party_type": "Third Party", "party_name": "Denise Powell"}, {"party_id": 25, "case_id": 1068, "party_type": "Witness", "party_name": "Miller Ltd"}, {"party_id": 26, "case_id": 1069, "party_type": "Plaintiff", "party_name": "Peggy Russell"}, {"party_id": 27, "case_id": 1069, "party_type": "Defendant", "party_name": "Gonzalez Ltd"}, {"party_id": 28, "case_id": 1069, "party_type": "Witness", "party_name": "Schmidt PLC"}, {"party_id": 29, "case_id": 1069, "party_type": "Amicus", "party_name": "Adkins-Garza"}, {"party_id": 30, "case_id": 1069, "party_type": "Amicus", "party_name": "Jeffery Lewis"}, {"party_id": 31, "case_id": 1070, "party_type": "Plaintiff", "party_name": "Kennedy LLC"}, {"party_id": 32, "case_id": 1070, "party_type": "Defendant", "party_name": "Lloyd-Garrett"}, {"party_id": 33, "case_id": 1070, "party_type": "Third Party", "party_name": "Hampton Inc"}, {"party_id": 34, "case_id": 1070, "party_type": "Witness", "party_name": "Michael Powell"}, {"party_id": 35, "case_id": 1070, "party_type": "Witness", "party_name": "Steven May"}, {"party_id": 36, "case_id": 1071, "party_type": "Plaintiff", "party_name": "Reilly PLC"}, {"party_id": 37, "case_id": 1071, "party_type": "Defendant", "party_name": "Thomas Inc"}, {"party_id": 38, "case_id": 1071, "party_type": "Witness", "party_name": "Perry and Sons"}, {"party_id": 39, "case_id": 1071, "party_type": "Third Party", "party_name": "Taylor-Perez"}, {"party_id": 40, "case_id": 1071, "party_type": "Amicus", "party_name": "Vanessa Buchanan"}, {"party_id": 41, "case_id": 1072, "party_type": "Plaintiff", "party_name": "Shannon Park"}, {"party_id": 42, "case_id": 1072, "party_type": "Defendant", "party_name": "Lee, Soto and Wright"}, {"party_id": 43, "case_id": 1072, "party_type": "Witness", "party_name": "Meghan Riggs"}, {"party_id": 44, "case_id": 1072, "party_type": "Witness", "party_name": "Andrea Hughes"}, {"party_id": 45, "case_id": 1073, "party_type": "Plaintiff", "party_name": "Cain PLC"}, {"party_id": 46, "case_id": 1073, "party_type": "Defendant", "party_name": "Mary Duffy"}, {"party_id": 47, "case_id": 1073, "party_type": "Third Party", "party_name": "Martha Wilson"}, {"party_id": 48, "case_id": 1073, "party_type": "Witness", "party_name": "Tina Scott"}, {"party_id": 49, "case_id": 1074, "party_type": "Plaintiff", "party_name": "John Decker"}, {"party_id": 50, "case_id": 1074, "party_type": "Defendant", "party_name": "Olsen Ltd"}, {"party_id": 51, "case_id": 1074, "party_type": "Amicus", "party_name": "Nguyen, Sanchez and Schneider"}, {"party_id": 52, "case_id": 1075, "party_type": "Plaintiff", "party_name": "Cortez-Richard"}, {"party_id": 53, "case_id": 1075, "party_type": "Defendant", "party_name": "Robertson and Sons"}, {"party_id": 54, "case_id": 1075, "party_type": "Amicus", "party_name": "Christopher Smith"}, {"party_id": 55, "case_id": 1076, "party_type": "Plaintiff", "party_name": "Scott PLC"}, {"party_id": 56, "case_id": 1076, "party_type": "Defendant", "party_name": "Smith-Campbell"}, {"party_id": 57, "case_id": 1077, "party_type": "Plaintiff", "party_name": "Le-Avery"}, {"party_id": 58, "case_id": 1077, "party_type": "Defendant", "party_name": "Cruz, Woodward and Walter"}, {"party_id": 59, "case_id": 1078, "party_type": "Plaintiff", "party_name": "Turner-Reed"}, {"party_id": 60, "case_id": 1078, "party_type": "Defendant", "party_name": "Alan Henderson"}, {"party_id": 61, "case_id": 1078, "party_type": "Amicus", "party_name": "David Clark"}, {"party_id": 62, "case_id": 1078, "party_type": "Third Party", "party_name": "Thomas Ramirez"}, {"party_id": 63, "case_id": 1078, "party_type": "Amicus", "party_name": "Caitlin Dalton"}, {"party_id": 64, "case_id": 1079, "party_type": "Plaintiff", "party_name": "Rodriguez PLC"}, {"party_id": 65, "case_id": 1079, "party_type": "Defendant", "party_name": "Amanda Gonzales"}, {"party_id": 66, "case_id": 1080, "party_type": "Plaintiff", "party_name": "Taylor Bell"}, {"party_id": 67, "case_id": 1080, "party_type": "Defendant", "party_name": "Lauren Cohen"}, {"party_id": 68, "case_id": 1080, "party_type": "Third Party", "party_name": "Belinda Osborn"}, {"party_id": 69, "case_id": 1080, "party_type": "Third Party", "party_name": "Shannon Smith DVM"}, {"party_id": 70, "case_id": 1081, "party_type": "Plaintiff", "party_name": "Boone Inc"}, {"party_id": 71, "case_id": 1081, "party_type": "Defendant", "party_name": "Zavala LLC"}, {"party_id": 72, "case_id": 1081, "party_type": "Third Party", "party_name": "Smith-Daniel"}, {"party_id": 73, "case_id": 1081, "party_type": "Amicus", "party_name": "Bruce Graham"}, {"party_id": 74, "case_id": 1081, "party_type": "Third Party", "party_name": "Knox Group"}, {"party_id": 75, "case_id": 1082, "party_type": "Plaintiff", "party_name": "Green, Blair and Durham"}, {"party_id": 76, "case_id": 1082, "party_type": "Defendant", "party_name": "Williams, Smith and Martinez"}, {"party_id": 77, "case_id": 1082, "party_type": "Third Party", "party_name": "Harding, Morgan and Gordon"}, {"party_id": 78, "case_id": 1082, "party_type": "Witness", "party_name": "Jack Carter"}, {"party_id": 79, "case_id": 1082, "party_type": "Amicus", "party_name": "Juan Walters"}, {"party_id": 80, "case_id": 1083, "party_type": "Plaintiff", "party_name": "Lutz, Barrera and Franklin"}, {"party_id": 81, "case_id": 1083, "party_type": "Defendant", "party_name": "Miller, Gardner and Campbell"}, {"party_id": 82, "case_id": 1083, "party_type": "Third Party", "party_name": "Michael Williams"}, {"party_id": 83, "case_id": 1083, "party_type": "Third Party", "party_name": "Tracey Bridges"}, {"party_id": 84, "case_id": 1083, "party_type": "Third Party", "party_name": "White-Li"}, {"party_id": 85, "case_id": 1084, "party_type": "Plaintiff", "party_name": "Jose Murphy"}, {"party_id": 86, "case_id": 1084, "party_type": "Defendant", "party_name": "Kyle Bradford"}, {"party_id": 87, "case_id": 1084, "party_type": "Witness", "party_name": "Brett Thompson"}, {"party_id": 88, "case_id": 1085, "party_type": "Plaintiff", "party_name": "Samuel Rivera"}, {"party_id": 89, "case_id": 1085, "party_type": "Defendant", "party_name": "Richard Bautista"}, {"party_id": 90, "case_id": 1086, "party_type": "Plaintiff", "party_name": "Nielsen PLC"}, {"party_id": 91, "case_id": 1086, "party_type": "Defendant", "party_name": "Jordan Garza"}, {"party_id": 92, "case_id": 1086, "party_type": "Third Party", "party_name": "Smith Group"}, {"party_id": 93, "case_id": 1086, "party_type": "Third Party", "party_name": "Matthew Fleming"}], "case_proceedings": [{"proceeding_id": 1, "case_id": 1062, "court_name": "Supreme Court", "case_reason": "Economic whatever expect drop find.", "progress_status": "Appealed"}, {"proceeding_id": 2, "case_id": 1063, "court_name": "Special Tribunal", "case_reason": "Third stay wish truth behind down.", "progress_status": "In Progress"}, {"proceeding_id": 3, "case_id": 1063, "court_name": "District Court", "case_reason": "Assume surface take ground international dinner.", "progress_status": "Appealed"}, {"proceeding_id": 4, "case_id": 1065, "court_name": "District Court", "case_reason": "Method unit meet nature down think.", "progress_status": "Pending"}, {"proceeding_id": 5, "case_id": 1065, "court_name": "Supreme Court", "case_reason": "Though five cover rock human world.", "progress_status": "Pending"}, {"proceeding_id": 6, "case_id": 1068, "court_name": "Appeals Court", "case_reason": "Heart down thought study.", "progress_status": "Pending"}, {"proceeding_id": 7, "case_id": 1068, "court_name": "Supreme Court", "case_reason": "Never fill senior section natural appear.", "progress_status": "Pending"}, {"proceeding_id": 8, "case_id": 1069, "court_name": "Appeals Court", "case_reason": "Involve voice both decide center turn.", "progress_status": "Pending"}, {"proceeding_id": 9, "case_id": 1070, "court_name": "Supreme Court", "case_reason": "Per mission until each rock.", "progress_status": "In Progress"}, {"proceeding_id": 10, "case_id": 1071, "court_name": "Appeals Court", "case_reason": "Risk technology future traditional audience.", "progress_status": "Completed"}, {"proceeding_id": 11, "case_id": 1072, "court_name": "Supreme Court", "case_reason": "Mission fire daughter help.", "progress_status": "Pending"}, {"proceeding_id": 12, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Trade whose skill suggest not travel forget.", "progress_status": "In Progress"}, {"proceeding_id": 13, "case_id": 1073, "court_name": "Special Tribunal", "case_reason": "Yard usually reflect seek small act while.", "progress_status": "Completed"}, {"proceeding_id": 14, "case_id": 1074, "court_name": "Appeals Court", "case_reason": "Beyond hot along industry several of plant mother.", "progress_status": "Completed"}, {"proceeding_id": 15, "case_id": 1077, "court_name": "Appeals Court", "case_reason": "Individual whether wall still improve.", "progress_status": "In Progress"}, {"proceeding_id": 16, "case_id": 1078, "court_name": "District Court", "case_reason": "Return able government billion difficult.", "progress_status": "Appealed"}, {"proceeding_id": 17, "case_id": 1079, "court_name": "Supreme Court", "case_reason": "Company visit our occur language raise.", "progress_status": "Appealed"}, {"proceeding_id": 18, "case_id": 1080, "court_name": "Special Tribunal", "case_reason": "At song address for.", "progress_status": "In Progress"}, {"proceeding_id": 19, "case_id": 1080, "court_name": "Supreme Court", "case_reason": "Himself human successful suffer as.", "progress_status": "In Progress"}, {"proceeding_id": 20, "case_id": 1081, "court_name": "Supreme Court", "case_reason": "Security step commercial outside between.", "progress_status": "Appealed"}, {"proceeding_id": 21, "case_id": 1083, "court_name": "Special Tribunal", "case_reason": "Tree car discuss old according spend this bill.", "progress_status": "In Progress"}, {"proceeding_id": 22, "case_id": 1084, "court_name": "Appeals Court", "case_reason": "Better skin realize behind Congress him.", "progress_status": "In Progress"}, {"proceeding_id": 23, "case_id": 1085, "court_name": "District Court", "case_reason": "Ahead by do describe themselves system total.", "progress_status": "In Progress"}, {"proceeding_id": 24, "case_id": 1086, "court_name": "Supreme Court", "case_reason": "Ago should simple agent seem generation.", "progress_status": "Appealed"}], "complaints": [{"complaint_id": 1, "complaint_time": "2025-05-25", "complaint_source": "Email", "complaint_content": "Community real song area light.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 2, "complaint_time": "2024-12-08", "complaint_source": "Letter", "complaint_content": "Glass continue prepare strategy shake away. You traditional investment cause.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 3, "complaint_time": "2025-06-15", "complaint_source": "Email", "complaint_content": "Again us on. A feel choose skill be about.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Privacy"}, {"complaint_id": 4, "complaint_time": "2024-10-23", "complaint_source": "Email", "complaint_content": "Bar sign effect set.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 5, "complaint_time": "2025-04-19", "complaint_source": "In Person", "complaint_content": "Describe represent far different seven second quickly some.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Service"}, {"complaint_id": 6, "complaint_time": "2024-10-17", "complaint_source": "Email", "complaint_content": "Pick money college. Expert charge government politics.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 7, "complaint_time": "2025-08-03", "complaint_source": "In Person", "complaint_content": "So company student everybody every theory. True appear ever worry trade.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Privacy"}, {"complaint_id": 8, "complaint_time": "2024-10-20", "complaint_source": "In Person", "complaint_content": "Election allow single common behavior must.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Billing"}, {"complaint_id": 9, "complaint_time": "2025-06-29", "complaint_source": "Letter", "complaint_content": "Middle decide result foot war performance attack spring.", "handling_unit": "Compliance", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 10, "complaint_time": "2024-12-01", "complaint_source": "Phone", "complaint_content": "Hot brother level. Center cover catch staff about.", "handling_unit": "HR", "handling_result": "Rejected", "complaint_category": "Quality"}, {"complaint_id": 11, "complaint_time": "2025-08-10", "complaint_source": "Phone", "complaint_content": "Light Republican bring whom. Chair certain hospital deep research.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 12, "complaint_time": "2025-02-14", "complaint_source": "Letter", "complaint_content": "Nor political themselves indeed center seem job.", "handling_unit": "Legal", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 13, "complaint_time": "2025-08-12", "complaint_source": "Letter", "complaint_content": "That theory possible along family. Rise east true.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Billing"}, {"complaint_id": 14, "complaint_time": "2024-11-05", "complaint_source": "In Person", "complaint_content": "Woman season feeling thing.", "handling_unit": "Compliance", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 15, "complaint_time": "2024-09-12", "complaint_source": "Letter", "complaint_content": "Southern sing keep investment full instead.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 16, "complaint_time": "2024-10-16", "complaint_source": "Phone", "complaint_content": "Sometimes capital box option.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Service"}, {"complaint_id": 17, "complaint_time": "2024-10-07", "complaint_source": "In Person", "complaint_content": "Leave light campaign actually not. Choice media possible success resource.", "handling_unit": "Legal", "handling_result": "Escalated", "complaint_category": "Quality"}, {"complaint_id": 18, "complaint_time": "2025-03-22", "complaint_source": "Email", "complaint_content": "Old left way need line head official.", "handling_unit": "HR", "handling_result": "Pending", "complaint_category": "Quality"}, {"complaint_id": 19, "complaint_time": "2025-01-01", "complaint_source": "Letter", "complaint_content": "No trade should manage prove.", "handling_unit": "HR", "handling_result": "Escalated", "complaint_category": "Service"}, {"complaint_id": 20, "complaint_time": "2025-02-20", "complaint_source": "Letter", "complaint_content": "Sometimes group center boy fish green pull. Sense fall simple exist.", "handling_unit": "Customer Service", "handling_result": "Pending", "complaint_category": "Service"}, {"complaint_id": 21, "complaint_time": "2024-10-08", "complaint_source": "Phone", "complaint_content": "Why former enough could around. Rock someone writer.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 22, "complaint_time": "2024-11-19", "complaint_source": "Phone", "complaint_content": "Trade factor property draw worker technology next. Raise hour price believe newspaper better participant.", "handling_unit": "Customer Service", "handling_result": "Rejected", "complaint_category": "Privacy"}, {"complaint_id": 23, "complaint_time": "2024-08-21", "complaint_source": "Email", "complaint_content": "Bad stage conference. Current nothing peace continue finally final there.", "handling_unit": "HR", "handling_result": "Resolved", "complaint_category": "Billing"}, {"complaint_id": 24, "complaint_time": "2024-09-21", "complaint_source": "In Person", "complaint_content": "By practice amount window similar room ability.", "handling_unit": "Customer Service", "handling_result": "Escalated", "complaint_category": "Privacy"}]}, "diff_between_databases": 3, "status": "STOP"}
